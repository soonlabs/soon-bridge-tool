/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export type DeploymentStruct = { name: string; addr: string };

export type DeploymentStructOutput = [string, string] & {
  name: string;
  addr: string;
};

export interface DeployInterface extends utils.Interface {
  functions: {
    "IS_SCRIPT()": FunctionFragment;
    "cfg()": FunctionFragment;
    "deployAddressManager()": FunctionFragment;
    "deployAnchorStateRegistry()": FunctionFragment;
    "deployDataAvailabilityChallenge()": FunctionFragment;
    "deployDataAvailabilityChallengeProxy()": FunctionFragment;
    "deployDelayedWETH()": FunctionFragment;
    "deployDisputeGameFactory()": FunctionFragment;
    "deployERC1967Proxy(string)": FunctionFragment;
    "deployERC1967ProxyWithOwner(string,address)": FunctionFragment;
    "deployImplementations()": FunctionFragment;
    "deployL1CrossDomainMessenger()": FunctionFragment;
    "deployL1CrossDomainMessengerProxy()": FunctionFragment;
    "deployL1ERC721Bridge()": FunctionFragment;
    "deployL1StandardBridge()": FunctionFragment;
    "deployL1StandardBridgeProxy()": FunctionFragment;
    "deployL2OutputOracle()": FunctionFragment;
    "deployMips()": FunctionFragment;
    "deployOptimismMintableERC20Factory()": FunctionFragment;
    "deployOptimismPortal()": FunctionFragment;
    "deployOptimismPortal2()": FunctionFragment;
    "deployPreimageOracle()": FunctionFragment;
    "deployProtocolVersions()": FunctionFragment;
    "deployProxies()": FunctionFragment;
    "deployProxyAdmin()": FunctionFragment;
    "deploySafe(string)": FunctionFragment;
    "deploySafe(string,address[],uint256,bool)": FunctionFragment;
    "deployStorageSetter()": FunctionFragment;
    "deploySuperchainConfig()": FunctionFragment;
    "deploySystemConfig()": FunctionFragment;
    "get(string)": FunctionFragment;
    "getAddress(string)": FunctionFragment;
    "has(string)": FunctionFragment;
    "initializeAnchorStateRegistry()": FunctionFragment;
    "initializeDataAvailabilityChallenge()": FunctionFragment;
    "initializeDelayedWETH()": FunctionFragment;
    "initializeDisputeGameFactory()": FunctionFragment;
    "initializeImplementations()": FunctionFragment;
    "initializeL1CrossDomainMessenger()": FunctionFragment;
    "initializeL1ERC721Bridge()": FunctionFragment;
    "initializeL1StandardBridge()": FunctionFragment;
    "initializeL2OutputOracle()": FunctionFragment;
    "initializeOptimismMintableERC20Factory()": FunctionFragment;
    "initializeOptimismPortal()": FunctionFragment;
    "initializeOptimismPortal2()": FunctionFragment;
    "initializePermissionedDelayedWETH()": FunctionFragment;
    "initializeProtocolVersions()": FunctionFragment;
    "initializeSuperchainConfig()": FunctionFragment;
    "initializeSystemConfig()": FunctionFragment;
    "loadInitializedSlot(string)": FunctionFragment;
    "mustGetAddress(string)": FunctionFragment;
    "newDeployments()": FunctionFragment;
    "prankDeployment(string,address)": FunctionFragment;
    "removeDeployerFromSafe(string,uint256)": FunctionFragment;
    "run()": FunctionFragment;
    "runWithStateDiff()": FunctionFragment;
    "runWithStateDump()": FunctionFragment;
    "save(string,address)": FunctionFragment;
    "setAlphabetFaultGameImplementation(bool)": FunctionFragment;
    "setCannonFaultGameImplementation(bool)": FunctionFragment;
    "setFastFaultGameImplementation(bool)": FunctionFragment;
    "setPermissionedCannonFaultGameImplementation(bool)": FunctionFragment;
    "setUp()": FunctionFragment;
    "setupOpAltDA()": FunctionFragment;
    "setupOpChain()": FunctionFragment;
    "setupSuperchain()": FunctionFragment;
    "transferAddressManagerOwnership()": FunctionFragment;
    "transferDelayedWETHOwnership()": FunctionFragment;
    "transferDisputeGameFactoryOwnership()": FunctionFragment;
    "transferPermissionedDelayedWETHOwnership()": FunctionFragment;
    "transferProxyAdminOwnership()": FunctionFragment;
    "transferProxyToProxyAdmin(string)": FunctionFragment;
    "upgradeL1CrossDomainMessenger()": FunctionFragment;
    "upgradeL1ERC721Bridge()": FunctionFragment;
    "upgradeL1StandardBridge()": FunctionFragment;
    "upgradeL2OutputOracle()": FunctionFragment;
    "upgradeOptimismPortal()": FunctionFragment;
    "upgradeSystemConfig()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "IS_SCRIPT"
      | "cfg"
      | "deployAddressManager"
      | "deployAnchorStateRegistry"
      | "deployDataAvailabilityChallenge"
      | "deployDataAvailabilityChallengeProxy"
      | "deployDelayedWETH"
      | "deployDisputeGameFactory"
      | "deployERC1967Proxy"
      | "deployERC1967ProxyWithOwner"
      | "deployImplementations"
      | "deployL1CrossDomainMessenger"
      | "deployL1CrossDomainMessengerProxy"
      | "deployL1ERC721Bridge"
      | "deployL1StandardBridge"
      | "deployL1StandardBridgeProxy"
      | "deployL2OutputOracle"
      | "deployMips"
      | "deployOptimismMintableERC20Factory"
      | "deployOptimismPortal"
      | "deployOptimismPortal2"
      | "deployPreimageOracle"
      | "deployProtocolVersions"
      | "deployProxies"
      | "deployProxyAdmin"
      | "deploySafe(string)"
      | "deploySafe(string,address[],uint256,bool)"
      | "deployStorageSetter"
      | "deploySuperchainConfig"
      | "deploySystemConfig"
      | "get"
      | "getAddress"
      | "has"
      | "initializeAnchorStateRegistry"
      | "initializeDataAvailabilityChallenge"
      | "initializeDelayedWETH"
      | "initializeDisputeGameFactory"
      | "initializeImplementations"
      | "initializeL1CrossDomainMessenger"
      | "initializeL1ERC721Bridge"
      | "initializeL1StandardBridge"
      | "initializeL2OutputOracle"
      | "initializeOptimismMintableERC20Factory"
      | "initializeOptimismPortal"
      | "initializeOptimismPortal2"
      | "initializePermissionedDelayedWETH"
      | "initializeProtocolVersions"
      | "initializeSuperchainConfig"
      | "initializeSystemConfig"
      | "loadInitializedSlot"
      | "mustGetAddress"
      | "newDeployments"
      | "prankDeployment"
      | "removeDeployerFromSafe"
      | "run"
      | "runWithStateDiff"
      | "runWithStateDump"
      | "save"
      | "setAlphabetFaultGameImplementation"
      | "setCannonFaultGameImplementation"
      | "setFastFaultGameImplementation"
      | "setPermissionedCannonFaultGameImplementation"
      | "setUp"
      | "setupOpAltDA"
      | "setupOpChain"
      | "setupSuperchain"
      | "transferAddressManagerOwnership"
      | "transferDelayedWETHOwnership"
      | "transferDisputeGameFactoryOwnership"
      | "transferPermissionedDelayedWETHOwnership"
      | "transferProxyAdminOwnership"
      | "transferProxyToProxyAdmin"
      | "upgradeL1CrossDomainMessenger"
      | "upgradeL1ERC721Bridge"
      | "upgradeL1StandardBridge"
      | "upgradeL2OutputOracle"
      | "upgradeOptimismPortal"
      | "upgradeSystemConfig"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "IS_SCRIPT", values?: undefined): string;
  encodeFunctionData(functionFragment: "cfg", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "deployAddressManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployAnchorStateRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployDataAvailabilityChallenge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployDataAvailabilityChallengeProxy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployDelayedWETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployDisputeGameFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployERC1967Proxy",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "deployERC1967ProxyWithOwner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deployImplementations",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL1CrossDomainMessenger",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL1CrossDomainMessengerProxy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL1ERC721Bridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL1StandardBridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL1StandardBridgeProxy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployL2OutputOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployMips",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployOptimismMintableERC20Factory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployOptimismPortal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployOptimismPortal2",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployPreimageOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployProtocolVersions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployProxies",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployProxyAdmin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deploySafe(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "deploySafe(string,address[],uint256,bool)",
    values: [string, string[], BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "deployStorageSetter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deploySuperchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deploySystemConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "get", values: [string]): string;
  encodeFunctionData(functionFragment: "getAddress", values: [string]): string;
  encodeFunctionData(functionFragment: "has", values: [string]): string;
  encodeFunctionData(
    functionFragment: "initializeAnchorStateRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeDataAvailabilityChallenge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeDelayedWETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeDisputeGameFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeImplementations",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeL1CrossDomainMessenger",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeL1ERC721Bridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeL1StandardBridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeL2OutputOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeOptimismMintableERC20Factory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeOptimismPortal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeOptimismPortal2",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializePermissionedDelayedWETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeProtocolVersions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeSuperchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeSystemConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "loadInitializedSlot",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "mustGetAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "newDeployments",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "prankDeployment",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeDeployerFromSafe",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "run", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "runWithStateDiff",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "runWithStateDump",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "save",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAlphabetFaultGameImplementation",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setCannonFaultGameImplementation",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFastFaultGameImplementation",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setPermissionedCannonFaultGameImplementation",
    values: [boolean]
  ): string;
  encodeFunctionData(functionFragment: "setUp", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setupOpAltDA",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setupOpChain",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setupSuperchain",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferAddressManagerOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferDelayedWETHOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferDisputeGameFactoryOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferPermissionedDelayedWETHOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferProxyAdminOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferProxyToProxyAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeL1CrossDomainMessenger",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeL1ERC721Bridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeL1StandardBridge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeL2OutputOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeOptimismPortal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeSystemConfig",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "IS_SCRIPT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cfg", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deployAddressManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployAnchorStateRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployDataAvailabilityChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployDataAvailabilityChallengeProxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployDelayedWETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployDisputeGameFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployERC1967Proxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployERC1967ProxyWithOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployImplementations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL1CrossDomainMessenger",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL1CrossDomainMessengerProxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL1ERC721Bridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL1StandardBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL1StandardBridgeProxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployL2OutputOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deployMips", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deployOptimismMintableERC20Factory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployOptimismPortal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployOptimismPortal2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployPreimageOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployProtocolVersions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployProxies",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployProxyAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deploySafe(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deploySafe(string,address[],uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployStorageSetter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deploySuperchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deploySystemConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "get", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAddress", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "has", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initializeAnchorStateRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeDataAvailabilityChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeDelayedWETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeDisputeGameFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeImplementations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeL1CrossDomainMessenger",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeL1ERC721Bridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeL1StandardBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeL2OutputOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeOptimismMintableERC20Factory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeOptimismPortal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeOptimismPortal2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializePermissionedDelayedWETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeProtocolVersions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeSuperchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeSystemConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadInitializedSlot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mustGetAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newDeployments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prankDeployment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeDeployerFromSafe",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "run", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "runWithStateDiff",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "runWithStateDump",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "save", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAlphabetFaultGameImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCannonFaultGameImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFastFaultGameImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPermissionedCannonFaultGameImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setupOpAltDA",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setupOpChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setupSuperchain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAddressManagerOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferDelayedWETHOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferDisputeGameFactoryOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferPermissionedDelayedWETHOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferProxyAdminOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferProxyToProxyAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeL1CrossDomainMessenger",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeL1ERC721Bridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeL1StandardBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeL2OutputOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeOptimismPortal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeSystemConfig",
    data: BytesLike
  ): Result;

  events: {};
}

export interface Deploy extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DeployInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    IS_SCRIPT(overrides?: CallOverrides): Promise<[boolean]>;

    cfg(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Deploy the AddressManager
     */
    deployAddressManager(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the AnchorStateRegistry
     */
    deployAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the DataAvailabilityChallenge
     */
    deployDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the DataAvailabilityChallengeProxy
     */
    deployDataAvailabilityChallengeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    deployDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the DisputeGameFactory
     */
    deployDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploys an ERC1967Proxy contract with the ProxyAdmin as the owner.
     * @param _name The name of the proxy contract to be deployed.
     */
    deployERC1967Proxy(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploys an ERC1967Proxy contract with a specified owner.
     * @param _name The name of the proxy contract to be deployed.
     * @param _proxyOwner The address of the owner of the proxy contract.
     */
    deployERC1967ProxyWithOwner(
      _name: string,
      _proxyOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy all of the implementations
     */
    deployImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L1CrossDomainMessenger
     */
    deployL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L1CrossDomainMessengerProxy using a ResolvedDelegateProxy
     */
    deployL1CrossDomainMessengerProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L1ERC721Bridge
     */
    deployL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L1StandardBridge
     */
    deployL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L1StandardBridgeProxy using a ChugSplashProxy
     */
    deployL1StandardBridgeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the L2OutputOracle
     */
    deployL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy Mips
     */
    deployMips(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the OptimismMintableERC20Factory
     */
    deployOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the OptimismPortal
     */
    deployOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the OptimismPortal2
     */
    deployOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the PreimageOracle
     */
    deployPreimageOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the ProtocolVersions
     */
    deployProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy all of the proxies
     */
    deployProxies(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the ProxyAdmin
     */
    deployProxyAdmin(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the Safe
     */
    "deploySafe(string)"(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy a new Safe contract. If the keepDeployer option is used to enable further setup actions, then         the removeDeployerFromSafe() function should be called on that safe after setup is complete.         Note this function does not have the broadcast modifier.
     * @param _keepDeployer Wether or not the deployer address will be added as an owner of the Safe.
     * @param _name The name of the Safe to deploy.
     * @param _owners The owners of the Safe.
     * @param _threshold The threshold of the Safe.
     */
    "deploySafe(string,address[],uint256,bool)"(
      _name: string,
      _owners: string[],
      _threshold: BigNumberish,
      _keepDeployer: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the StorageSetter contract, used for upgrades.
     */
    deployStorageSetter(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the SuperchainConfig contract
     */
    deploySuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy the SystemConfig
     */
    deploySystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns a deployment that is suitable to be used to interact with contracts.
     * @param _name The name of the deployment.
     */
    get(
      _name: string,
      overrides?: CallOverrides
    ): Promise<[DeploymentStructOutput]>;

    /**
     * Returns the address of a deployment. Also handles the predeploys.
     * @param _name The name of the deployment.
     */
    getAddress(_name: string, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns whether or not a particular deployment exists.
     * @param _name The name of the deployment.
     */
    has(_name: string, overrides?: CallOverrides): Promise<[boolean]>;

    initializeAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the DataAvailabilityChallenge
     */
    initializeDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    initializeDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the DisputeGameFactory
     */
    initializeDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize all of the implementations
     */
    initializeImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * initializeL1CrossDomainMessenger
     */
    initializeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the L1ERC721Bridge
     */
    initializeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the L1StandardBridge
     */
    initializeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the L2OutputOracle
     */
    initializeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the OptimismMintableERC20Factory
     */
    initializeOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the OptimismPortal
     */
    initializeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the OptimismPortal2
     */
    initializeOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    initializePermissionedDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    initializeProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the SuperchainConfig
     */
    initializeSuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialize the SystemConfig
     */
    initializeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the value of the internal `_initialized` storage slot for a given contract.
     */
    loadInitializedSlot(
      _contractName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of a deployment and reverts if the deployment         does not exist.
     */
    mustGetAddress(_name: string, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns all of the deployments done in the current context.
     */
    newDeployments(
      overrides?: CallOverrides
    ): Promise<[DeploymentStructOutput[]]>;

    /**
     * Stubs a deployment retrieved through `get`.
     * @param _addr The mock address of the deployment.
     * @param _name The name of the deployment.
     */
    prankDeployment(
      _name: string,
      _addr: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * If the keepDeployer option was used with deploySafe(), this function can be used to remove the deployer.         Note this function does not have the broadcast modifier.
     */
    removeDeployerFromSafe(
      _name: string,
      _newThreshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy all of the L1 contracts necessary for a full Superchain with a single Op Chain.
     */
    run(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy all L1 contracts and write the state diff to a file.
     */
    runWithStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    runWithStateDump(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Appends a deployment to disk as a JSON deploy artifact.
     * @param _deployed The address of the deployment.
     * @param _name The name of the deployment.
     */
    save(
      _name: string,
      _deployed: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setAlphabetFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the implementation for the `CANNON` game type in the `DisputeGameFactory`
     */
    setCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setFastFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the implementation for the `PERMISSIONED_CANNON` game type in the `DisputeGameFactory`
     */
    setPermissionedCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets up the artifacts contract.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Add AltDA setup to the OP chain
     */
    setupOpAltDA(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy a new OP Chain, with an existing SuperchainConfig provided
     */
    setupOpChain(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploy a full system with a new SuperchainConfig         The Superchain system has 2 singleton contracts which lie outside of an OP Chain:         1. The SuperchainConfig contract         2. The ProtocolVersions contract
     */
    setupSuperchain(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of the address manager to the ProxyAdmin
     */
    transferAddressManagerOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of the DelayedWETH contract to the final system owner
     */
    transferDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of the DisputeGameFactory contract to the final system owner
     */
    transferDisputeGameFactoryOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of the permissioned DelayedWETH contract to the final system owner
     */
    transferPermissionedDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of the ProxyAdmin contract to the final system owner
     */
    transferProxyAdminOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfer ownership of a Proxy to the ProxyAdmin contract         This is expected to be used in conjusting with deployERC1967ProxyWithOwner after setup actions         have been performed on the proxy.
     * @param _name The name of the proxy to transfer ownership of.
     */
    transferProxyToProxyAdmin(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the L1CrossDomainMessenger
     */
    upgradeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the L1ERC721Bridge
     */
    upgradeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the L1StandardBridge
     */
    upgradeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the L2OutputOracle
     */
    upgradeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the OptimismPortal
     */
    upgradeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the SystemConfig
     */
    upgradeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  IS_SCRIPT(overrides?: CallOverrides): Promise<boolean>;

  cfg(overrides?: CallOverrides): Promise<string>;

  /**
   * Deploy the AddressManager
   */
  deployAddressManager(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the AnchorStateRegistry
   */
  deployAnchorStateRegistry(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the DataAvailabilityChallenge
   */
  deployDataAvailabilityChallenge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the DataAvailabilityChallengeProxy
   */
  deployDataAvailabilityChallengeProxy(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  deployDelayedWETH(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the DisputeGameFactory
   */
  deployDisputeGameFactory(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploys an ERC1967Proxy contract with the ProxyAdmin as the owner.
   * @param _name The name of the proxy contract to be deployed.
   */
  deployERC1967Proxy(
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploys an ERC1967Proxy contract with a specified owner.
   * @param _name The name of the proxy contract to be deployed.
   * @param _proxyOwner The address of the owner of the proxy contract.
   */
  deployERC1967ProxyWithOwner(
    _name: string,
    _proxyOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy all of the implementations
   */
  deployImplementations(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L1CrossDomainMessenger
   */
  deployL1CrossDomainMessenger(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L1CrossDomainMessengerProxy using a ResolvedDelegateProxy
   */
  deployL1CrossDomainMessengerProxy(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L1ERC721Bridge
   */
  deployL1ERC721Bridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L1StandardBridge
   */
  deployL1StandardBridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L1StandardBridgeProxy using a ChugSplashProxy
   */
  deployL1StandardBridgeProxy(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the L2OutputOracle
   */
  deployL2OutputOracle(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy Mips
   */
  deployMips(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the OptimismMintableERC20Factory
   */
  deployOptimismMintableERC20Factory(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the OptimismPortal
   */
  deployOptimismPortal(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the OptimismPortal2
   */
  deployOptimismPortal2(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the PreimageOracle
   */
  deployPreimageOracle(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the ProtocolVersions
   */
  deployProtocolVersions(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy all of the proxies
   */
  deployProxies(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the ProxyAdmin
   */
  deployProxyAdmin(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the Safe
   */
  "deploySafe(string)"(
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy a new Safe contract. If the keepDeployer option is used to enable further setup actions, then         the removeDeployerFromSafe() function should be called on that safe after setup is complete.         Note this function does not have the broadcast modifier.
   * @param _keepDeployer Wether or not the deployer address will be added as an owner of the Safe.
   * @param _name The name of the Safe to deploy.
   * @param _owners The owners of the Safe.
   * @param _threshold The threshold of the Safe.
   */
  "deploySafe(string,address[],uint256,bool)"(
    _name: string,
    _owners: string[],
    _threshold: BigNumberish,
    _keepDeployer: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the StorageSetter contract, used for upgrades.
   */
  deployStorageSetter(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the SuperchainConfig contract
   */
  deploySuperchainConfig(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy the SystemConfig
   */
  deploySystemConfig(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns a deployment that is suitable to be used to interact with contracts.
   * @param _name The name of the deployment.
   */
  get(
    _name: string,
    overrides?: CallOverrides
  ): Promise<DeploymentStructOutput>;

  /**
   * Returns the address of a deployment. Also handles the predeploys.
   * @param _name The name of the deployment.
   */
  getAddress(_name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns whether or not a particular deployment exists.
   * @param _name The name of the deployment.
   */
  has(_name: string, overrides?: CallOverrides): Promise<boolean>;

  initializeAnchorStateRegistry(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the DataAvailabilityChallenge
   */
  initializeDataAvailabilityChallenge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  initializeDelayedWETH(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the DisputeGameFactory
   */
  initializeDisputeGameFactory(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize all of the implementations
   */
  initializeImplementations(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * initializeL1CrossDomainMessenger
   */
  initializeL1CrossDomainMessenger(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the L1ERC721Bridge
   */
  initializeL1ERC721Bridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the L1StandardBridge
   */
  initializeL1StandardBridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the L2OutputOracle
   */
  initializeL2OutputOracle(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the OptimismMintableERC20Factory
   */
  initializeOptimismMintableERC20Factory(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the OptimismPortal
   */
  initializeOptimismPortal(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the OptimismPortal2
   */
  initializeOptimismPortal2(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  initializePermissionedDelayedWETH(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  initializeProtocolVersions(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the SuperchainConfig
   */
  initializeSuperchainConfig(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialize the SystemConfig
   */
  initializeSystemConfig(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the value of the internal `_initialized` storage slot for a given contract.
   */
  loadInitializedSlot(
    _contractName: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the address of a deployment and reverts if the deployment         does not exist.
   */
  mustGetAddress(_name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns all of the deployments done in the current context.
   */
  newDeployments(overrides?: CallOverrides): Promise<DeploymentStructOutput[]>;

  /**
   * Stubs a deployment retrieved through `get`.
   * @param _addr The mock address of the deployment.
   * @param _name The name of the deployment.
   */
  prankDeployment(
    _name: string,
    _addr: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * If the keepDeployer option was used with deploySafe(), this function can be used to remove the deployer.         Note this function does not have the broadcast modifier.
   */
  removeDeployerFromSafe(
    _name: string,
    _newThreshold: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy all of the L1 contracts necessary for a full Superchain with a single Op Chain.
   */
  run(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  /**
   * Deploy all L1 contracts and write the state diff to a file.
   */
  runWithStateDiff(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  runWithStateDump(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Appends a deployment to disk as a JSON deploy artifact.
   * @param _deployed The address of the deployment.
   * @param _name The name of the deployment.
   */
  save(
    _name: string,
    _deployed: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
   */
  setAlphabetFaultGameImplementation(
    _allowUpgrade: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the implementation for the `CANNON` game type in the `DisputeGameFactory`
   */
  setCannonFaultGameImplementation(
    _allowUpgrade: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
   */
  setFastFaultGameImplementation(
    _allowUpgrade: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the implementation for the `PERMISSIONED_CANNON` game type in the `DisputeGameFactory`
   */
  setPermissionedCannonFaultGameImplementation(
    _allowUpgrade: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets up the artifacts contract.
   */
  setUp(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Add AltDA setup to the OP chain
   */
  setupOpAltDA(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy a new OP Chain, with an existing SuperchainConfig provided
   */
  setupOpChain(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploy a full system with a new SuperchainConfig         The Superchain system has 2 singleton contracts which lie outside of an OP Chain:         1. The SuperchainConfig contract         2. The ProtocolVersions contract
   */
  setupSuperchain(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of the address manager to the ProxyAdmin
   */
  transferAddressManagerOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of the DelayedWETH contract to the final system owner
   */
  transferDelayedWETHOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of the DisputeGameFactory contract to the final system owner
   */
  transferDisputeGameFactoryOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of the permissioned DelayedWETH contract to the final system owner
   */
  transferPermissionedDelayedWETHOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of the ProxyAdmin contract to the final system owner
   */
  transferProxyAdminOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfer ownership of a Proxy to the ProxyAdmin contract         This is expected to be used in conjusting with deployERC1967ProxyWithOwner after setup actions         have been performed on the proxy.
   * @param _name The name of the proxy to transfer ownership of.
   */
  transferProxyToProxyAdmin(
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the L1CrossDomainMessenger
   */
  upgradeL1CrossDomainMessenger(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the L1ERC721Bridge
   */
  upgradeL1ERC721Bridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the L1StandardBridge
   */
  upgradeL1StandardBridge(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the L2OutputOracle
   */
  upgradeL2OutputOracle(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the OptimismPortal
   */
  upgradeOptimismPortal(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the SystemConfig
   */
  upgradeSystemConfig(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    IS_SCRIPT(overrides?: CallOverrides): Promise<boolean>;

    cfg(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the AddressManager
     */
    deployAddressManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the AnchorStateRegistry
     */
    deployAnchorStateRegistry(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the DataAvailabilityChallenge
     */
    deployDataAvailabilityChallenge(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the DataAvailabilityChallengeProxy
     */
    deployDataAvailabilityChallengeProxy(
      overrides?: CallOverrides
    ): Promise<string>;

    deployDelayedWETH(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the DisputeGameFactory
     */
    deployDisputeGameFactory(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploys an ERC1967Proxy contract with the ProxyAdmin as the owner.
     * @param _name The name of the proxy contract to be deployed.
     */
    deployERC1967Proxy(
      _name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploys an ERC1967Proxy contract with a specified owner.
     * @param _name The name of the proxy contract to be deployed.
     * @param _proxyOwner The address of the owner of the proxy contract.
     */
    deployERC1967ProxyWithOwner(
      _name: string,
      _proxyOwner: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploy all of the implementations
     */
    deployImplementations(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy the L1CrossDomainMessenger
     */
    deployL1CrossDomainMessenger(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the L1CrossDomainMessengerProxy using a ResolvedDelegateProxy
     */
    deployL1CrossDomainMessengerProxy(
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploy the L1ERC721Bridge
     */
    deployL1ERC721Bridge(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the L1StandardBridge
     */
    deployL1StandardBridge(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the L1StandardBridgeProxy using a ChugSplashProxy
     */
    deployL1StandardBridgeProxy(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the L2OutputOracle
     */
    deployL2OutputOracle(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy Mips
     */
    deployMips(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the OptimismMintableERC20Factory
     */
    deployOptimismMintableERC20Factory(
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploy the OptimismPortal
     */
    deployOptimismPortal(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the OptimismPortal2
     */
    deployOptimismPortal2(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the PreimageOracle
     */
    deployPreimageOracle(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the ProtocolVersions
     */
    deployProtocolVersions(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy all of the proxies
     */
    deployProxies(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy the ProxyAdmin
     */
    deployProxyAdmin(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the Safe
     */
    "deploySafe(string)"(
      _name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploy a new Safe contract. If the keepDeployer option is used to enable further setup actions, then         the removeDeployerFromSafe() function should be called on that safe after setup is complete.         Note this function does not have the broadcast modifier.
     * @param _keepDeployer Wether or not the deployer address will be added as an owner of the Safe.
     * @param _name The name of the Safe to deploy.
     * @param _owners The owners of the Safe.
     * @param _threshold The threshold of the Safe.
     */
    "deploySafe(string,address[],uint256,bool)"(
      _name: string,
      _owners: string[],
      _threshold: BigNumberish,
      _keepDeployer: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Deploy the StorageSetter contract, used for upgrades.
     */
    deployStorageSetter(overrides?: CallOverrides): Promise<string>;

    /**
     * Deploy the SuperchainConfig contract
     */
    deploySuperchainConfig(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy the SystemConfig
     */
    deploySystemConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns a deployment that is suitable to be used to interact with contracts.
     * @param _name The name of the deployment.
     */
    get(
      _name: string,
      overrides?: CallOverrides
    ): Promise<DeploymentStructOutput>;

    /**
     * Returns the address of a deployment. Also handles the predeploys.
     * @param _name The name of the deployment.
     */
    getAddress(_name: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns whether or not a particular deployment exists.
     * @param _name The name of the deployment.
     */
    has(_name: string, overrides?: CallOverrides): Promise<boolean>;

    initializeAnchorStateRegistry(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the DataAvailabilityChallenge
     */
    initializeDataAvailabilityChallenge(
      overrides?: CallOverrides
    ): Promise<void>;

    initializeDelayedWETH(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the DisputeGameFactory
     */
    initializeDisputeGameFactory(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize all of the implementations
     */
    initializeImplementations(overrides?: CallOverrides): Promise<void>;

    /**
     * initializeL1CrossDomainMessenger
     */
    initializeL1CrossDomainMessenger(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the L1ERC721Bridge
     */
    initializeL1ERC721Bridge(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the L1StandardBridge
     */
    initializeL1StandardBridge(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the L2OutputOracle
     */
    initializeL2OutputOracle(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the OptimismMintableERC20Factory
     */
    initializeOptimismMintableERC20Factory(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Initialize the OptimismPortal
     */
    initializeOptimismPortal(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the OptimismPortal2
     */
    initializeOptimismPortal2(overrides?: CallOverrides): Promise<void>;

    initializePermissionedDelayedWETH(overrides?: CallOverrides): Promise<void>;

    initializeProtocolVersions(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the SuperchainConfig
     */
    initializeSuperchainConfig(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialize the SystemConfig
     */
    initializeSystemConfig(overrides?: CallOverrides): Promise<void>;

    /**
     * Returns the value of the internal `_initialized` storage slot for a given contract.
     */
    loadInitializedSlot(
      _contractName: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Returns the address of a deployment and reverts if the deployment         does not exist.
     */
    mustGetAddress(_name: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns all of the deployments done in the current context.
     */
    newDeployments(
      overrides?: CallOverrides
    ): Promise<DeploymentStructOutput[]>;

    /**
     * Stubs a deployment retrieved through `get`.
     * @param _addr The mock address of the deployment.
     * @param _name The name of the deployment.
     */
    prankDeployment(
      _name: string,
      _addr: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * If the keepDeployer option was used with deploySafe(), this function can be used to remove the deployer.         Note this function does not have the broadcast modifier.
     */
    removeDeployerFromSafe(
      _name: string,
      _newThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Deploy all of the L1 contracts necessary for a full Superchain with a single Op Chain.
     */
    run(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy all L1 contracts and write the state diff to a file.
     */
    runWithStateDiff(overrides?: CallOverrides): Promise<void>;

    runWithStateDump(overrides?: CallOverrides): Promise<void>;

    /**
     * Appends a deployment to disk as a JSON deploy artifact.
     * @param _deployed The address of the deployment.
     * @param _name The name of the deployment.
     */
    save(
      _name: string,
      _deployed: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setAlphabetFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the implementation for the `CANNON` game type in the `DisputeGameFactory`
     */
    setCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setFastFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the implementation for the `PERMISSIONED_CANNON` game type in the `DisputeGameFactory`
     */
    setPermissionedCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets up the artifacts contract.
     */
    setUp(overrides?: CallOverrides): Promise<void>;

    /**
     * Add AltDA setup to the OP chain
     */
    setupOpAltDA(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy a new OP Chain, with an existing SuperchainConfig provided
     */
    setupOpChain(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploy a full system with a new SuperchainConfig         The Superchain system has 2 singleton contracts which lie outside of an OP Chain:         1. The SuperchainConfig contract         2. The ProtocolVersions contract
     */
    setupSuperchain(overrides?: CallOverrides): Promise<void>;

    /**
     * Transfer ownership of the address manager to the ProxyAdmin
     */
    transferAddressManagerOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Transfer ownership of the DelayedWETH contract to the final system owner
     */
    transferDelayedWETHOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Transfer ownership of the DisputeGameFactory contract to the final system owner
     */
    transferDisputeGameFactoryOwnership(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfer ownership of the permissioned DelayedWETH contract to the final system owner
     */
    transferPermissionedDelayedWETHOwnership(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfer ownership of the ProxyAdmin contract to the final system owner
     */
    transferProxyAdminOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Transfer ownership of a Proxy to the ProxyAdmin contract         This is expected to be used in conjusting with deployERC1967ProxyWithOwner after setup actions         have been performed on the proxy.
     * @param _name The name of the proxy to transfer ownership of.
     */
    transferProxyToProxyAdmin(
      _name: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the L1CrossDomainMessenger
     */
    upgradeL1CrossDomainMessenger(overrides?: CallOverrides): Promise<void>;

    /**
     * Upgrade the L1ERC721Bridge
     */
    upgradeL1ERC721Bridge(overrides?: CallOverrides): Promise<void>;

    /**
     * Upgrade the L1StandardBridge
     */
    upgradeL1StandardBridge(overrides?: CallOverrides): Promise<void>;

    /**
     * Upgrade the L2OutputOracle
     */
    upgradeL2OutputOracle(overrides?: CallOverrides): Promise<void>;

    /**
     * Upgrade the OptimismPortal
     */
    upgradeOptimismPortal(overrides?: CallOverrides): Promise<void>;

    /**
     * Upgrade the SystemConfig
     */
    upgradeSystemConfig(overrides?: CallOverrides): Promise<void>;
  };

  filters: {};

  estimateGas: {
    IS_SCRIPT(overrides?: CallOverrides): Promise<BigNumber>;

    cfg(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deploy the AddressManager
     */
    deployAddressManager(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the AnchorStateRegistry
     */
    deployAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the DataAvailabilityChallenge
     */
    deployDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the DataAvailabilityChallengeProxy
     */
    deployDataAvailabilityChallengeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    deployDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the DisputeGameFactory
     */
    deployDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploys an ERC1967Proxy contract with the ProxyAdmin as the owner.
     * @param _name The name of the proxy contract to be deployed.
     */
    deployERC1967Proxy(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploys an ERC1967Proxy contract with a specified owner.
     * @param _name The name of the proxy contract to be deployed.
     * @param _proxyOwner The address of the owner of the proxy contract.
     */
    deployERC1967ProxyWithOwner(
      _name: string,
      _proxyOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy all of the implementations
     */
    deployImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L1CrossDomainMessenger
     */
    deployL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L1CrossDomainMessengerProxy using a ResolvedDelegateProxy
     */
    deployL1CrossDomainMessengerProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L1ERC721Bridge
     */
    deployL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L1StandardBridge
     */
    deployL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L1StandardBridgeProxy using a ChugSplashProxy
     */
    deployL1StandardBridgeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the L2OutputOracle
     */
    deployL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy Mips
     */
    deployMips(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Deploy the OptimismMintableERC20Factory
     */
    deployOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the OptimismPortal
     */
    deployOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the OptimismPortal2
     */
    deployOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the PreimageOracle
     */
    deployPreimageOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the ProtocolVersions
     */
    deployProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy all of the proxies
     */
    deployProxies(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the ProxyAdmin
     */
    deployProxyAdmin(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the Safe
     */
    "deploySafe(string)"(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy a new Safe contract. If the keepDeployer option is used to enable further setup actions, then         the removeDeployerFromSafe() function should be called on that safe after setup is complete.         Note this function does not have the broadcast modifier.
     * @param _keepDeployer Wether or not the deployer address will be added as an owner of the Safe.
     * @param _name The name of the Safe to deploy.
     * @param _owners The owners of the Safe.
     * @param _threshold The threshold of the Safe.
     */
    "deploySafe(string,address[],uint256,bool)"(
      _name: string,
      _owners: string[],
      _threshold: BigNumberish,
      _keepDeployer: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the StorageSetter contract, used for upgrades.
     */
    deployStorageSetter(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the SuperchainConfig contract
     */
    deploySuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy the SystemConfig
     */
    deploySystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns a deployment that is suitable to be used to interact with contracts.
     * @param _name The name of the deployment.
     */
    get(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of a deployment. Also handles the predeploys.
     * @param _name The name of the deployment.
     */
    getAddress(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns whether or not a particular deployment exists.
     * @param _name The name of the deployment.
     */
    has(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    initializeAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the DataAvailabilityChallenge
     */
    initializeDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    initializeDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the DisputeGameFactory
     */
    initializeDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize all of the implementations
     */
    initializeImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * initializeL1CrossDomainMessenger
     */
    initializeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the L1ERC721Bridge
     */
    initializeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the L1StandardBridge
     */
    initializeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the L2OutputOracle
     */
    initializeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the OptimismMintableERC20Factory
     */
    initializeOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the OptimismPortal
     */
    initializeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the OptimismPortal2
     */
    initializeOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    initializePermissionedDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    initializeProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the SuperchainConfig
     */
    initializeSuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialize the SystemConfig
     */
    initializeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the value of the internal `_initialized` storage slot for a given contract.
     */
    loadInitializedSlot(
      _contractName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the address of a deployment and reverts if the deployment         does not exist.
     */
    mustGetAddress(
      _name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns all of the deployments done in the current context.
     */
    newDeployments(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Stubs a deployment retrieved through `get`.
     * @param _addr The mock address of the deployment.
     * @param _name The name of the deployment.
     */
    prankDeployment(
      _name: string,
      _addr: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * If the keepDeployer option was used with deploySafe(), this function can be used to remove the deployer.         Note this function does not have the broadcast modifier.
     */
    removeDeployerFromSafe(
      _name: string,
      _newThreshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploy all of the L1 contracts necessary for a full Superchain with a single Op Chain.
     */
    run(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Deploy all L1 contracts and write the state diff to a file.
     */
    runWithStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    runWithStateDump(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Appends a deployment to disk as a JSON deploy artifact.
     * @param _deployed The address of the deployment.
     * @param _name The name of the deployment.
     */
    save(
      _name: string,
      _deployed: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setAlphabetFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the implementation for the `CANNON` game type in the `DisputeGameFactory`
     */
    setCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setFastFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the implementation for the `PERMISSIONED_CANNON` game type in the `DisputeGameFactory`
     */
    setPermissionedCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets up the artifacts contract.
     */
    setUp(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Add AltDA setup to the OP chain
     */
    setupOpAltDA(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Deploy a new OP Chain, with an existing SuperchainConfig provided
     */
    setupOpChain(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Deploy a full system with a new SuperchainConfig         The Superchain system has 2 singleton contracts which lie outside of an OP Chain:         1. The SuperchainConfig contract         2. The ProtocolVersions contract
     */
    setupSuperchain(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of the address manager to the ProxyAdmin
     */
    transferAddressManagerOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of the DelayedWETH contract to the final system owner
     */
    transferDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of the DisputeGameFactory contract to the final system owner
     */
    transferDisputeGameFactoryOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of the permissioned DelayedWETH contract to the final system owner
     */
    transferPermissionedDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of the ProxyAdmin contract to the final system owner
     */
    transferProxyAdminOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfer ownership of a Proxy to the ProxyAdmin contract         This is expected to be used in conjusting with deployERC1967ProxyWithOwner after setup actions         have been performed on the proxy.
     * @param _name The name of the proxy to transfer ownership of.
     */
    transferProxyToProxyAdmin(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the L1CrossDomainMessenger
     */
    upgradeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the L1ERC721Bridge
     */
    upgradeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the L1StandardBridge
     */
    upgradeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the L2OutputOracle
     */
    upgradeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the OptimismPortal
     */
    upgradeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade the SystemConfig
     */
    upgradeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    IS_SCRIPT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cfg(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Deploy the AddressManager
     */
    deployAddressManager(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the AnchorStateRegistry
     */
    deployAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the DataAvailabilityChallenge
     */
    deployDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the DataAvailabilityChallengeProxy
     */
    deployDataAvailabilityChallengeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    deployDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the DisputeGameFactory
     */
    deployDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploys an ERC1967Proxy contract with the ProxyAdmin as the owner.
     * @param _name The name of the proxy contract to be deployed.
     */
    deployERC1967Proxy(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploys an ERC1967Proxy contract with a specified owner.
     * @param _name The name of the proxy contract to be deployed.
     * @param _proxyOwner The address of the owner of the proxy contract.
     */
    deployERC1967ProxyWithOwner(
      _name: string,
      _proxyOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy all of the implementations
     */
    deployImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L1CrossDomainMessenger
     */
    deployL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L1CrossDomainMessengerProxy using a ResolvedDelegateProxy
     */
    deployL1CrossDomainMessengerProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L1ERC721Bridge
     */
    deployL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L1StandardBridge
     */
    deployL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L1StandardBridgeProxy using a ChugSplashProxy
     */
    deployL1StandardBridgeProxy(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the L2OutputOracle
     */
    deployL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy Mips
     */
    deployMips(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the OptimismMintableERC20Factory
     */
    deployOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the OptimismPortal
     */
    deployOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the OptimismPortal2
     */
    deployOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the PreimageOracle
     */
    deployPreimageOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the ProtocolVersions
     */
    deployProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy all of the proxies
     */
    deployProxies(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the ProxyAdmin
     */
    deployProxyAdmin(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the Safe
     */
    "deploySafe(string)"(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy a new Safe contract. If the keepDeployer option is used to enable further setup actions, then         the removeDeployerFromSafe() function should be called on that safe after setup is complete.         Note this function does not have the broadcast modifier.
     * @param _keepDeployer Wether or not the deployer address will be added as an owner of the Safe.
     * @param _name The name of the Safe to deploy.
     * @param _owners The owners of the Safe.
     * @param _threshold The threshold of the Safe.
     */
    "deploySafe(string,address[],uint256,bool)"(
      _name: string,
      _owners: string[],
      _threshold: BigNumberish,
      _keepDeployer: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the StorageSetter contract, used for upgrades.
     */
    deployStorageSetter(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the SuperchainConfig contract
     */
    deploySuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy the SystemConfig
     */
    deploySystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns a deployment that is suitable to be used to interact with contracts.
     * @param _name The name of the deployment.
     */
    get(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of a deployment. Also handles the predeploys.
     * @param _name The name of the deployment.
     */
    getAddress(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns whether or not a particular deployment exists.
     * @param _name The name of the deployment.
     */
    has(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initializeAnchorStateRegistry(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the DataAvailabilityChallenge
     */
    initializeDataAvailabilityChallenge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    initializeDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the DisputeGameFactory
     */
    initializeDisputeGameFactory(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize all of the implementations
     */
    initializeImplementations(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * initializeL1CrossDomainMessenger
     */
    initializeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the L1ERC721Bridge
     */
    initializeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the L1StandardBridge
     */
    initializeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the L2OutputOracle
     */
    initializeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the OptimismMintableERC20Factory
     */
    initializeOptimismMintableERC20Factory(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the OptimismPortal
     */
    initializeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the OptimismPortal2
     */
    initializeOptimismPortal2(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    initializePermissionedDelayedWETH(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    initializeProtocolVersions(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the SuperchainConfig
     */
    initializeSuperchainConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize the SystemConfig
     */
    initializeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the value of the internal `_initialized` storage slot for a given contract.
     */
    loadInitializedSlot(
      _contractName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of a deployment and reverts if the deployment         does not exist.
     */
    mustGetAddress(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns all of the deployments done in the current context.
     */
    newDeployments(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Stubs a deployment retrieved through `get`.
     * @param _addr The mock address of the deployment.
     * @param _name The name of the deployment.
     */
    prankDeployment(
      _name: string,
      _addr: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * If the keepDeployer option was used with deploySafe(), this function can be used to remove the deployer.         Note this function does not have the broadcast modifier.
     */
    removeDeployerFromSafe(
      _name: string,
      _newThreshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy all of the L1 contracts necessary for a full Superchain with a single Op Chain.
     */
    run(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy all L1 contracts and write the state diff to a file.
     */
    runWithStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    runWithStateDump(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Appends a deployment to disk as a JSON deploy artifact.
     * @param _deployed The address of the deployment.
     * @param _name The name of the deployment.
     */
    save(
      _name: string,
      _deployed: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setAlphabetFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the implementation for the `CANNON` game type in the `DisputeGameFactory`
     */
    setCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the implementation for the `ALPHABET` game type in the `DisputeGameFactory`
     */
    setFastFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the implementation for the `PERMISSIONED_CANNON` game type in the `DisputeGameFactory`
     */
    setPermissionedCannonFaultGameImplementation(
      _allowUpgrade: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets up the artifacts contract.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Add AltDA setup to the OP chain
     */
    setupOpAltDA(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy a new OP Chain, with an existing SuperchainConfig provided
     */
    setupOpChain(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploy a full system with a new SuperchainConfig         The Superchain system has 2 singleton contracts which lie outside of an OP Chain:         1. The SuperchainConfig contract         2. The ProtocolVersions contract
     */
    setupSuperchain(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of the address manager to the ProxyAdmin
     */
    transferAddressManagerOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of the DelayedWETH contract to the final system owner
     */
    transferDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of the DisputeGameFactory contract to the final system owner
     */
    transferDisputeGameFactoryOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of the permissioned DelayedWETH contract to the final system owner
     */
    transferPermissionedDelayedWETHOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of the ProxyAdmin contract to the final system owner
     */
    transferProxyAdminOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer ownership of a Proxy to the ProxyAdmin contract         This is expected to be used in conjusting with deployERC1967ProxyWithOwner after setup actions         have been performed on the proxy.
     * @param _name The name of the proxy to transfer ownership of.
     */
    transferProxyToProxyAdmin(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the L1CrossDomainMessenger
     */
    upgradeL1CrossDomainMessenger(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the L1ERC721Bridge
     */
    upgradeL1ERC721Bridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the L1StandardBridge
     */
    upgradeL1StandardBridge(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the L2OutputOracle
     */
    upgradeL2OutputOracle(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the OptimismPortal
     */
    upgradeOptimismPortal(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the SystemConfig
     */
    upgradeSystemConfig(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
