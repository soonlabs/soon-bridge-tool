/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace StdInvariant {
  export type FuzzSelectorStruct = { addr: string; selectors: BytesLike[] };

  export type FuzzSelectorStructOutput = [string, string[]] & {
    addr: string;
    selectors: string[];
  };

  export type FuzzInterfaceStruct = { addr: string; artifacts: string[] };

  export type FuzzInterfaceStructOutput = [string, string[]] & {
    addr: string;
    artifacts: string[];
  };
}

export interface FaultDisputeGame_TestInterface extends utils.Interface {
  functions: {
    "IS_TEST()": FunctionFragment;
    "L1()": FunctionFragment;
    "enableAltDA()": FunctionFragment;
    "enableCustomGasToken(address)": FunctionFragment;
    "enableFaultProofs()": FunctionFragment;
    "enableInterop()": FunctionFragment;
    "excludeArtifacts()": FunctionFragment;
    "excludeContracts()": FunctionFragment;
    "excludeSenders()": FunctionFragment;
    "failed()": FunctionFragment;
    "init(bytes32,bytes32,uint256)": FunctionFragment;
    "proposeAnotherOutput()": FunctionFragment;
    "setUp()": FunctionFragment;
    "targetArtifactSelectors()": FunctionFragment;
    "targetArtifacts()": FunctionFragment;
    "targetContracts()": FunctionFragment;
    "targetInterfaces()": FunctionFragment;
    "targetSelectors()": FunctionFragment;
    "targetSenders()": FunctionFragment;
    "testFuzz_addLocalData_oob_reverts(uint256)": FunctionFragment;
    "testFuzz_challengeRootL2Block_receivesBond_succeeds(bytes32,bytes32,uint256)": FunctionFragment;
    "testFuzz_challengeRootL2Block_rightBlockNumber_reverts(bytes32,bytes32,uint256)": FunctionFragment;
    "testFuzz_challengeRootL2Block_succeeds(bytes32,bytes32,uint256)": FunctionFragment;
    "testFuzz_constructor_clockExtensionTooLong_reverts(uint64,uint64)": FunctionFragment;
    "testFuzz_constructor_invalidSplitDepth_reverts(uint256)": FunctionFragment;
    "testFuzz_constructor_lowSplitDepth_reverts(uint256)": FunctionFragment;
    "testFuzz_constructor_maxDepthTooLarge_reverts(uint256)": FunctionFragment;
    "testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(uint256)": FunctionFragment;
    "testFuzz_initialize_badExtraData_reverts(uint256)": FunctionFragment;
    "testFuzz_initialize_cannotProposeGenesis_reverts(uint256)": FunctionFragment;
    "test_addLocalDataGenesisTransition_static_succeeds()": FunctionFragment;
    "test_addLocalDataMiddle_static_succeeds()": FunctionFragment;
    "test_addLocalData_l2BlockNumberExtension_succeeds()": FunctionFragment;
    "test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts()": FunctionFragment;
    "test_challengeRootL2Block_badHeaderRLP_reverts()": FunctionFragment;
    "test_challengeRootL2Block_badProof_reverts()": FunctionFragment;
    "test_claimCredit_claimAlreadyResolved_reverts()": FunctionFragment;
    "test_createdAt_succeeds()": FunctionFragment;
    "test_cwiaCalldata_userCannotControlSelector_succeeds()": FunctionFragment;
    "test_extraData_succeeds()": FunctionFragment;
    "test_gameData_succeeds()": FunctionFragment;
    "test_gameType_succeeds()": FunctionFragment;
    "test_getRequiredBond_outOfBounds_reverts()": FunctionFragment;
    "test_getRequiredBond_succeeds()": FunctionFragment;
    "test_initialize_correctData_succeeds()": FunctionFragment;
    "test_initialize_onlyOnce_succeeds()": FunctionFragment;
    "test_initialize_receivesETH_succeeds()": FunctionFragment;
    "test_move_clockCorrectness_succeeds()": FunctionFragment;
    "test_move_clockTimeExceeded_reverts()": FunctionFragment;
    "test_move_correctStatusExecRoot_succeeds()": FunctionFragment;
    "test_move_defendRoot_reverts()": FunctionFragment;
    "test_move_duplicateClaim_reverts()": FunctionFragment;
    "test_move_duplicateClaimsDifferentSubgames_succeeds()": FunctionFragment;
    "test_move_gameDepthExceeded_reverts()": FunctionFragment;
    "test_move_gameNotInProgress_reverts()": FunctionFragment;
    "test_move_incorrectBondAmount_reverts()": FunctionFragment;
    "test_move_incorrectDisputedIndex_reverts()": FunctionFragment;
    "test_move_incorrectStatusExecRoot_reverts()": FunctionFragment;
    "test_move_maxGameDepthClockExtension_succeeds()": FunctionFragment;
    "test_move_nonExistentParent_reverts()": FunctionFragment;
    "test_move_simpleAttack_succeeds()": FunctionFragment;
    "test_move_splitDepthClockExtension_succeeds()": FunctionFragment;
    "test_move_standardClockExtension_succeeds()": FunctionFragment;
    "test_resolution_lastSecondDisputes_succeeds()": FunctionFragment;
    "test_resolve_bondPayoutsSeveralActors_succeeds()": FunctionFragment;
    "test_resolve_bondPayouts_succeeds()": FunctionFragment;
    "test_resolve_challengeContested_succeeds()": FunctionFragment;
    "test_resolve_claimAlreadyResolved_reverts()": FunctionFragment;
    "test_resolve_claimAtMaxDepthAlreadyResolved_reverts()": FunctionFragment;
    "test_resolve_invalidStateSameAnchor_succeeds()": FunctionFragment;
    "test_resolve_leftmostBondPayout_succeeds()": FunctionFragment;
    "test_resolve_multiPart_succeeds()": FunctionFragment;
    "test_resolve_notInProgress_reverts()": FunctionFragment;
    "test_resolve_outOfOrderResolution_reverts()": FunctionFragment;
    "test_resolve_rootContested_succeeds()": FunctionFragment;
    "test_resolve_rootUncontestedButUnresolved_reverts()": FunctionFragment;
    "test_resolve_rootUncontestedClockNotExpired_succeeds()": FunctionFragment;
    "test_resolve_rootUncontested_succeeds()": FunctionFragment;
    "test_resolve_stepReached_succeeds()": FunctionFragment;
    "test_resolve_teamDeathmatch_succeeds()": FunctionFragment;
    "test_resolve_validNewerStateUpdatesAnchor_succeeds()": FunctionFragment;
    "test_resolve_validOlderStateSameAnchor_succeeds()": FunctionFragment;
    "test_rootClaim_succeeds()": FunctionFragment;
    "test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds()": FunctionFragment;
    "test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts()": FunctionFragment;
    "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts()": FunctionFragment;
    "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds()": FunctionFragment;
    "test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts()": FunctionFragment;
    "test_step_duplicateStep_reverts()": FunctionFragment;
    "warpToProposeTime(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "IS_TEST"
      | "L1"
      | "enableAltDA"
      | "enableCustomGasToken"
      | "enableFaultProofs"
      | "enableInterop"
      | "excludeArtifacts"
      | "excludeContracts"
      | "excludeSenders"
      | "failed"
      | "init"
      | "proposeAnotherOutput"
      | "setUp"
      | "targetArtifactSelectors"
      | "targetArtifacts"
      | "targetContracts"
      | "targetInterfaces"
      | "targetSelectors"
      | "targetSenders"
      | "testFuzz_addLocalData_oob_reverts"
      | "testFuzz_challengeRootL2Block_receivesBond_succeeds"
      | "testFuzz_challengeRootL2Block_rightBlockNumber_reverts"
      | "testFuzz_challengeRootL2Block_succeeds"
      | "testFuzz_constructor_clockExtensionTooLong_reverts"
      | "testFuzz_constructor_invalidSplitDepth_reverts"
      | "testFuzz_constructor_lowSplitDepth_reverts"
      | "testFuzz_constructor_maxDepthTooLarge_reverts"
      | "testFuzz_constructor_oracleChallengePeriodTooLarge_reverts"
      | "testFuzz_initialize_badExtraData_reverts"
      | "testFuzz_initialize_cannotProposeGenesis_reverts"
      | "test_addLocalDataGenesisTransition_static_succeeds"
      | "test_addLocalDataMiddle_static_succeeds"
      | "test_addLocalData_l2BlockNumberExtension_succeeds"
      | "test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts"
      | "test_challengeRootL2Block_badHeaderRLP_reverts"
      | "test_challengeRootL2Block_badProof_reverts"
      | "test_claimCredit_claimAlreadyResolved_reverts"
      | "test_createdAt_succeeds"
      | "test_cwiaCalldata_userCannotControlSelector_succeeds"
      | "test_extraData_succeeds"
      | "test_gameData_succeeds"
      | "test_gameType_succeeds"
      | "test_getRequiredBond_outOfBounds_reverts"
      | "test_getRequiredBond_succeeds"
      | "test_initialize_correctData_succeeds"
      | "test_initialize_onlyOnce_succeeds"
      | "test_initialize_receivesETH_succeeds"
      | "test_move_clockCorrectness_succeeds"
      | "test_move_clockTimeExceeded_reverts"
      | "test_move_correctStatusExecRoot_succeeds"
      | "test_move_defendRoot_reverts"
      | "test_move_duplicateClaim_reverts"
      | "test_move_duplicateClaimsDifferentSubgames_succeeds"
      | "test_move_gameDepthExceeded_reverts"
      | "test_move_gameNotInProgress_reverts"
      | "test_move_incorrectBondAmount_reverts"
      | "test_move_incorrectDisputedIndex_reverts"
      | "test_move_incorrectStatusExecRoot_reverts"
      | "test_move_maxGameDepthClockExtension_succeeds"
      | "test_move_nonExistentParent_reverts"
      | "test_move_simpleAttack_succeeds"
      | "test_move_splitDepthClockExtension_succeeds"
      | "test_move_standardClockExtension_succeeds"
      | "test_resolution_lastSecondDisputes_succeeds"
      | "test_resolve_bondPayoutsSeveralActors_succeeds"
      | "test_resolve_bondPayouts_succeeds"
      | "test_resolve_challengeContested_succeeds"
      | "test_resolve_claimAlreadyResolved_reverts"
      | "test_resolve_claimAtMaxDepthAlreadyResolved_reverts"
      | "test_resolve_invalidStateSameAnchor_succeeds"
      | "test_resolve_leftmostBondPayout_succeeds"
      | "test_resolve_multiPart_succeeds"
      | "test_resolve_notInProgress_reverts"
      | "test_resolve_outOfOrderResolution_reverts"
      | "test_resolve_rootContested_succeeds"
      | "test_resolve_rootUncontestedButUnresolved_reverts"
      | "test_resolve_rootUncontestedClockNotExpired_succeeds"
      | "test_resolve_rootUncontested_succeeds"
      | "test_resolve_stepReached_succeeds"
      | "test_resolve_teamDeathmatch_succeeds"
      | "test_resolve_validNewerStateUpdatesAnchor_succeeds"
      | "test_resolve_validOlderStateSameAnchor_succeeds"
      | "test_rootClaim_succeeds"
      | "test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds"
      | "test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts"
      | "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts"
      | "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds"
      | "test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts"
      | "test_step_duplicateStep_reverts"
      | "warpToProposeTime"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "IS_TEST", values?: undefined): string;
  encodeFunctionData(functionFragment: "L1", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "enableAltDA",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enableCustomGasToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "enableFaultProofs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enableInterop",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeArtifacts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeContracts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeSenders",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "failed", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "init",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeAnotherOutput",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "setUp", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "targetArtifactSelectors",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetArtifacts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetContracts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetInterfaces",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetSelectors",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetSenders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_addLocalData_oob_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_challengeRootL2Block_receivesBond_succeeds",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_challengeRootL2Block_rightBlockNumber_reverts",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_challengeRootL2Block_succeeds",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_constructor_clockExtensionTooLong_reverts",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_constructor_invalidSplitDepth_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_constructor_lowSplitDepth_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_constructor_maxDepthTooLarge_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_constructor_oracleChallengePeriodTooLarge_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_initialize_badExtraData_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_initialize_cannotProposeGenesis_reverts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "test_addLocalDataGenesisTransition_static_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_addLocalDataMiddle_static_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_addLocalData_l2BlockNumberExtension_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_challengeRootL2Block_badHeaderRLP_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_challengeRootL2Block_badProof_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_claimCredit_claimAlreadyResolved_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_createdAt_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_cwiaCalldata_userCannotControlSelector_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_extraData_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_gameData_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_gameType_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_getRequiredBond_outOfBounds_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_getRequiredBond_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_initialize_correctData_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_initialize_onlyOnce_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_initialize_receivesETH_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_clockCorrectness_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_clockTimeExceeded_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_correctStatusExecRoot_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_defendRoot_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_duplicateClaim_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_duplicateClaimsDifferentSubgames_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_gameDepthExceeded_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_gameNotInProgress_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_incorrectBondAmount_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_incorrectDisputedIndex_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_incorrectStatusExecRoot_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_maxGameDepthClockExtension_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_nonExistentParent_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_simpleAttack_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_splitDepthClockExtension_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_move_standardClockExtension_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolution_lastSecondDisputes_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_bondPayoutsSeveralActors_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_bondPayouts_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_challengeContested_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_claimAlreadyResolved_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_claimAtMaxDepthAlreadyResolved_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_invalidStateSameAnchor_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_leftmostBondPayout_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_multiPart_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_notInProgress_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_outOfOrderResolution_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_rootContested_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_rootUncontestedButUnresolved_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_rootUncontestedClockNotExpired_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_rootUncontested_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_stepReached_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_teamDeathmatch_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_validNewerStateUpdatesAnchor_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_resolve_validOlderStateSameAnchor_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_rootClaim_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_step_duplicateStep_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "warpToProposeTime",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "IS_TEST", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "L1", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "enableAltDA",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableCustomGasToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableFaultProofs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableInterop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeArtifacts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeSenders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "failed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposeAnotherOutput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "targetArtifactSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetArtifacts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetInterfaces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetSenders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_addLocalData_oob_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_challengeRootL2Block_receivesBond_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_challengeRootL2Block_rightBlockNumber_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_challengeRootL2Block_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_constructor_clockExtensionTooLong_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_constructor_invalidSplitDepth_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_constructor_lowSplitDepth_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_constructor_maxDepthTooLarge_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_constructor_oracleChallengePeriodTooLarge_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_initialize_badExtraData_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_initialize_cannotProposeGenesis_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_addLocalDataGenesisTransition_static_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_addLocalDataMiddle_static_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_addLocalData_l2BlockNumberExtension_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_challengeRootL2Block_badHeaderRLP_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_challengeRootL2Block_badProof_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_claimCredit_claimAlreadyResolved_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_createdAt_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_cwiaCalldata_userCannotControlSelector_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_extraData_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_gameData_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_gameType_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_getRequiredBond_outOfBounds_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_getRequiredBond_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_initialize_correctData_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_initialize_onlyOnce_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_initialize_receivesETH_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_clockCorrectness_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_clockTimeExceeded_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_correctStatusExecRoot_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_defendRoot_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_duplicateClaim_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_duplicateClaimsDifferentSubgames_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_gameDepthExceeded_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_gameNotInProgress_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_incorrectBondAmount_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_incorrectDisputedIndex_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_incorrectStatusExecRoot_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_maxGameDepthClockExtension_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_nonExistentParent_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_simpleAttack_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_splitDepthClockExtension_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_move_standardClockExtension_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolution_lastSecondDisputes_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_bondPayoutsSeveralActors_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_bondPayouts_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_challengeContested_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_claimAlreadyResolved_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_claimAtMaxDepthAlreadyResolved_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_invalidStateSameAnchor_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_leftmostBondPayout_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_multiPart_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_notInProgress_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_outOfOrderResolution_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_rootContested_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_rootUncontestedButUnresolved_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_rootUncontestedClockNotExpired_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_rootUncontested_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_stepReached_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_teamDeathmatch_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_validNewerStateUpdatesAnchor_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_resolve_validOlderStateSameAnchor_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_rootClaim_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_step_duplicateStep_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "warpToProposeTime",
    data: BytesLike
  ): Result;

  events: {
    "DepositFailed(address,address,address,address,uint256,bytes)": EventFragment;
    "DepositFinalized(address,address,address,address,uint256,bytes)": EventFragment;
    "DisputeGameBlacklisted(address)": EventFragment;
    "DisputeGameCreated(address,uint32,bytes32)": EventFragment;
    "ERC20BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ERC20BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "ERC20DepositInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "ERC20WithdrawalFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ETHBridgeFinalized(bytes32,address,uint256,bytes)": EventFragment;
    "ETHBridgeInitiated(address,bytes32,uint256,bytes)": EventFragment;
    "ETHDepositInitiated(address,bytes32,uint256,bytes)": EventFragment;
    "ETHWithdrawalFinalized(bytes32,address,uint256,bytes)": EventFragment;
    "FailedRelayedMessage(bytes32)": EventFragment;
    "ImplementationSet(address,uint32)": EventFragment;
    "InitBondUpdated(uint32,uint256)": EventFragment;
    "MessagePassed(uint256,address,address,uint256,uint256,bytes,bytes32)": EventFragment;
    "Move(uint256,bytes32,address)": EventFragment;
    "OutputProposed(bytes32,uint256,uint256,uint256)": EventFragment;
    "OutputsDeleted(uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(string)": EventFragment;
    "ReceiveETH(uint256)": EventFragment;
    "RelayedMessage(bytes32)": EventFragment;
    "RespectedGameTypeSet(uint32,uint64)": EventFragment;
    "SentMessage(bytes32,address,bytes,uint256,uint256)": EventFragment;
    "SentMessageExtension1(address,uint256)": EventFragment;
    "TransactionDeposited(address,bytes32,uint256,bytes)": EventFragment;
    "TransactionDeposited(address,bytes32,uint256,uint256,uint64,bool,bytes)": EventFragment;
    "Unpaused()": EventFragment;
    "WhatHappened(bool,bytes)": EventFragment;
    "Withdrawal(uint256,address,address)": EventFragment;
    "WithdrawalFinalized(bytes32,bool)": EventFragment;
    "WithdrawalInitiated(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "WithdrawalProven(bytes32,bytes32,address)": EventFragment;
    "WithdrawalProvenExtension1(bytes32,address)": EventFragment;
    "WithdrawerBalanceBurnt(uint256)": EventFragment;
    "log(string)": EventFragment;
    "log_address(address)": EventFragment;
    "log_array(uint256[])": EventFragment;
    "log_array(int256[])": EventFragment;
    "log_array(address[])": EventFragment;
    "log_bytes(bytes)": EventFragment;
    "log_bytes32(bytes32)": EventFragment;
    "log_int(int256)": EventFragment;
    "log_named_address(string,address)": EventFragment;
    "log_named_array(string,uint256[])": EventFragment;
    "log_named_array(string,int256[])": EventFragment;
    "log_named_array(string,address[])": EventFragment;
    "log_named_bytes(string,bytes)": EventFragment;
    "log_named_bytes32(string,bytes32)": EventFragment;
    "log_named_decimal_int(string,int256,uint256)": EventFragment;
    "log_named_decimal_uint(string,uint256,uint256)": EventFragment;
    "log_named_int(string,int256)": EventFragment;
    "log_named_string(string,string)": EventFragment;
    "log_named_uint(string,uint256)": EventFragment;
    "log_string(string)": EventFragment;
    "log_uint(uint256)": EventFragment;
    "logs(bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DepositFailed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DepositFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeGameBlacklisted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeGameCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20BridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20BridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20DepositInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20WithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHBridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHBridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHDepositInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHWithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FailedRelayedMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ImplementationSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InitBondUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MessagePassed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Move"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OutputProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OutputsDeleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReceiveETH"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayedMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RespectedGameTypeSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SentMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SentMessageExtension1"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "TransactionDeposited(address,bytes32,uint256,bytes)"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "TransactionDeposited(address,bytes32,uint256,uint256,uint64,bool,bytes)"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhatHappened"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalProven"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalProvenExtension1"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawerBalanceBurnt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_address"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(uint256[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(int256[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(address[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_bytes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_bytes32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_address"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,uint256[])"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,int256[])"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,address[])"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_bytes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_bytes32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_decimal_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_decimal_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_string"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_string"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "logs"): EventFragment;
}

export interface DepositFailedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type DepositFailedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  DepositFailedEventObject
>;

export type DepositFailedEventFilter = TypedEventFilter<DepositFailedEvent>;

export interface DepositFinalizedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type DepositFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  DepositFinalizedEventObject
>;

export type DepositFinalizedEventFilter =
  TypedEventFilter<DepositFinalizedEvent>;

export interface DisputeGameBlacklistedEventObject {
  disputeGame: string;
}
export type DisputeGameBlacklistedEvent = TypedEvent<
  [string],
  DisputeGameBlacklistedEventObject
>;

export type DisputeGameBlacklistedEventFilter =
  TypedEventFilter<DisputeGameBlacklistedEvent>;

export interface DisputeGameCreatedEventObject {
  disputeProxy: string;
  gameType: number;
  rootClaim: string;
}
export type DisputeGameCreatedEvent = TypedEvent<
  [string, number, string],
  DisputeGameCreatedEventObject
>;

export type DisputeGameCreatedEventFilter =
  TypedEventFilter<DisputeGameCreatedEvent>;

export interface ERC20BridgeFinalizedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ERC20BridgeFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20BridgeFinalizedEventObject
>;

export type ERC20BridgeFinalizedEventFilter =
  TypedEventFilter<ERC20BridgeFinalizedEvent>;

export interface ERC20BridgeInitiatedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ERC20BridgeInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20BridgeInitiatedEventObject
>;

export type ERC20BridgeInitiatedEventFilter =
  TypedEventFilter<ERC20BridgeInitiatedEvent>;

export interface ERC20DepositInitiatedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ERC20DepositInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20DepositInitiatedEventObject
>;

export type ERC20DepositInitiatedEventFilter =
  TypedEventFilter<ERC20DepositInitiatedEvent>;

export interface ERC20WithdrawalFinalizedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ERC20WithdrawalFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20WithdrawalFinalizedEventObject
>;

export type ERC20WithdrawalFinalizedEventFilter =
  TypedEventFilter<ERC20WithdrawalFinalizedEvent>;

export interface ETHBridgeFinalizedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ETHBridgeFinalizedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHBridgeFinalizedEventObject
>;

export type ETHBridgeFinalizedEventFilter =
  TypedEventFilter<ETHBridgeFinalizedEvent>;

export interface ETHBridgeInitiatedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ETHBridgeInitiatedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHBridgeInitiatedEventObject
>;

export type ETHBridgeInitiatedEventFilter =
  TypedEventFilter<ETHBridgeInitiatedEvent>;

export interface ETHDepositInitiatedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ETHDepositInitiatedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHDepositInitiatedEventObject
>;

export type ETHDepositInitiatedEventFilter =
  TypedEventFilter<ETHDepositInitiatedEvent>;

export interface ETHWithdrawalFinalizedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type ETHWithdrawalFinalizedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHWithdrawalFinalizedEventObject
>;

export type ETHWithdrawalFinalizedEventFilter =
  TypedEventFilter<ETHWithdrawalFinalizedEvent>;

export interface FailedRelayedMessageEventObject {
  msgHash: string;
}
export type FailedRelayedMessageEvent = TypedEvent<
  [string],
  FailedRelayedMessageEventObject
>;

export type FailedRelayedMessageEventFilter =
  TypedEventFilter<FailedRelayedMessageEvent>;

export interface ImplementationSetEventObject {
  impl: string;
  gameType: number;
}
export type ImplementationSetEvent = TypedEvent<
  [string, number],
  ImplementationSetEventObject
>;

export type ImplementationSetEventFilter =
  TypedEventFilter<ImplementationSetEvent>;

export interface InitBondUpdatedEventObject {
  gameType: number;
  newBond: BigNumber;
}
export type InitBondUpdatedEvent = TypedEvent<
  [number, BigNumber],
  InitBondUpdatedEventObject
>;

export type InitBondUpdatedEventFilter = TypedEventFilter<InitBondUpdatedEvent>;

export interface MessagePassedEventObject {
  nonce: BigNumber;
  sender: string;
  target: string;
  value: BigNumber;
  gasLimit: BigNumber;
  data: string;
  withdrawalHash: string;
}
export type MessagePassedEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber, string, string],
  MessagePassedEventObject
>;

export type MessagePassedEventFilter = TypedEventFilter<MessagePassedEvent>;

export interface MoveEventObject {
  parentIndex: BigNumber;
  pivot: string;
  claimant: string;
}
export type MoveEvent = TypedEvent<
  [BigNumber, string, string],
  MoveEventObject
>;

export type MoveEventFilter = TypedEventFilter<MoveEvent>;

export interface OutputProposedEventObject {
  outputRoot: string;
  l2OutputIndex: BigNumber;
  l2BlockNumber: BigNumber;
  l1Timestamp: BigNumber;
}
export type OutputProposedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  OutputProposedEventObject
>;

export type OutputProposedEventFilter = TypedEventFilter<OutputProposedEvent>;

export interface OutputsDeletedEventObject {
  prevNextOutputIndex: BigNumber;
  newNextOutputIndex: BigNumber;
}
export type OutputsDeletedEvent = TypedEvent<
  [BigNumber, BigNumber],
  OutputsDeletedEventObject
>;

export type OutputsDeletedEventFilter = TypedEventFilter<OutputsDeletedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  identifier: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface ReceiveETHEventObject {
  amount: BigNumber;
}
export type ReceiveETHEvent = TypedEvent<[BigNumber], ReceiveETHEventObject>;

export type ReceiveETHEventFilter = TypedEventFilter<ReceiveETHEvent>;

export interface RelayedMessageEventObject {
  msgHash: string;
}
export type RelayedMessageEvent = TypedEvent<
  [string],
  RelayedMessageEventObject
>;

export type RelayedMessageEventFilter = TypedEventFilter<RelayedMessageEvent>;

export interface RespectedGameTypeSetEventObject {
  newGameType: number;
  updatedAt: BigNumber;
}
export type RespectedGameTypeSetEvent = TypedEvent<
  [number, BigNumber],
  RespectedGameTypeSetEventObject
>;

export type RespectedGameTypeSetEventFilter =
  TypedEventFilter<RespectedGameTypeSetEvent>;

export interface SentMessageEventObject {
  target: string;
  sender: string;
  message: string;
  messageNonce: BigNumber;
  gasLimit: BigNumber;
}
export type SentMessageEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  SentMessageEventObject
>;

export type SentMessageEventFilter = TypedEventFilter<SentMessageEvent>;

export interface SentMessageExtension1EventObject {
  sender: string;
  value: BigNumber;
}
export type SentMessageExtension1Event = TypedEvent<
  [string, BigNumber],
  SentMessageExtension1EventObject
>;

export type SentMessageExtension1EventFilter =
  TypedEventFilter<SentMessageExtension1Event>;

export interface TransactionDeposited_address_bytes32_uint256_bytes_EventObject {
  from: string;
  to: string;
  version: BigNumber;
  opaqueData: string;
}
export type TransactionDeposited_address_bytes32_uint256_bytes_Event =
  TypedEvent<
    [string, string, BigNumber, string],
    TransactionDeposited_address_bytes32_uint256_bytes_EventObject
  >;

export type TransactionDeposited_address_bytes32_uint256_bytes_EventFilter =
  TypedEventFilter<TransactionDeposited_address_bytes32_uint256_bytes_Event>;

export interface TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_EventObject {
  from: string;
  to: string;
  mint: BigNumber;
  value: BigNumber;
  gasLimit: BigNumber;
  isCreation: boolean;
  data: string;
}
export type TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_Event =
  TypedEvent<
    [string, string, BigNumber, BigNumber, BigNumber, boolean, string],
    TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_EventObject
  >;

export type TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_EventFilter =
  TypedEventFilter<TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_Event>;

export interface UnpausedEventObject {}
export type UnpausedEvent = TypedEvent<[], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface WhatHappenedEventObject {
  success: boolean;
  returndata: string;
}
export type WhatHappenedEvent = TypedEvent<
  [boolean, string],
  WhatHappenedEventObject
>;

export type WhatHappenedEventFilter = TypedEventFilter<WhatHappenedEvent>;

export interface WithdrawalEventObject {
  value: BigNumber;
  to: string;
  from: string;
}
export type WithdrawalEvent = TypedEvent<
  [BigNumber, string, string],
  WithdrawalEventObject
>;

export type WithdrawalEventFilter = TypedEventFilter<WithdrawalEvent>;

export interface WithdrawalFinalizedEventObject {
  withdrawalHash: string;
  success: boolean;
}
export type WithdrawalFinalizedEvent = TypedEvent<
  [string, boolean],
  WithdrawalFinalizedEventObject
>;

export type WithdrawalFinalizedEventFilter =
  TypedEventFilter<WithdrawalFinalizedEvent>;

export interface WithdrawalInitiatedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  data: string;
}
export type WithdrawalInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  WithdrawalInitiatedEventObject
>;

export type WithdrawalInitiatedEventFilter =
  TypedEventFilter<WithdrawalInitiatedEvent>;

export interface WithdrawalProvenEventObject {
  withdrawalHash: string;
  from: string;
  to: string;
}
export type WithdrawalProvenEvent = TypedEvent<
  [string, string, string],
  WithdrawalProvenEventObject
>;

export type WithdrawalProvenEventFilter =
  TypedEventFilter<WithdrawalProvenEvent>;

export interface WithdrawalProvenExtension1EventObject {
  withdrawalHash: string;
  proofSubmitter: string;
}
export type WithdrawalProvenExtension1Event = TypedEvent<
  [string, string],
  WithdrawalProvenExtension1EventObject
>;

export type WithdrawalProvenExtension1EventFilter =
  TypedEventFilter<WithdrawalProvenExtension1Event>;

export interface WithdrawerBalanceBurntEventObject {
  amount: BigNumber;
}
export type WithdrawerBalanceBurntEvent = TypedEvent<
  [BigNumber],
  WithdrawerBalanceBurntEventObject
>;

export type WithdrawerBalanceBurntEventFilter =
  TypedEventFilter<WithdrawerBalanceBurntEvent>;

export interface logEventObject {
  arg0: string;
}
export type logEvent = TypedEvent<[string], logEventObject>;

export type logEventFilter = TypedEventFilter<logEvent>;

export interface log_addressEventObject {
  arg0: string;
}
export type log_addressEvent = TypedEvent<[string], log_addressEventObject>;

export type log_addressEventFilter = TypedEventFilter<log_addressEvent>;

export interface log_array_uint256_array_EventObject {
  val: BigNumber[];
}
export type log_array_uint256_array_Event = TypedEvent<
  [BigNumber[]],
  log_array_uint256_array_EventObject
>;

export type log_array_uint256_array_EventFilter =
  TypedEventFilter<log_array_uint256_array_Event>;

export interface log_array_int256_array_EventObject {
  val: BigNumber[];
}
export type log_array_int256_array_Event = TypedEvent<
  [BigNumber[]],
  log_array_int256_array_EventObject
>;

export type log_array_int256_array_EventFilter =
  TypedEventFilter<log_array_int256_array_Event>;

export interface log_array_address_array_EventObject {
  val: string[];
}
export type log_array_address_array_Event = TypedEvent<
  [string[]],
  log_array_address_array_EventObject
>;

export type log_array_address_array_EventFilter =
  TypedEventFilter<log_array_address_array_Event>;

export interface log_bytesEventObject {
  arg0: string;
}
export type log_bytesEvent = TypedEvent<[string], log_bytesEventObject>;

export type log_bytesEventFilter = TypedEventFilter<log_bytesEvent>;

export interface log_bytes32EventObject {
  arg0: string;
}
export type log_bytes32Event = TypedEvent<[string], log_bytes32EventObject>;

export type log_bytes32EventFilter = TypedEventFilter<log_bytes32Event>;

export interface log_intEventObject {
  arg0: BigNumber;
}
export type log_intEvent = TypedEvent<[BigNumber], log_intEventObject>;

export type log_intEventFilter = TypedEventFilter<log_intEvent>;

export interface log_named_addressEventObject {
  key: string;
  val: string;
}
export type log_named_addressEvent = TypedEvent<
  [string, string],
  log_named_addressEventObject
>;

export type log_named_addressEventFilter =
  TypedEventFilter<log_named_addressEvent>;

export interface log_named_array_string_uint256_array_EventObject {
  key: string;
  val: BigNumber[];
}
export type log_named_array_string_uint256_array_Event = TypedEvent<
  [string, BigNumber[]],
  log_named_array_string_uint256_array_EventObject
>;

export type log_named_array_string_uint256_array_EventFilter =
  TypedEventFilter<log_named_array_string_uint256_array_Event>;

export interface log_named_array_string_int256_array_EventObject {
  key: string;
  val: BigNumber[];
}
export type log_named_array_string_int256_array_Event = TypedEvent<
  [string, BigNumber[]],
  log_named_array_string_int256_array_EventObject
>;

export type log_named_array_string_int256_array_EventFilter =
  TypedEventFilter<log_named_array_string_int256_array_Event>;

export interface log_named_array_string_address_array_EventObject {
  key: string;
  val: string[];
}
export type log_named_array_string_address_array_Event = TypedEvent<
  [string, string[]],
  log_named_array_string_address_array_EventObject
>;

export type log_named_array_string_address_array_EventFilter =
  TypedEventFilter<log_named_array_string_address_array_Event>;

export interface log_named_bytesEventObject {
  key: string;
  val: string;
}
export type log_named_bytesEvent = TypedEvent<
  [string, string],
  log_named_bytesEventObject
>;

export type log_named_bytesEventFilter = TypedEventFilter<log_named_bytesEvent>;

export interface log_named_bytes32EventObject {
  key: string;
  val: string;
}
export type log_named_bytes32Event = TypedEvent<
  [string, string],
  log_named_bytes32EventObject
>;

export type log_named_bytes32EventFilter =
  TypedEventFilter<log_named_bytes32Event>;

export interface log_named_decimal_intEventObject {
  key: string;
  val: BigNumber;
  decimals: BigNumber;
}
export type log_named_decimal_intEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  log_named_decimal_intEventObject
>;

export type log_named_decimal_intEventFilter =
  TypedEventFilter<log_named_decimal_intEvent>;

export interface log_named_decimal_uintEventObject {
  key: string;
  val: BigNumber;
  decimals: BigNumber;
}
export type log_named_decimal_uintEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  log_named_decimal_uintEventObject
>;

export type log_named_decimal_uintEventFilter =
  TypedEventFilter<log_named_decimal_uintEvent>;

export interface log_named_intEventObject {
  key: string;
  val: BigNumber;
}
export type log_named_intEvent = TypedEvent<
  [string, BigNumber],
  log_named_intEventObject
>;

export type log_named_intEventFilter = TypedEventFilter<log_named_intEvent>;

export interface log_named_stringEventObject {
  key: string;
  val: string;
}
export type log_named_stringEvent = TypedEvent<
  [string, string],
  log_named_stringEventObject
>;

export type log_named_stringEventFilter =
  TypedEventFilter<log_named_stringEvent>;

export interface log_named_uintEventObject {
  key: string;
  val: BigNumber;
}
export type log_named_uintEvent = TypedEvent<
  [string, BigNumber],
  log_named_uintEventObject
>;

export type log_named_uintEventFilter = TypedEventFilter<log_named_uintEvent>;

export interface log_stringEventObject {
  arg0: string;
}
export type log_stringEvent = TypedEvent<[string], log_stringEventObject>;

export type log_stringEventFilter = TypedEventFilter<log_stringEvent>;

export interface log_uintEventObject {
  arg0: BigNumber;
}
export type log_uintEvent = TypedEvent<[BigNumber], log_uintEventObject>;

export type log_uintEventFilter = TypedEventFilter<log_uintEvent>;

export interface logsEventObject {
  arg0: string;
}
export type logsEvent = TypedEvent<[string], logsEventObject>;

export type logsEventFilter = TypedEventFilter<logsEvent>;

export interface FaultDisputeGame_Test extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FaultDisputeGame_TestInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    IS_TEST(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

    enableAltDA(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    enableCustomGasToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    enableFaultProofs(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    enableInterop(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    excludeArtifacts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedArtifacts_: string[] }>;

    excludeContracts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedContracts_: string[] }>;

    excludeSenders(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedSenders_: string[] }>;

    failed(overrides?: CallOverrides): Promise<[boolean]>;

    init(
      rootClaim: BytesLike,
      absolutePrestate: BytesLike,
      l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Helper function to propose an output.
     */
    proposeAnotherOutput(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzSelectorStructOutput[]] & {
        targetedArtifactSelectors_: StdInvariant.FuzzSelectorStructOutput[];
      }
    >;

    targetArtifacts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedArtifacts_: string[] }>;

    targetContracts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedContracts_: string[] }>;

    targetInterfaces(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzInterfaceStructOutput[]] & {
        targetedInterfaces_: StdInvariant.FuzzInterfaceStructOutput[];
      }
    >;

    targetSelectors(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzSelectorStructOutput[]] & {
        targetedSelectors_: StdInvariant.FuzzSelectorStructOutput[];
      }
    >;

    targetSenders(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedSenders_: string[] }>;

    /**
     * Tests that adding local data with an out of bounds identifier reverts.
     */
    testFuzz_addLocalData_oob_reverts(
      _ident: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds. Also, this claim should always receive the bond when there is another counter that is as far left      as possible.
     */
    testFuzz_challengeRootL2Block_receivesBond_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      never succeeds.
     */
    testFuzz_challengeRootL2Block_rightBlockNumber_reverts(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds.
     */
    testFuzz_challengeRootL2Block_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when clock extension * 2 is greater than      the max clock duration.
     */
    testFuzz_constructor_clockExtensionTooLong_reverts(
      _maxClockDuration: BigNumberish,
      _clockExtension: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is greater than or equal to the `MAX_GAME_DEPTH`
     */
    testFuzz_constructor_invalidSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is less than the minimum split depth (currently 2).
     */
    testFuzz_constructor_lowSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `MAX_GAME_DEPTH` parameter is      greater  than `LibPosition.MAX_POSITION_BITLEN - 1`.
     */
    testFuzz_constructor_maxDepthTooLarge_reverts(
      _maxGameDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _challengePeriod The challenge period of the preimage oracle.
     */
    testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(
      _challengePeriod: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the game cannot be initialized with extra data of the incorrect length (must be 32 bytes)
     */
    testFuzz_initialize_badExtraData_reverts(
      _extraDataLen: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the game cannot be initialized with an output root that commits to <= the configured starting      block number
     */
    testFuzz_initialize_cannotProposeGenesis_reverts(
      _blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly in the subgame      that is disputing the transition from `GENESIS -> GENESIS + 1`
     */
    test_addLocalDataGenesisTransition_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly.
     */
    test_addLocalDataMiddle_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the L2 block number claim is favored over the bisected-to block when adding data
     */
    test_addLocalData_l2BlockNumberExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLP_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badProof_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that credit may not be drained past allowance through reentrancy.
     */
    test_claimCredit_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the game's starting timestamp is set correctly.
     */
    test_createdAt_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that the user cannot control the first 4 bytes of the CWIA data, disallowing them to control the      entrypoint when no calldata is provided to a call.
     */
    test_cwiaCalldata_userCannotControlSelector_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the game's extra data is set correctly.
     */
    test_extraData_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that the game's data is set correctly.
     */
    test_gameData_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that the game's type is set correctly.
     */
    test_gameType_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that the bond at a depth greater than the maximum game depth reverts.
     */
    test_getRequiredBond_outOfBounds_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the bond during the bisection game depths is correct.
     */
    test_getRequiredBond_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that the game is initialized with the correct data.
     */
    test_initialize_correctData_succeeds(
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Tests that the game cannot be initialized twice.
     */
    test_initialize_onlyOnce_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the proxy receives ETH from the dispute game factory.
     */
    test_initialize_receivesETH_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of the chess clock incrementation.
     */
    test_move_clockCorrectness_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that a move made after the clock time has exceeded reverts with the      `ClockTimeExceeded` error.
     */
    test_move_clockTimeExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that making a claim at the execution trace bisection root level with a valid status      byte succeeds.
     */
    test_move_correctStatusExecRoot_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that an attempt to defend the root claim reverts with the `CannotDefendRootClaim` error.
     */
    test_move_defendRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that an identical claim cannot be made twice. The duplicate claim attempt should      revert with the `ClaimAlreadyExists` error.
     */
    test_move_duplicateClaim_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that identical claims at the same position can be made in different subgames.
     */
    test_move_duplicateClaimsDifferentSubgames_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that an attempt to move at the maximum game depth reverts with the      `GameDepthExceeded` error.
     */
    test_move_gameDepthExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that a move while the game status is not `IN_PROGRESS` causes the call to revert      with the `GameNotInProgress` error
     */
    test_move_gameNotInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that a move reverts when the bonded amount is incorrect.
     */
    test_move_incorrectBondAmount_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that a move reverts when the disputed claim does not match its index.
     */
    test_move_incorrectDisputedIndex_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that making a claim at the execution trace bisection root level with an invalid status      byte reverts with the `UnexpectedRootClaim` error.
     */
    test_move_incorrectStatusExecRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    test_move_maxGameDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that an attempt to move against a claim that does not exist reverts with the      `ParentDoesNotExist` error.
     */
    test_move_nonExistentParent_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of an opening attack.
     */
    test_move_simpleAttack_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    test_move_splitDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the standard clock extension is triggered for a move that is not the      split depth or the max game depth.
     */
    test_move_standardClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolveClaim isn't possible if there's time      left for a counter.
     */
    test_resolution_lastSecondDisputes_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves with 2 actors and a dishonest root claim.
     */
    test_resolve_bondPayoutsSeveralActors_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves.
     */
    test_resolve_bondPayouts_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of resolving a game with a contested challenge claim.
     */
    test_resolve_challengeContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame multiple times
     */
    test_resolve_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame at max depth
     */
    test_resolve_claimAtMaxDepthAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the challenger, even if the game state is newer than the anchor.
     */
    test_resolve_invalidStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on moves to the leftmost actor in subgames containing successful counters.
     */
    test_resolve_leftmostBondPayout_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of a multi-part resolution of a single claim.
     */
    test_resolve_multiPart_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve reverts when the game state is      not in progress.
     */
    test_resolve_notInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve subgames out of order
     */
    test_resolve_outOfOrderResolution_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of resolving a single attack game state.
     */
    test_resolve_rootContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that resolve reverts when the absolute root      subgame has not been resolved.
     */
    test_resolve_rootUncontestedButUnresolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontestedClockNotExpired_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of resolving a game that reaches max game depth.
     */
    test_resolve_stepReached_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test for the correctness of resolving a game with multiplayer moves.
     */
    test_resolve_teamDeathmatch_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that the anchor state updates when the game resolves in favor of the defender and the anchor state is older than the game state.
     */
    test_resolve_validNewerStateUpdatesAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the defender but the game state is not newer than the anchor state.
     */
    test_resolve_validOlderStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that the game's root claim is set correctly.
     */
    test_rootClaim_succeeds(overrides?: CallOverrides): Promise<[void]>;

    /**
     * Tests that successfully step with true attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that step reverts with false attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that step reverts with false defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that successfully step with true defend claim when there is a true defend claim(claim7) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that step reverts with true defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Tests that a claim cannot be stepped against twice.
     */
    test_step_duplicateStep_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    warpToProposeTime(
      _nextBlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  IS_TEST(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Sets up the L1 contracts.
   */
  L1(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  enableAltDA(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  enableCustomGasToken(
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  enableFaultProofs(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  enableInterop(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  excludeArtifacts(overrides?: CallOverrides): Promise<string[]>;

  excludeContracts(overrides?: CallOverrides): Promise<string[]>;

  excludeSenders(overrides?: CallOverrides): Promise<string[]>;

  failed(overrides?: CallOverrides): Promise<boolean>;

  init(
    rootClaim: BytesLike,
    absolutePrestate: BytesLike,
    l2BlockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Helper function to propose an output.
   */
  proposeAnotherOutput(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
   */
  setUp(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  targetArtifactSelectors(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

  targetArtifacts(overrides?: CallOverrides): Promise<string[]>;

  targetContracts(overrides?: CallOverrides): Promise<string[]>;

  targetInterfaces(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzInterfaceStructOutput[]>;

  targetSelectors(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

  targetSenders(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Tests that adding local data with an out of bounds identifier reverts.
   */
  testFuzz_addLocalData_oob_reverts(
    _ident: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds. Also, this claim should always receive the bond when there is another counter that is as far left      as possible.
   */
  testFuzz_challengeRootL2Block_receivesBond_succeeds(
    _storageRoot: BytesLike,
    _withdrawalRoot: BytesLike,
    _l2BlockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      never succeeds.
   */
  testFuzz_challengeRootL2Block_rightBlockNumber_reverts(
    _storageRoot: BytesLike,
    _withdrawalRoot: BytesLike,
    _l2BlockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds.
   */
  testFuzz_challengeRootL2Block_succeeds(
    _storageRoot: BytesLike,
    _withdrawalRoot: BytesLike,
    _l2BlockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the constructor of the `FaultDisputeGame` reverts when clock extension * 2 is greater than      the max clock duration.
   */
  testFuzz_constructor_clockExtensionTooLong_reverts(
    _maxClockDuration: BigNumberish,
    _clockExtension: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is greater than or equal to the `MAX_GAME_DEPTH`
   */
  testFuzz_constructor_invalidSplitDepth_reverts(
    _splitDepth: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is less than the minimum split depth (currently 2).
   */
  testFuzz_constructor_lowSplitDepth_reverts(
    _splitDepth: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the constructor of the `FaultDisputeGame` reverts when the `MAX_GAME_DEPTH` parameter is      greater  than `LibPosition.MAX_POSITION_BITLEN - 1`.
   */
  testFuzz_constructor_maxDepthTooLarge_reverts(
    _maxGameDepth: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _challengePeriod The challenge period of the preimage oracle.
   */
  testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(
    _challengePeriod: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the game cannot be initialized with extra data of the incorrect length (must be 32 bytes)
   */
  testFuzz_initialize_badExtraData_reverts(
    _extraDataLen: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the game cannot be initialized with an output root that commits to <= the configured starting      block number
   */
  testFuzz_initialize_cannotProposeGenesis_reverts(
    _blockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that local data is loaded into the preimage oracle correctly in the subgame      that is disputing the transition from `GENESIS -> GENESIS + 1`
   */
  test_addLocalDataGenesisTransition_static_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that local data is loaded into the preimage oracle correctly.
   */
  test_addLocalDataMiddle_static_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the L2 block number claim is favored over the bisected-to block when adding data
   */
  test_addLocalData_l2BlockNumberExtension_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
   */
  test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
   */
  test_challengeRootL2Block_badHeaderRLP_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
   */
  test_challengeRootL2Block_badProof_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that credit may not be drained past allowance through reentrancy.
   */
  test_claimCredit_claimAlreadyResolved_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the game's starting timestamp is set correctly.
   */
  test_createdAt_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that the user cannot control the first 4 bytes of the CWIA data, disallowing them to control the      entrypoint when no calldata is provided to a call.
   */
  test_cwiaCalldata_userCannotControlSelector_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the game's extra data is set correctly.
   */
  test_extraData_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that the game's data is set correctly.
   */
  test_gameData_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that the game's type is set correctly.
   */
  test_gameType_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that the bond at a depth greater than the maximum game depth reverts.
   */
  test_getRequiredBond_outOfBounds_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the bond during the bisection game depths is correct.
   */
  test_getRequiredBond_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that the game is initialized with the correct data.
   */
  test_initialize_correctData_succeeds(
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Tests that the game cannot be initialized twice.
   */
  test_initialize_onlyOnce_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the proxy receives ETH from the dispute game factory.
   */
  test_initialize_receivesETH_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of the chess clock incrementation.
   */
  test_move_clockCorrectness_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that a move made after the clock time has exceeded reverts with the      `ClockTimeExceeded` error.
   */
  test_move_clockTimeExceeded_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that making a claim at the execution trace bisection root level with a valid status      byte succeeds.
   */
  test_move_correctStatusExecRoot_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that an attempt to defend the root claim reverts with the `CannotDefendRootClaim` error.
   */
  test_move_defendRoot_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that an identical claim cannot be made twice. The duplicate claim attempt should      revert with the `ClaimAlreadyExists` error.
   */
  test_move_duplicateClaim_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that identical claims at the same position can be made in different subgames.
   */
  test_move_duplicateClaimsDifferentSubgames_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that an attempt to move at the maximum game depth reverts with the      `GameDepthExceeded` error.
   */
  test_move_gameDepthExceeded_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that a move while the game status is not `IN_PROGRESS` causes the call to revert      with the `GameNotInProgress` error
   */
  test_move_gameNotInProgress_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that a move reverts when the bonded amount is incorrect.
   */
  test_move_incorrectBondAmount_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that a move reverts when the disputed claim does not match its index.
   */
  test_move_incorrectDisputedIndex_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that making a claim at the execution trace bisection root level with an invalid status      byte reverts with the `UnexpectedRootClaim` error.
   */
  test_move_incorrectStatusExecRoot_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  test_move_maxGameDepthClockExtension_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that an attempt to move against a claim that does not exist reverts with the      `ParentDoesNotExist` error.
   */
  test_move_nonExistentParent_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of an opening attack.
   */
  test_move_simpleAttack_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  test_move_splitDepthClockExtension_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the standard clock extension is triggered for a move that is not the      split depth or the max game depth.
   */
  test_move_standardClockExtension_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolveClaim isn't possible if there's time      left for a counter.
   */
  test_resolution_lastSecondDisputes_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves with 2 actors and a dishonest root claim.
   */
  test_resolve_bondPayoutsSeveralActors_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves.
   */
  test_resolve_bondPayouts_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of resolving a game with a contested challenge claim.
   */
  test_resolve_challengeContested_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve reverts when attempting to resolve a subgame multiple times
   */
  test_resolve_claimAlreadyResolved_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve reverts when attempting to resolve a subgame at max depth
   */
  test_resolve_claimAtMaxDepthAlreadyResolved_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that the anchor state does not change when the game resolves in favor of the challenger, even if the game state is newer than the anchor.
   */
  test_resolve_invalidStateSameAnchor_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve pays out bonds on moves to the leftmost actor in subgames containing successful counters.
   */
  test_resolve_leftmostBondPayout_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of a multi-part resolution of a single claim.
   */
  test_resolve_multiPart_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve reverts when the game state is      not in progress.
   */
  test_resolve_notInProgress_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve reverts when attempting to resolve subgames out of order
   */
  test_resolve_outOfOrderResolution_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of resolving a single attack game state.
   */
  test_resolve_rootContested_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that resolve reverts when the absolute root      subgame has not been resolved.
   */
  test_resolve_rootUncontestedButUnresolved_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness an uncontested root resolution.
   */
  test_resolve_rootUncontestedClockNotExpired_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness an uncontested root resolution.
   */
  test_resolve_rootUncontested_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of resolving a game that reaches max game depth.
   */
  test_resolve_stepReached_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test for the correctness of resolving a game with multiplayer moves.
   */
  test_resolve_teamDeathmatch_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that the anchor state updates when the game resolves in favor of the defender and the anchor state is older than the game state.
   */
  test_resolve_validNewerStateUpdatesAnchor_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Static unit test asserting that the anchor state does not change when the game resolves in favor of the defender but the game state is not newer than the anchor state.
   */
  test_resolve_validOlderStateSameAnchor_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that the game's root claim is set correctly.
   */
  test_rootClaim_succeeds(overrides?: CallOverrides): Promise<void>;

  /**
   * Tests that successfully step with true attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
   */
  test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that step reverts with false attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
   */
  test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that step reverts with false defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
   */
  test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that successfully step with true defend claim when there is a true defend claim(claim7) in the middle of the dispute game.
   */
  test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that step reverts with true defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
   */
  test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Tests that a claim cannot be stepped against twice.
   */
  test_step_duplicateStep_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  warpToProposeTime(
    _nextBlockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    IS_TEST(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: CallOverrides): Promise<void>;

    enableAltDA(overrides?: CallOverrides): Promise<void>;

    enableCustomGasToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    enableFaultProofs(overrides?: CallOverrides): Promise<void>;

    enableInterop(overrides?: CallOverrides): Promise<void>;

    excludeArtifacts(overrides?: CallOverrides): Promise<string[]>;

    excludeContracts(overrides?: CallOverrides): Promise<string[]>;

    excludeSenders(overrides?: CallOverrides): Promise<string[]>;

    failed(overrides?: CallOverrides): Promise<boolean>;

    init(
      rootClaim: BytesLike,
      absolutePrestate: BytesLike,
      l2BlockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Helper function to propose an output.
     */
    proposeAnotherOutput(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(overrides?: CallOverrides): Promise<void>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

    targetArtifacts(overrides?: CallOverrides): Promise<string[]>;

    targetContracts(overrides?: CallOverrides): Promise<string[]>;

    targetInterfaces(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzInterfaceStructOutput[]>;

    targetSelectors(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

    targetSenders(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Tests that adding local data with an out of bounds identifier reverts.
     */
    testFuzz_addLocalData_oob_reverts(
      _ident: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds. Also, this claim should always receive the bond when there is another counter that is as far left      as possible.
     */
    testFuzz_challengeRootL2Block_receivesBond_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      never succeeds.
     */
    testFuzz_challengeRootL2Block_rightBlockNumber_reverts(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds.
     */
    testFuzz_challengeRootL2Block_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when clock extension * 2 is greater than      the max clock duration.
     */
    testFuzz_constructor_clockExtensionTooLong_reverts(
      _maxClockDuration: BigNumberish,
      _clockExtension: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is greater than or equal to the `MAX_GAME_DEPTH`
     */
    testFuzz_constructor_invalidSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is less than the minimum split depth (currently 2).
     */
    testFuzz_constructor_lowSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `MAX_GAME_DEPTH` parameter is      greater  than `LibPosition.MAX_POSITION_BITLEN - 1`.
     */
    testFuzz_constructor_maxDepthTooLarge_reverts(
      _maxGameDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _challengePeriod The challenge period of the preimage oracle.
     */
    testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(
      _challengePeriod: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game cannot be initialized with extra data of the incorrect length (must be 32 bytes)
     */
    testFuzz_initialize_badExtraData_reverts(
      _extraDataLen: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game cannot be initialized with an output root that commits to <= the configured starting      block number
     */
    testFuzz_initialize_cannotProposeGenesis_reverts(
      _blockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly in the subgame      that is disputing the transition from `GENESIS -> GENESIS + 1`
     */
    test_addLocalDataGenesisTransition_static_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly.
     */
    test_addLocalDataMiddle_static_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the L2 block number claim is favored over the bisected-to block when adding data
     */
    test_addLocalData_l2BlockNumberExtension_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLP_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badProof_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that credit may not be drained past allowance through reentrancy.
     */
    test_claimCredit_claimAlreadyResolved_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game's starting timestamp is set correctly.
     */
    test_createdAt_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the user cannot control the first 4 bytes of the CWIA data, disallowing them to control the      entrypoint when no calldata is provided to a call.
     */
    test_cwiaCalldata_userCannotControlSelector_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game's extra data is set correctly.
     */
    test_extraData_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the game's data is set correctly.
     */
    test_gameData_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the game's type is set correctly.
     */
    test_gameType_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the bond at a depth greater than the maximum game depth reverts.
     */
    test_getRequiredBond_outOfBounds_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the bond during the bisection game depths is correct.
     */
    test_getRequiredBond_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the game is initialized with the correct data.
     */
    test_initialize_correctData_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game cannot be initialized twice.
     */
    test_initialize_onlyOnce_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that the proxy receives ETH from the dispute game factory.
     */
    test_initialize_receivesETH_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness of the chess clock incrementation.
     */
    test_move_clockCorrectness_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that a move made after the clock time has exceeded reverts with the      `ClockTimeExceeded` error.
     */
    test_move_clockTimeExceeded_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that making a claim at the execution trace bisection root level with a valid status      byte succeeds.
     */
    test_move_correctStatusExecRoot_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that an attempt to defend the root claim reverts with the `CannotDefendRootClaim` error.
     */
    test_move_defendRoot_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that an identical claim cannot be made twice. The duplicate claim attempt should      revert with the `ClaimAlreadyExists` error.
     */
    test_move_duplicateClaim_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * Static unit test asserting that identical claims at the same position can be made in different subgames.
     */
    test_move_duplicateClaimsDifferentSubgames_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that an attempt to move at the maximum game depth reverts with the      `GameDepthExceeded` error.
     */
    test_move_gameDepthExceeded_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that a move while the game status is not `IN_PROGRESS` causes the call to revert      with the `GameNotInProgress` error
     */
    test_move_gameNotInProgress_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that a move reverts when the bonded amount is incorrect.
     */
    test_move_incorrectBondAmount_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that a move reverts when the disputed claim does not match its index.
     */
    test_move_incorrectDisputedIndex_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that making a claim at the execution trace bisection root level with an invalid status      byte reverts with the `UnexpectedRootClaim` error.
     */
    test_move_incorrectStatusExecRoot_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    test_move_maxGameDepthClockExtension_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that an attempt to move against a claim that does not exist reverts with the      `ParentDoesNotExist` error.
     */
    test_move_nonExistentParent_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness of an opening attack.
     */
    test_move_simpleAttack_succeeds(overrides?: CallOverrides): Promise<void>;

    test_move_splitDepthClockExtension_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the standard clock extension is triggered for a move that is not the      split depth or the max game depth.
     */
    test_move_standardClockExtension_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolveClaim isn't possible if there's time      left for a counter.
     */
    test_resolution_lastSecondDisputes_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves with 2 actors and a dishonest root claim.
     */
    test_resolve_bondPayoutsSeveralActors_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves.
     */
    test_resolve_bondPayouts_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Static unit test for the correctness of resolving a game with a contested challenge claim.
     */
    test_resolve_challengeContested_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame multiple times
     */
    test_resolve_claimAlreadyResolved_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame at max depth
     */
    test_resolve_claimAtMaxDepthAlreadyResolved_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the challenger, even if the game state is newer than the anchor.
     */
    test_resolve_invalidStateSameAnchor_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve pays out bonds on moves to the leftmost actor in subgames containing successful counters.
     */
    test_resolve_leftmostBondPayout_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness of a multi-part resolution of a single claim.
     */
    test_resolve_multiPart_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Static unit test asserting that resolve reverts when the game state is      not in progress.
     */
    test_resolve_notInProgress_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve subgames out of order
     */
    test_resolve_outOfOrderResolution_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness of resolving a single attack game state.
     */
    test_resolve_rootContested_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that resolve reverts when the absolute root      subgame has not been resolved.
     */
    test_resolve_rootUncontestedButUnresolved_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontestedClockNotExpired_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontested_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test for the correctness of resolving a game that reaches max game depth.
     */
    test_resolve_stepReached_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Static unit test for the correctness of resolving a game with multiplayer moves.
     */
    test_resolve_teamDeathmatch_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that the anchor state updates when the game resolves in favor of the defender and the anchor state is older than the game state.
     */
    test_resolve_validNewerStateUpdatesAnchor_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the defender but the game state is not newer than the anchor state.
     */
    test_resolve_validOlderStateSameAnchor_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that the game's root claim is set correctly.
     */
    test_rootClaim_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Tests that successfully step with true attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that step reverts with false attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that step reverts with false defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that successfully step with true defend claim when there is a true defend claim(claim7) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that step reverts with true defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Tests that a claim cannot be stepped against twice.
     */
    test_step_duplicateStep_reverts(overrides?: CallOverrides): Promise<void>;

    warpToProposeTime(
      _nextBlockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "DepositFailed(address,address,address,address,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: string | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): DepositFailedEventFilter;
    DepositFailed(
      l1Token?: string | null,
      l2Token?: string | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): DepositFailedEventFilter;

    "DepositFinalized(address,address,address,address,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: string | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): DepositFinalizedEventFilter;
    DepositFinalized(
      l1Token?: string | null,
      l2Token?: string | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): DepositFinalizedEventFilter;

    "DisputeGameBlacklisted(address)"(
      disputeGame?: string | null
    ): DisputeGameBlacklistedEventFilter;
    DisputeGameBlacklisted(
      disputeGame?: string | null
    ): DisputeGameBlacklistedEventFilter;

    "DisputeGameCreated(address,uint32,bytes32)"(
      disputeProxy?: string | null,
      gameType?: BigNumberish | null,
      rootClaim?: BytesLike | null
    ): DisputeGameCreatedEventFilter;
    DisputeGameCreated(
      disputeProxy?: string | null,
      gameType?: BigNumberish | null,
      rootClaim?: BytesLike | null
    ): DisputeGameCreatedEventFilter;

    "ERC20BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20BridgeFinalizedEventFilter;
    ERC20BridgeFinalized(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20BridgeFinalizedEventFilter;

    "ERC20BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20BridgeInitiatedEventFilter;
    ERC20BridgeInitiated(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20BridgeInitiatedEventFilter;

    "ERC20DepositInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20DepositInitiatedEventFilter;
    ERC20DepositInitiated(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20DepositInitiatedEventFilter;

    "ERC20WithdrawalFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20WithdrawalFinalizedEventFilter;
    ERC20WithdrawalFinalized(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): ERC20WithdrawalFinalizedEventFilter;

    "ETHBridgeFinalized(bytes32,address,uint256,bytes)"(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      data?: null
    ): ETHBridgeFinalizedEventFilter;
    ETHBridgeFinalized(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      data?: null
    ): ETHBridgeFinalizedEventFilter;

    "ETHBridgeInitiated(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      data?: null
    ): ETHBridgeInitiatedEventFilter;
    ETHBridgeInitiated(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      data?: null
    ): ETHBridgeInitiatedEventFilter;

    "ETHDepositInitiated(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      data?: null
    ): ETHDepositInitiatedEventFilter;
    ETHDepositInitiated(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      data?: null
    ): ETHDepositInitiatedEventFilter;

    "ETHWithdrawalFinalized(bytes32,address,uint256,bytes)"(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      data?: null
    ): ETHWithdrawalFinalizedEventFilter;
    ETHWithdrawalFinalized(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      data?: null
    ): ETHWithdrawalFinalizedEventFilter;

    "FailedRelayedMessage(bytes32)"(
      msgHash?: BytesLike | null
    ): FailedRelayedMessageEventFilter;
    FailedRelayedMessage(
      msgHash?: BytesLike | null
    ): FailedRelayedMessageEventFilter;

    "ImplementationSet(address,uint32)"(
      impl?: string | null,
      gameType?: BigNumberish | null
    ): ImplementationSetEventFilter;
    ImplementationSet(
      impl?: string | null,
      gameType?: BigNumberish | null
    ): ImplementationSetEventFilter;

    "InitBondUpdated(uint32,uint256)"(
      gameType?: BigNumberish | null,
      newBond?: BigNumberish | null
    ): InitBondUpdatedEventFilter;
    InitBondUpdated(
      gameType?: BigNumberish | null,
      newBond?: BigNumberish | null
    ): InitBondUpdatedEventFilter;

    "MessagePassed(uint256,address,address,uint256,uint256,bytes,bytes32)"(
      nonce?: BigNumberish | null,
      sender?: string | null,
      target?: string | null,
      value?: null,
      gasLimit?: null,
      data?: null,
      withdrawalHash?: null
    ): MessagePassedEventFilter;
    MessagePassed(
      nonce?: BigNumberish | null,
      sender?: string | null,
      target?: string | null,
      value?: null,
      gasLimit?: null,
      data?: null,
      withdrawalHash?: null
    ): MessagePassedEventFilter;

    "Move(uint256,bytes32,address)"(
      parentIndex?: BigNumberish | null,
      pivot?: BytesLike | null,
      claimant?: string | null
    ): MoveEventFilter;
    Move(
      parentIndex?: BigNumberish | null,
      pivot?: BytesLike | null,
      claimant?: string | null
    ): MoveEventFilter;

    "OutputProposed(bytes32,uint256,uint256,uint256)"(
      outputRoot?: BytesLike | null,
      l2OutputIndex?: BigNumberish | null,
      l2BlockNumber?: BigNumberish | null,
      l1Timestamp?: null
    ): OutputProposedEventFilter;
    OutputProposed(
      outputRoot?: BytesLike | null,
      l2OutputIndex?: BigNumberish | null,
      l2BlockNumber?: BigNumberish | null,
      l1Timestamp?: null
    ): OutputProposedEventFilter;

    "OutputsDeleted(uint256,uint256)"(
      prevNextOutputIndex?: BigNumberish | null,
      newNextOutputIndex?: BigNumberish | null
    ): OutputsDeletedEventFilter;
    OutputsDeleted(
      prevNextOutputIndex?: BigNumberish | null,
      newNextOutputIndex?: BigNumberish | null
    ): OutputsDeletedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Paused(string)"(identifier?: null): PausedEventFilter;
    Paused(identifier?: null): PausedEventFilter;

    "ReceiveETH(uint256)"(amount?: null): ReceiveETHEventFilter;
    ReceiveETH(amount?: null): ReceiveETHEventFilter;

    "RelayedMessage(bytes32)"(
      msgHash?: BytesLike | null
    ): RelayedMessageEventFilter;
    RelayedMessage(msgHash?: BytesLike | null): RelayedMessageEventFilter;

    "RespectedGameTypeSet(uint32,uint64)"(
      newGameType?: BigNumberish | null,
      updatedAt?: BigNumberish | null
    ): RespectedGameTypeSetEventFilter;
    RespectedGameTypeSet(
      newGameType?: BigNumberish | null,
      updatedAt?: BigNumberish | null
    ): RespectedGameTypeSetEventFilter;

    "SentMessage(bytes32,address,bytes,uint256,uint256)"(
      target?: BytesLike | null,
      sender?: null,
      message?: null,
      messageNonce?: null,
      gasLimit?: null
    ): SentMessageEventFilter;
    SentMessage(
      target?: BytesLike | null,
      sender?: null,
      message?: null,
      messageNonce?: null,
      gasLimit?: null
    ): SentMessageEventFilter;

    "SentMessageExtension1(address,uint256)"(
      sender?: string | null,
      value?: null
    ): SentMessageExtension1EventFilter;
    SentMessageExtension1(
      sender?: string | null,
      value?: null
    ): SentMessageExtension1EventFilter;

    "TransactionDeposited(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      version?: BigNumberish | null,
      opaqueData?: null
    ): TransactionDeposited_address_bytes32_uint256_bytes_EventFilter;
    "TransactionDeposited(address,bytes32,uint256,uint256,uint64,bool,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      mint?: null,
      value?: null,
      gasLimit?: null,
      isCreation?: null,
      data?: null
    ): TransactionDeposited_address_bytes32_uint256_uint256_uint64_bool_bytes_EventFilter;

    "Unpaused()"(): UnpausedEventFilter;
    Unpaused(): UnpausedEventFilter;

    "WhatHappened(bool,bytes)"(
      success?: null,
      returndata?: null
    ): WhatHappenedEventFilter;
    WhatHappened(success?: null, returndata?: null): WhatHappenedEventFilter;

    "Withdrawal(uint256,address,address)"(
      value?: null,
      to?: null,
      from?: null
    ): WithdrawalEventFilter;
    Withdrawal(value?: null, to?: null, from?: null): WithdrawalEventFilter;

    "WithdrawalFinalized(bytes32,bool)"(
      withdrawalHash?: BytesLike | null,
      success?: null
    ): WithdrawalFinalizedEventFilter;
    WithdrawalFinalized(
      withdrawalHash?: BytesLike | null,
      success?: null
    ): WithdrawalFinalizedEventFilter;

    "WithdrawalInitiated(address,bytes32,bytes32,address,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): WithdrawalInitiatedEventFilter;
    WithdrawalInitiated(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      data?: null
    ): WithdrawalInitiatedEventFilter;

    "WithdrawalProven(bytes32,bytes32,address)"(
      withdrawalHash?: BytesLike | null,
      from?: BytesLike | null,
      to?: string | null
    ): WithdrawalProvenEventFilter;
    WithdrawalProven(
      withdrawalHash?: BytesLike | null,
      from?: BytesLike | null,
      to?: string | null
    ): WithdrawalProvenEventFilter;

    "WithdrawalProvenExtension1(bytes32,address)"(
      withdrawalHash?: BytesLike | null,
      proofSubmitter?: string | null
    ): WithdrawalProvenExtension1EventFilter;
    WithdrawalProvenExtension1(
      withdrawalHash?: BytesLike | null,
      proofSubmitter?: string | null
    ): WithdrawalProvenExtension1EventFilter;

    "WithdrawerBalanceBurnt(uint256)"(
      amount?: BigNumberish | null
    ): WithdrawerBalanceBurntEventFilter;
    WithdrawerBalanceBurnt(
      amount?: BigNumberish | null
    ): WithdrawerBalanceBurntEventFilter;

    "log(string)"(arg0?: null): logEventFilter;
    log(arg0?: null): logEventFilter;

    "log_address(address)"(arg0?: null): log_addressEventFilter;
    log_address(arg0?: null): log_addressEventFilter;

    "log_array(uint256[])"(val?: null): log_array_uint256_array_EventFilter;
    "log_array(int256[])"(val?: null): log_array_int256_array_EventFilter;
    "log_array(address[])"(val?: null): log_array_address_array_EventFilter;

    "log_bytes(bytes)"(arg0?: null): log_bytesEventFilter;
    log_bytes(arg0?: null): log_bytesEventFilter;

    "log_bytes32(bytes32)"(arg0?: null): log_bytes32EventFilter;
    log_bytes32(arg0?: null): log_bytes32EventFilter;

    "log_int(int256)"(arg0?: null): log_intEventFilter;
    log_int(arg0?: null): log_intEventFilter;

    "log_named_address(string,address)"(
      key?: null,
      val?: null
    ): log_named_addressEventFilter;
    log_named_address(key?: null, val?: null): log_named_addressEventFilter;

    "log_named_array(string,uint256[])"(
      key?: null,
      val?: null
    ): log_named_array_string_uint256_array_EventFilter;
    "log_named_array(string,int256[])"(
      key?: null,
      val?: null
    ): log_named_array_string_int256_array_EventFilter;
    "log_named_array(string,address[])"(
      key?: null,
      val?: null
    ): log_named_array_string_address_array_EventFilter;

    "log_named_bytes(string,bytes)"(
      key?: null,
      val?: null
    ): log_named_bytesEventFilter;
    log_named_bytes(key?: null, val?: null): log_named_bytesEventFilter;

    "log_named_bytes32(string,bytes32)"(
      key?: null,
      val?: null
    ): log_named_bytes32EventFilter;
    log_named_bytes32(key?: null, val?: null): log_named_bytes32EventFilter;

    "log_named_decimal_int(string,int256,uint256)"(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_intEventFilter;
    log_named_decimal_int(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_intEventFilter;

    "log_named_decimal_uint(string,uint256,uint256)"(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_uintEventFilter;
    log_named_decimal_uint(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_uintEventFilter;

    "log_named_int(string,int256)"(
      key?: null,
      val?: null
    ): log_named_intEventFilter;
    log_named_int(key?: null, val?: null): log_named_intEventFilter;

    "log_named_string(string,string)"(
      key?: null,
      val?: null
    ): log_named_stringEventFilter;
    log_named_string(key?: null, val?: null): log_named_stringEventFilter;

    "log_named_uint(string,uint256)"(
      key?: null,
      val?: null
    ): log_named_uintEventFilter;
    log_named_uint(key?: null, val?: null): log_named_uintEventFilter;

    "log_string(string)"(arg0?: null): log_stringEventFilter;
    log_string(arg0?: null): log_stringEventFilter;

    "log_uint(uint256)"(arg0?: null): log_uintEventFilter;
    log_uint(arg0?: null): log_uintEventFilter;

    "logs(bytes)"(arg0?: null): logsEventFilter;
    logs(arg0?: null): logsEventFilter;
  };

  estimateGas: {
    IS_TEST(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    enableAltDA(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    enableCustomGasToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    enableFaultProofs(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    enableInterop(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    excludeArtifacts(overrides?: CallOverrides): Promise<BigNumber>;

    excludeContracts(overrides?: CallOverrides): Promise<BigNumber>;

    excludeSenders(overrides?: CallOverrides): Promise<BigNumber>;

    failed(overrides?: CallOverrides): Promise<BigNumber>;

    init(
      rootClaim: BytesLike,
      absolutePrestate: BytesLike,
      l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Helper function to propose an output.
     */
    proposeAnotherOutput(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    targetArtifactSelectors(overrides?: CallOverrides): Promise<BigNumber>;

    targetArtifacts(overrides?: CallOverrides): Promise<BigNumber>;

    targetContracts(overrides?: CallOverrides): Promise<BigNumber>;

    targetInterfaces(overrides?: CallOverrides): Promise<BigNumber>;

    targetSelectors(overrides?: CallOverrides): Promise<BigNumber>;

    targetSenders(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that adding local data with an out of bounds identifier reverts.
     */
    testFuzz_addLocalData_oob_reverts(
      _ident: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds. Also, this claim should always receive the bond when there is another counter that is as far left      as possible.
     */
    testFuzz_challengeRootL2Block_receivesBond_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      never succeeds.
     */
    testFuzz_challengeRootL2Block_rightBlockNumber_reverts(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds.
     */
    testFuzz_challengeRootL2Block_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when clock extension * 2 is greater than      the max clock duration.
     */
    testFuzz_constructor_clockExtensionTooLong_reverts(
      _maxClockDuration: BigNumberish,
      _clockExtension: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is greater than or equal to the `MAX_GAME_DEPTH`
     */
    testFuzz_constructor_invalidSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is less than the minimum split depth (currently 2).
     */
    testFuzz_constructor_lowSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `MAX_GAME_DEPTH` parameter is      greater  than `LibPosition.MAX_POSITION_BITLEN - 1`.
     */
    testFuzz_constructor_maxDepthTooLarge_reverts(
      _maxGameDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _challengePeriod The challenge period of the preimage oracle.
     */
    testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(
      _challengePeriod: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the game cannot be initialized with extra data of the incorrect length (must be 32 bytes)
     */
    testFuzz_initialize_badExtraData_reverts(
      _extraDataLen: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the game cannot be initialized with an output root that commits to <= the configured starting      block number
     */
    testFuzz_initialize_cannotProposeGenesis_reverts(
      _blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly in the subgame      that is disputing the transition from `GENESIS -> GENESIS + 1`
     */
    test_addLocalDataGenesisTransition_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly.
     */
    test_addLocalDataMiddle_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the L2 block number claim is favored over the bisected-to block when adding data
     */
    test_addLocalData_l2BlockNumberExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLP_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badProof_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that credit may not be drained past allowance through reentrancy.
     */
    test_claimCredit_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the game's starting timestamp is set correctly.
     */
    test_createdAt_succeeds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that the user cannot control the first 4 bytes of the CWIA data, disallowing them to control the      entrypoint when no calldata is provided to a call.
     */
    test_cwiaCalldata_userCannotControlSelector_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the game's extra data is set correctly.
     */
    test_extraData_succeeds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that the game's data is set correctly.
     */
    test_gameData_succeeds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that the game's type is set correctly.
     */
    test_gameType_succeeds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that the bond at a depth greater than the maximum game depth reverts.
     */
    test_getRequiredBond_outOfBounds_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the bond during the bisection game depths is correct.
     */
    test_getRequiredBond_succeeds(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Tests that the game is initialized with the correct data.
     */
    test_initialize_correctData_succeeds(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Tests that the game cannot be initialized twice.
     */
    test_initialize_onlyOnce_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the proxy receives ETH from the dispute game factory.
     */
    test_initialize_receivesETH_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of the chess clock incrementation.
     */
    test_move_clockCorrectness_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that a move made after the clock time has exceeded reverts with the      `ClockTimeExceeded` error.
     */
    test_move_clockTimeExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that making a claim at the execution trace bisection root level with a valid status      byte succeeds.
     */
    test_move_correctStatusExecRoot_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that an attempt to defend the root claim reverts with the `CannotDefendRootClaim` error.
     */
    test_move_defendRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that an identical claim cannot be made twice. The duplicate claim attempt should      revert with the `ClaimAlreadyExists` error.
     */
    test_move_duplicateClaim_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that identical claims at the same position can be made in different subgames.
     */
    test_move_duplicateClaimsDifferentSubgames_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that an attempt to move at the maximum game depth reverts with the      `GameDepthExceeded` error.
     */
    test_move_gameDepthExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that a move while the game status is not `IN_PROGRESS` causes the call to revert      with the `GameNotInProgress` error
     */
    test_move_gameNotInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that a move reverts when the bonded amount is incorrect.
     */
    test_move_incorrectBondAmount_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that a move reverts when the disputed claim does not match its index.
     */
    test_move_incorrectDisputedIndex_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that making a claim at the execution trace bisection root level with an invalid status      byte reverts with the `UnexpectedRootClaim` error.
     */
    test_move_incorrectStatusExecRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    test_move_maxGameDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that an attempt to move against a claim that does not exist reverts with the      `ParentDoesNotExist` error.
     */
    test_move_nonExistentParent_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of an opening attack.
     */
    test_move_simpleAttack_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    test_move_splitDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the standard clock extension is triggered for a move that is not the      split depth or the max game depth.
     */
    test_move_standardClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolveClaim isn't possible if there's time      left for a counter.
     */
    test_resolution_lastSecondDisputes_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves with 2 actors and a dishonest root claim.
     */
    test_resolve_bondPayoutsSeveralActors_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves.
     */
    test_resolve_bondPayouts_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of resolving a game with a contested challenge claim.
     */
    test_resolve_challengeContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame multiple times
     */
    test_resolve_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame at max depth
     */
    test_resolve_claimAtMaxDepthAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the challenger, even if the game state is newer than the anchor.
     */
    test_resolve_invalidStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve pays out bonds on moves to the leftmost actor in subgames containing successful counters.
     */
    test_resolve_leftmostBondPayout_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of a multi-part resolution of a single claim.
     */
    test_resolve_multiPart_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve reverts when the game state is      not in progress.
     */
    test_resolve_notInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve subgames out of order
     */
    test_resolve_outOfOrderResolution_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of resolving a single attack game state.
     */
    test_resolve_rootContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that resolve reverts when the absolute root      subgame has not been resolved.
     */
    test_resolve_rootUncontestedButUnresolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontestedClockNotExpired_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of resolving a game that reaches max game depth.
     */
    test_resolve_stepReached_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test for the correctness of resolving a game with multiplayer moves.
     */
    test_resolve_teamDeathmatch_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that the anchor state updates when the game resolves in favor of the defender and the anchor state is older than the game state.
     */
    test_resolve_validNewerStateUpdatesAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the defender but the game state is not newer than the anchor state.
     */
    test_resolve_validOlderStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that the game's root claim is set correctly.
     */
    test_rootClaim_succeeds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Tests that successfully step with true attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that step reverts with false attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that step reverts with false defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that successfully step with true defend claim when there is a true defend claim(claim7) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that step reverts with true defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Tests that a claim cannot be stepped against twice.
     */
    test_step_duplicateStep_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    warpToProposeTime(
      _nextBlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    IS_TEST(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Sets up the L1 contracts.
     */
    L1(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enableAltDA(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enableCustomGasToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enableFaultProofs(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enableInterop(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    excludeArtifacts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    excludeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    excludeSenders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    failed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    init(
      rootClaim: BytesLike,
      absolutePrestate: BytesLike,
      l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Helper function to propose an output.
     */
    proposeAnotherOutput(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targetArtifacts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetInterfaces(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetSelectors(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetSenders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Tests that adding local data with an out of bounds identifier reverts.
     */
    testFuzz_addLocalData_oob_reverts(
      _ident: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds. Also, this claim should always receive the bond when there is another counter that is as far left      as possible.
     */
    testFuzz_challengeRootL2Block_receivesBond_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      never succeeds.
     */
    testFuzz_challengeRootL2Block_rightBlockNumber_reverts(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number by providing the real preimage of the output root      succeeds.
     */
    testFuzz_challengeRootL2Block_succeeds(
      _storageRoot: BytesLike,
      _withdrawalRoot: BytesLike,
      _l2BlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when clock extension * 2 is greater than      the max clock duration.
     */
    testFuzz_constructor_clockExtensionTooLong_reverts(
      _maxClockDuration: BigNumberish,
      _clockExtension: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is greater than or equal to the `MAX_GAME_DEPTH`
     */
    testFuzz_constructor_invalidSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `_splitDepth`      parameter is less than the minimum split depth (currently 2).
     */
    testFuzz_constructor_lowSplitDepth_reverts(
      _splitDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the constructor of the `FaultDisputeGame` reverts when the `MAX_GAME_DEPTH` parameter is      greater  than `LibPosition.MAX_POSITION_BITLEN - 1`.
     */
    testFuzz_constructor_maxDepthTooLarge_reverts(
      _maxGameDepth: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _challengePeriod The challenge period of the preimage oracle.
     */
    testFuzz_constructor_oracleChallengePeriodTooLarge_reverts(
      _challengePeriod: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game cannot be initialized with extra data of the incorrect length (must be 32 bytes)
     */
    testFuzz_initialize_badExtraData_reverts(
      _extraDataLen: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game cannot be initialized with an output root that commits to <= the configured starting      block number
     */
    testFuzz_initialize_cannotProposeGenesis_reverts(
      _blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly in the subgame      that is disputing the transition from `GENESIS -> GENESIS + 1`
     */
    test_addLocalDataGenesisTransition_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that local data is loaded into the preimage oracle correctly.
     */
    test_addLocalDataMiddle_static_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the L2 block number claim is favored over the bisected-to block when adding data
     */
    test_addLocalData_l2BlockNumberExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLPBlockNumberLength_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badHeaderRLP_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that challenging the root claim's L2 block number with a bad output root proof reverts.
     */
    test_challengeRootL2Block_badProof_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that credit may not be drained past allowance through reentrancy.
     */
    test_claimCredit_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game's starting timestamp is set correctly.
     */
    test_createdAt_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the user cannot control the first 4 bytes of the CWIA data, disallowing them to control the      entrypoint when no calldata is provided to a call.
     */
    test_cwiaCalldata_userCannotControlSelector_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game's extra data is set correctly.
     */
    test_extraData_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game's data is set correctly.
     */
    test_gameData_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game's type is set correctly.
     */
    test_gameType_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the bond at a depth greater than the maximum game depth reverts.
     */
    test_getRequiredBond_outOfBounds_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the bond during the bisection game depths is correct.
     */
    test_getRequiredBond_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game is initialized with the correct data.
     */
    test_initialize_correctData_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game cannot be initialized twice.
     */
    test_initialize_onlyOnce_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the proxy receives ETH from the dispute game factory.
     */
    test_initialize_receivesETH_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of the chess clock incrementation.
     */
    test_move_clockCorrectness_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that a move made after the clock time has exceeded reverts with the      `ClockTimeExceeded` error.
     */
    test_move_clockTimeExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that making a claim at the execution trace bisection root level with a valid status      byte succeeds.
     */
    test_move_correctStatusExecRoot_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that an attempt to defend the root claim reverts with the `CannotDefendRootClaim` error.
     */
    test_move_defendRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that an identical claim cannot be made twice. The duplicate claim attempt should      revert with the `ClaimAlreadyExists` error.
     */
    test_move_duplicateClaim_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that identical claims at the same position can be made in different subgames.
     */
    test_move_duplicateClaimsDifferentSubgames_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that an attempt to move at the maximum game depth reverts with the      `GameDepthExceeded` error.
     */
    test_move_gameDepthExceeded_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that a move while the game status is not `IN_PROGRESS` causes the call to revert      with the `GameNotInProgress` error
     */
    test_move_gameNotInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that a move reverts when the bonded amount is incorrect.
     */
    test_move_incorrectBondAmount_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that a move reverts when the disputed claim does not match its index.
     */
    test_move_incorrectDisputedIndex_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that making a claim at the execution trace bisection root level with an invalid status      byte reverts with the `UnexpectedRootClaim` error.
     */
    test_move_incorrectStatusExecRoot_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    test_move_maxGameDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that an attempt to move against a claim that does not exist reverts with the      `ParentDoesNotExist` error.
     */
    test_move_nonExistentParent_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of an opening attack.
     */
    test_move_simpleAttack_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    test_move_splitDepthClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the standard clock extension is triggered for a move that is not the      split depth or the max game depth.
     */
    test_move_standardClockExtension_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolveClaim isn't possible if there's time      left for a counter.
     */
    test_resolution_lastSecondDisputes_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves with 2 actors and a dishonest root claim.
     */
    test_resolve_bondPayoutsSeveralActors_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on step, output bisection, and execution trace moves.
     */
    test_resolve_bondPayouts_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of resolving a game with a contested challenge claim.
     */
    test_resolve_challengeContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame multiple times
     */
    test_resolve_claimAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve a subgame at max depth
     */
    test_resolve_claimAtMaxDepthAlreadyResolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the challenger, even if the game state is newer than the anchor.
     */
    test_resolve_invalidStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve pays out bonds on moves to the leftmost actor in subgames containing successful counters.
     */
    test_resolve_leftmostBondPayout_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of a multi-part resolution of a single claim.
     */
    test_resolve_multiPart_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve reverts when the game state is      not in progress.
     */
    test_resolve_notInProgress_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve reverts when attempting to resolve subgames out of order
     */
    test_resolve_outOfOrderResolution_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of resolving a single attack game state.
     */
    test_resolve_rootContested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that resolve reverts when the absolute root      subgame has not been resolved.
     */
    test_resolve_rootUncontestedButUnresolved_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontestedClockNotExpired_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness an uncontested root resolution.
     */
    test_resolve_rootUncontested_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of resolving a game that reaches max game depth.
     */
    test_resolve_stepReached_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test for the correctness of resolving a game with multiplayer moves.
     */
    test_resolve_teamDeathmatch_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that the anchor state updates when the game resolves in favor of the defender and the anchor state is older than the game state.
     */
    test_resolve_validNewerStateUpdatesAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Static unit test asserting that the anchor state does not change when the game resolves in favor of the defender but the game state is not newer than the anchor state.
     */
    test_resolve_validOlderStateSameAnchor_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that the game's root claim is set correctly.
     */
    test_rootClaim_succeeds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that successfully step with true attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that step reverts with false attacking claim when there is a true defend claim(claim5) in the middle of the dispute game.
     */
    test_stepAttackTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that step reverts with false defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that successfully step with true defend claim when there is a true defend claim(claim7) in the middle of the dispute game.
     */
    test_stepDefendDummyClaim_defendTrueClaimInTheMiddle_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that step reverts with true defending claim when there is a true defend claim(postState_) in the middle of the dispute game.
     */
    test_stepDefendTrueClaim_defendTrueClaimInTheMiddle_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Tests that a claim cannot be stepped against twice.
     */
    test_step_duplicateStep_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    warpToProposeTime(
      _nextBlockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
