/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace PreimageOracle {
  export type LeafStruct = {
    input: BytesLike;
    index: BigNumberish;
    stateCommitment: BytesLike;
  };

  export type LeafStructOutput = [string, BigNumber, string] & {
    input: string;
    index: BigNumber;
    stateCommitment: string;
  };
}

export declare namespace LibKeccak {
  export type StateMatrixStruct = { state: BigNumberish[] };

  export type StateMatrixStructOutput = [BigNumber[]] & { state: BigNumber[] };
}

export interface PreimageOracleInterface extends utils.Interface {
  functions: {
    "KECCAK_TREE_DEPTH()": FunctionFragment;
    "MAX_LEAF_COUNT()": FunctionFragment;
    "MIN_BOND_SIZE()": FunctionFragment;
    "PRECOMPILE_CALL_RESERVED_GAS()": FunctionFragment;
    "addLeavesLPP(uint256,uint256,bytes,bytes32[],bool)": FunctionFragment;
    "challengeFirstLPP(address,uint256,(bytes,uint256,bytes32),bytes32[])": FunctionFragment;
    "challengeLPP(address,uint256,(uint64[25]),(bytes,uint256,bytes32),bytes32[],(bytes,uint256,bytes32),bytes32[])": FunctionFragment;
    "challengePeriod()": FunctionFragment;
    "getTreeRootLPP(address,uint256)": FunctionFragment;
    "initLPP(uint256,uint32,uint32)": FunctionFragment;
    "loadBlobPreimagePart(uint256,uint256,bytes,bytes,uint256)": FunctionFragment;
    "loadKeccak256PreimagePart(uint256,bytes)": FunctionFragment;
    "loadLocalData(uint256,bytes32,bytes32,uint256,uint256)": FunctionFragment;
    "loadPrecompilePreimagePart(uint256,address,uint64,bytes)": FunctionFragment;
    "loadSha256PreimagePart(uint256,bytes)": FunctionFragment;
    "minProposalSize()": FunctionFragment;
    "preimageLengths(bytes32)": FunctionFragment;
    "preimagePartOk(bytes32,uint256)": FunctionFragment;
    "preimageParts(bytes32,uint256)": FunctionFragment;
    "proposalBlocks(address,uint256,uint256)": FunctionFragment;
    "proposalBlocksLen(address,uint256)": FunctionFragment;
    "proposalBonds(address,uint256)": FunctionFragment;
    "proposalBranches(address,uint256,uint256)": FunctionFragment;
    "proposalCount()": FunctionFragment;
    "proposalMetadata(address,uint256)": FunctionFragment;
    "proposalParts(address,uint256)": FunctionFragment;
    "proposals(uint256)": FunctionFragment;
    "readPreimage(bytes32,uint256)": FunctionFragment;
    "squeezeLPP(address,uint256,(uint64[25]),(bytes,uint256,bytes32),bytes32[],(bytes,uint256,bytes32),bytes32[])": FunctionFragment;
    "version()": FunctionFragment;
    "zeroHashes(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "KECCAK_TREE_DEPTH"
      | "MAX_LEAF_COUNT"
      | "MIN_BOND_SIZE"
      | "PRECOMPILE_CALL_RESERVED_GAS"
      | "addLeavesLPP"
      | "challengeFirstLPP"
      | "challengeLPP"
      | "challengePeriod"
      | "getTreeRootLPP"
      | "initLPP"
      | "loadBlobPreimagePart"
      | "loadKeccak256PreimagePart"
      | "loadLocalData"
      | "loadPrecompilePreimagePart"
      | "loadSha256PreimagePart"
      | "minProposalSize"
      | "preimageLengths"
      | "preimagePartOk"
      | "preimageParts"
      | "proposalBlocks"
      | "proposalBlocksLen"
      | "proposalBonds"
      | "proposalBranches"
      | "proposalCount"
      | "proposalMetadata"
      | "proposalParts"
      | "proposals"
      | "readPreimage"
      | "squeezeLPP"
      | "version"
      | "zeroHashes"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "KECCAK_TREE_DEPTH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_LEAF_COUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_BOND_SIZE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PRECOMPILE_CALL_RESERVED_GAS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addLeavesLPP",
    values: [BigNumberish, BigNumberish, BytesLike, BytesLike[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "challengeFirstLPP",
    values: [string, BigNumberish, PreimageOracle.LeafStruct, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "challengeLPP",
    values: [
      string,
      BigNumberish,
      LibKeccak.StateMatrixStruct,
      PreimageOracle.LeafStruct,
      BytesLike[],
      PreimageOracle.LeafStruct,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "challengePeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTreeRootLPP",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initLPP",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "loadBlobPreimagePart",
    values: [BigNumberish, BigNumberish, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "loadKeccak256PreimagePart",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "loadLocalData",
    values: [BigNumberish, BytesLike, BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "loadPrecompilePreimagePart",
    values: [BigNumberish, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "loadSha256PreimagePart",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "minProposalSize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "preimageLengths",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "preimagePartOk",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "preimageParts",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBlocks",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBlocksLen",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBonds",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBranches",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposalMetadata",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalParts",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposals",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readPreimage",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "squeezeLPP",
    values: [
      string,
      BigNumberish,
      LibKeccak.StateMatrixStruct,
      PreimageOracle.LeafStruct,
      BytesLike[],
      PreimageOracle.LeafStruct,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "zeroHashes",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "KECCAK_TREE_DEPTH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_LEAF_COUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_BOND_SIZE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PRECOMPILE_CALL_RESERVED_GAS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLeavesLPP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "challengeFirstLPP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "challengeLPP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "challengePeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTreeRootLPP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initLPP", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "loadBlobPreimagePart",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadKeccak256PreimagePart",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadLocalData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadPrecompilePreimagePart",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadSha256PreimagePart",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minProposalSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preimageLengths",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preimagePartOk",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preimageParts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBlocksLen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBonds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBranches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalParts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proposals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "readPreimage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "squeezeLPP", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "zeroHashes", data: BytesLike): Result;

  events: {};
}

export interface PreimageOracle extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PreimageOracleInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The depth of the keccak256 merkle tree. Supports up to 65,536 keccak blocks, or ~8.91MB preimages.
     */
    KECCAK_TREE_DEPTH(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The maximum number of keccak blocks that can fit into the merkle tree.
     */
    MAX_LEAF_COUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The minimum bond size for large preimage proposals.
     */
    MIN_BOND_SIZE(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The reserved gas for precompile call setup.
     */
    PRECOMPILE_CALL_RESERVED_GAS(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Adds a contiguous list of keccak state matrices to the merkle tree.
     */
    addLeavesLPP(
      _uuid: BigNumberish,
      _inputStartBlock: BigNumberish,
      _input: BytesLike,
      _stateCommitments: BytesLike[],
      _finalize: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    challengeFirstLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    challengeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the length of the large preimage proposal challenge period.
     */
    challengePeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { challengePeriod_: BigNumber }>;

    /**
     * Gets the current merkle root of the large preimage proposal tree.
     */
    getTreeRootLPP(
      _owner: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { treeRoot_: string }>;

    /**
     * Initialize a large preimage proposal. Must be called before adding any leaves.
     */
    initLPP(
      _uuid: BigNumberish,
      _partOffset: BigNumberish,
      _claimedSize: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _commitment The commitment to the polynomial. 48 bytes, part of the preimage key.
     * @param _partOffset The offset of the preimage to store.
     * @param _proof The KZG proof, part of the preimage key.
     * @param _y Big endian point value. The preimage for the key.
     * @param _z Big endian point value. Part of the preimage key.
     */
    loadBlobPreimagePart(
      _z: BigNumberish,
      _y: BigNumberish,
      _commitment: BytesLike,
      _proof: BytesLike,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prepares a preimage to be read by keccak256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadKeccak256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The local data parts are loaded into the preimage oracle under the context      of the caller - no other account can write to the caller's context      specific data.      There are 5 local data identifiers:      ┌────────────┬────────────────────────┐      │ Identifier │      Data              │      ├────────────┼────────────────────────┤      │          1 │ L1 Head Hash (bytes32) │      │          2 │ Output Root (bytes32)  │      │          3 │ Root Claim (bytes32)   │      │          4 │ L2 Block Number (u64)  │      │          5 │ Chain ID (u64)         │      └────────────┴────────────────────────┘
     * Loads of local data part into the preimage oracle.
     * @param _ident The identifier of the local data.
     * @param _localContext The local key context for the preimage oracle. Optionally, can be set as a constant                      if the caller only requires one set of local keys.
     * @param _partOffset The offset of the local data part to write to the oracle.
     * @param _size The number of bytes in `_word` to load.
     * @param _word The local data word.
     */
    loadLocalData(
      _ident: BigNumberish,
      _localContext: BytesLike,
      _word: BytesLike,
      _size: BigNumberish,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prepares a precompile result to be read by a precompile key for the specified offset.         The precompile result data is a concatenation of the precompile call status byte and its return data.         The preimage key is `6 ++ keccak256(precompile ++ input)[1:]`.
     * @param _input The input to the precompile call.
     * @param _partOffset The offset of the precompile result being loaded.
     * @param _precompile The precompile address
     * @param _requiredGas The gas required to fully execute an L1 precompile.
     */
    loadPrecompilePreimagePart(
      _partOffset: BigNumberish,
      _precompile: string,
      _requiredGas: BigNumberish,
      _input: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prepares a preimage to be read by sha256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadSha256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the minimum size (in bytes) of a large preimage proposal.
     */
    minProposalSize(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { minProposalSize_: BigNumber }>;

    /**
     * Mapping of pre-image keys to pre-image lengths.
     */
    preimageLengths(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Mapping of pre-image keys to pre-image part offsets to preimage preparedness.
     */
    preimagePartOk(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Mapping of pre-image keys to pre-image offsets to pre-image parts.
     */
    preimageParts(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Mapping of claimants to proposal UUIDs to blocks which leaves were added to the merkle tree.
     */
    proposalBlocks(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the length of the array with the block numbers of `addLeavesLPP` calls for a given large         preimage proposal.
     */
    proposalBlocksLen(
      _claimant: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { len_: BigNumber }>;

    /**
     * Mapping of claimants to proposal UUIDs to bond amounts.
     */
    proposalBonds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Mapping of claimants to proposal UUIDs to the current branch path of the merkleization process.
     */
    proposalBranches(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Returns the length of the `proposals` array
     */
    proposalCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count_: BigNumber }>;

    /**
     * Mapping of claimants to proposal UUIDs to the timestamp of creation of the proposal as well as the challenged status.
     */
    proposalMetadata(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Mapping of claimants to proposal UUIDs to the preimage part picked up during the absorbtion process.
     */
    proposalParts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Append-only array of large preimage proposals for off-chain reference.
     */
    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { claimant: string; uuid: BigNumber }>;

    /**
     * Reads a preimage from the oracle.
     * @param _key The key of the preimage to read.
     * @param _offset The offset of the preimage to read.
     */
    readPreimage(
      _key: BytesLike,
      _offset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { dat_: string; datLen_: BigNumber }>;

    squeezeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The semantic version of the Preimage Oracle contract.
     */
    version(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Static padding hashes. These values are persisted in storage, but are entirely immutable         after the constructor's execution.
     */
    zeroHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;
  };

  /**
   * The depth of the keccak256 merkle tree. Supports up to 65,536 keccak blocks, or ~8.91MB preimages.
   */
  KECCAK_TREE_DEPTH(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The maximum number of keccak blocks that can fit into the merkle tree.
   */
  MAX_LEAF_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The minimum bond size for large preimage proposals.
   */
  MIN_BOND_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The reserved gas for precompile call setup.
   */
  PRECOMPILE_CALL_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Adds a contiguous list of keccak state matrices to the merkle tree.
   */
  addLeavesLPP(
    _uuid: BigNumberish,
    _inputStartBlock: BigNumberish,
    _input: BytesLike,
    _stateCommitments: BytesLike[],
    _finalize: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  challengeFirstLPP(
    _claimant: string,
    _uuid: BigNumberish,
    _postState: PreimageOracle.LeafStruct,
    _postStateProof: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  challengeLPP(
    _claimant: string,
    _uuid: BigNumberish,
    _stateMatrix: LibKeccak.StateMatrixStruct,
    _preState: PreimageOracle.LeafStruct,
    _preStateProof: BytesLike[],
    _postState: PreimageOracle.LeafStruct,
    _postStateProof: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the length of the large preimage proposal challenge period.
   */
  challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the current merkle root of the large preimage proposal tree.
   */
  getTreeRootLPP(
    _owner: string,
    _uuid: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Initialize a large preimage proposal. Must be called before adding any leaves.
   */
  initLPP(
    _uuid: BigNumberish,
    _partOffset: BigNumberish,
    _claimedSize: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _commitment The commitment to the polynomial. 48 bytes, part of the preimage key.
   * @param _partOffset The offset of the preimage to store.
   * @param _proof The KZG proof, part of the preimage key.
   * @param _y Big endian point value. The preimage for the key.
   * @param _z Big endian point value. Part of the preimage key.
   */
  loadBlobPreimagePart(
    _z: BigNumberish,
    _y: BigNumberish,
    _commitment: BytesLike,
    _proof: BytesLike,
    _partOffset: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prepares a preimage to be read by keccak256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
   * @param _partOffset The offset of the preimage to read.
   * @param _preimage The preimage data.
   */
  loadKeccak256PreimagePart(
    _partOffset: BigNumberish,
    _preimage: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The local data parts are loaded into the preimage oracle under the context      of the caller - no other account can write to the caller's context      specific data.      There are 5 local data identifiers:      ┌────────────┬────────────────────────┐      │ Identifier │      Data              │      ├────────────┼────────────────────────┤      │          1 │ L1 Head Hash (bytes32) │      │          2 │ Output Root (bytes32)  │      │          3 │ Root Claim (bytes32)   │      │          4 │ L2 Block Number (u64)  │      │          5 │ Chain ID (u64)         │      └────────────┴────────────────────────┘
   * Loads of local data part into the preimage oracle.
   * @param _ident The identifier of the local data.
   * @param _localContext The local key context for the preimage oracle. Optionally, can be set as a constant                      if the caller only requires one set of local keys.
   * @param _partOffset The offset of the local data part to write to the oracle.
   * @param _size The number of bytes in `_word` to load.
   * @param _word The local data word.
   */
  loadLocalData(
    _ident: BigNumberish,
    _localContext: BytesLike,
    _word: BytesLike,
    _size: BigNumberish,
    _partOffset: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prepares a precompile result to be read by a precompile key for the specified offset.         The precompile result data is a concatenation of the precompile call status byte and its return data.         The preimage key is `6 ++ keccak256(precompile ++ input)[1:]`.
   * @param _input The input to the precompile call.
   * @param _partOffset The offset of the precompile result being loaded.
   * @param _precompile The precompile address
   * @param _requiredGas The gas required to fully execute an L1 precompile.
   */
  loadPrecompilePreimagePart(
    _partOffset: BigNumberish,
    _precompile: string,
    _requiredGas: BigNumberish,
    _input: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prepares a preimage to be read by sha256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
   * @param _partOffset The offset of the preimage to read.
   * @param _preimage The preimage data.
   */
  loadSha256PreimagePart(
    _partOffset: BigNumberish,
    _preimage: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the minimum size (in bytes) of a large preimage proposal.
   */
  minProposalSize(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Mapping of pre-image keys to pre-image lengths.
   */
  preimageLengths(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Mapping of pre-image keys to pre-image part offsets to preimage preparedness.
   */
  preimagePartOk(
    arg0: BytesLike,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Mapping of pre-image keys to pre-image offsets to pre-image parts.
   */
  preimageParts(
    arg0: BytesLike,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Mapping of claimants to proposal UUIDs to blocks which leaves were added to the merkle tree.
   */
  proposalBlocks(
    arg0: string,
    arg1: BigNumberish,
    arg2: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the length of the array with the block numbers of `addLeavesLPP` calls for a given large         preimage proposal.
   */
  proposalBlocksLen(
    _claimant: string,
    _uuid: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Mapping of claimants to proposal UUIDs to bond amounts.
   */
  proposalBonds(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Mapping of claimants to proposal UUIDs to the current branch path of the merkleization process.
   */
  proposalBranches(
    arg0: string,
    arg1: BigNumberish,
    arg2: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns the length of the `proposals` array
   */
  proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Mapping of claimants to proposal UUIDs to the timestamp of creation of the proposal as well as the challenged status.
   */
  proposalMetadata(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Mapping of claimants to proposal UUIDs to the preimage part picked up during the absorbtion process.
   */
  proposalParts(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Append-only array of large preimage proposals for off-chain reference.
   */
  proposals(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { claimant: string; uuid: BigNumber }>;

  /**
   * Reads a preimage from the oracle.
   * @param _key The key of the preimage to read.
   * @param _offset The offset of the preimage to read.
   */
  readPreimage(
    _key: BytesLike,
    _offset: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { dat_: string; datLen_: BigNumber }>;

  squeezeLPP(
    _claimant: string,
    _uuid: BigNumberish,
    _stateMatrix: LibKeccak.StateMatrixStruct,
    _preState: PreimageOracle.LeafStruct,
    _preStateProof: BytesLike[],
    _postState: PreimageOracle.LeafStruct,
    _postStateProof: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The semantic version of the Preimage Oracle contract.
   */
  version(overrides?: CallOverrides): Promise<string>;

  /**
   * Static padding hashes. These values are persisted in storage, but are entirely immutable         after the constructor's execution.
   */
  zeroHashes(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * The depth of the keccak256 merkle tree. Supports up to 65,536 keccak blocks, or ~8.91MB preimages.
     */
    KECCAK_TREE_DEPTH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The maximum number of keccak blocks that can fit into the merkle tree.
     */
    MAX_LEAF_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The minimum bond size for large preimage proposals.
     */
    MIN_BOND_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The reserved gas for precompile call setup.
     */
    PRECOMPILE_CALL_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Adds a contiguous list of keccak state matrices to the merkle tree.
     */
    addLeavesLPP(
      _uuid: BigNumberish,
      _inputStartBlock: BigNumberish,
      _input: BytesLike,
      _stateCommitments: BytesLike[],
      _finalize: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    challengeFirstLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    challengeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the length of the large preimage proposal challenge period.
     */
    challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current merkle root of the large preimage proposal tree.
     */
    getTreeRootLPP(
      _owner: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Initialize a large preimage proposal. Must be called before adding any leaves.
     */
    initLPP(
      _uuid: BigNumberish,
      _partOffset: BigNumberish,
      _claimedSize: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _commitment The commitment to the polynomial. 48 bytes, part of the preimage key.
     * @param _partOffset The offset of the preimage to store.
     * @param _proof The KZG proof, part of the preimage key.
     * @param _y Big endian point value. The preimage for the key.
     * @param _z Big endian point value. Part of the preimage key.
     */
    loadBlobPreimagePart(
      _z: BigNumberish,
      _y: BigNumberish,
      _commitment: BytesLike,
      _proof: BytesLike,
      _partOffset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Prepares a preimage to be read by keccak256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadKeccak256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The local data parts are loaded into the preimage oracle under the context      of the caller - no other account can write to the caller's context      specific data.      There are 5 local data identifiers:      ┌────────────┬────────────────────────┐      │ Identifier │      Data              │      ├────────────┼────────────────────────┤      │          1 │ L1 Head Hash (bytes32) │      │          2 │ Output Root (bytes32)  │      │          3 │ Root Claim (bytes32)   │      │          4 │ L2 Block Number (u64)  │      │          5 │ Chain ID (u64)         │      └────────────┴────────────────────────┘
     * Loads of local data part into the preimage oracle.
     * @param _ident The identifier of the local data.
     * @param _localContext The local key context for the preimage oracle. Optionally, can be set as a constant                      if the caller only requires one set of local keys.
     * @param _partOffset The offset of the local data part to write to the oracle.
     * @param _size The number of bytes in `_word` to load.
     * @param _word The local data word.
     */
    loadLocalData(
      _ident: BigNumberish,
      _localContext: BytesLike,
      _word: BytesLike,
      _size: BigNumberish,
      _partOffset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Prepares a precompile result to be read by a precompile key for the specified offset.         The precompile result data is a concatenation of the precompile call status byte and its return data.         The preimage key is `6 ++ keccak256(precompile ++ input)[1:]`.
     * @param _input The input to the precompile call.
     * @param _partOffset The offset of the precompile result being loaded.
     * @param _precompile The precompile address
     * @param _requiredGas The gas required to fully execute an L1 precompile.
     */
    loadPrecompilePreimagePart(
      _partOffset: BigNumberish,
      _precompile: string,
      _requiredGas: BigNumberish,
      _input: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Prepares a preimage to be read by sha256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadSha256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the minimum size (in bytes) of a large preimage proposal.
     */
    minProposalSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Mapping of pre-image keys to pre-image lengths.
     */
    preimageLengths(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of pre-image keys to pre-image part offsets to preimage preparedness.
     */
    preimagePartOk(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Mapping of pre-image keys to pre-image offsets to pre-image parts.
     */
    preimageParts(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Mapping of claimants to proposal UUIDs to blocks which leaves were added to the merkle tree.
     */
    proposalBlocks(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the length of the array with the block numbers of `addLeavesLPP` calls for a given large         preimage proposal.
     */
    proposalBlocksLen(
      _claimant: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to bond amounts.
     */
    proposalBonds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to the current branch path of the merkleization process.
     */
    proposalBranches(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the length of the `proposals` array
     */
    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to the timestamp of creation of the proposal as well as the challenged status.
     */
    proposalMetadata(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Mapping of claimants to proposal UUIDs to the preimage part picked up during the absorbtion process.
     */
    proposalParts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Append-only array of large preimage proposals for off-chain reference.
     */
    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { claimant: string; uuid: BigNumber }>;

    /**
     * Reads a preimage from the oracle.
     * @param _key The key of the preimage to read.
     * @param _offset The offset of the preimage to read.
     */
    readPreimage(
      _key: BytesLike,
      _offset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { dat_: string; datLen_: BigNumber }>;

    squeezeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The semantic version of the Preimage Oracle contract.
     */
    version(overrides?: CallOverrides): Promise<string>;

    /**
     * Static padding hashes. These values are persisted in storage, but are entirely immutable         after the constructor's execution.
     */
    zeroHashes(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
  };

  filters: {};

  estimateGas: {
    /**
     * The depth of the keccak256 merkle tree. Supports up to 65,536 keccak blocks, or ~8.91MB preimages.
     */
    KECCAK_TREE_DEPTH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The maximum number of keccak blocks that can fit into the merkle tree.
     */
    MAX_LEAF_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The minimum bond size for large preimage proposals.
     */
    MIN_BOND_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The reserved gas for precompile call setup.
     */
    PRECOMPILE_CALL_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Adds a contiguous list of keccak state matrices to the merkle tree.
     */
    addLeavesLPP(
      _uuid: BigNumberish,
      _inputStartBlock: BigNumberish,
      _input: BytesLike,
      _stateCommitments: BytesLike[],
      _finalize: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    challengeFirstLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    challengeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the length of the large preimage proposal challenge period.
     */
    challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current merkle root of the large preimage proposal tree.
     */
    getTreeRootLPP(
      _owner: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initialize a large preimage proposal. Must be called before adding any leaves.
     */
    initLPP(
      _uuid: BigNumberish,
      _partOffset: BigNumberish,
      _claimedSize: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _commitment The commitment to the polynomial. 48 bytes, part of the preimage key.
     * @param _partOffset The offset of the preimage to store.
     * @param _proof The KZG proof, part of the preimage key.
     * @param _y Big endian point value. The preimage for the key.
     * @param _z Big endian point value. Part of the preimage key.
     */
    loadBlobPreimagePart(
      _z: BigNumberish,
      _y: BigNumberish,
      _commitment: BytesLike,
      _proof: BytesLike,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prepares a preimage to be read by keccak256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadKeccak256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The local data parts are loaded into the preimage oracle under the context      of the caller - no other account can write to the caller's context      specific data.      There are 5 local data identifiers:      ┌────────────┬────────────────────────┐      │ Identifier │      Data              │      ├────────────┼────────────────────────┤      │          1 │ L1 Head Hash (bytes32) │      │          2 │ Output Root (bytes32)  │      │          3 │ Root Claim (bytes32)   │      │          4 │ L2 Block Number (u64)  │      │          5 │ Chain ID (u64)         │      └────────────┴────────────────────────┘
     * Loads of local data part into the preimage oracle.
     * @param _ident The identifier of the local data.
     * @param _localContext The local key context for the preimage oracle. Optionally, can be set as a constant                      if the caller only requires one set of local keys.
     * @param _partOffset The offset of the local data part to write to the oracle.
     * @param _size The number of bytes in `_word` to load.
     * @param _word The local data word.
     */
    loadLocalData(
      _ident: BigNumberish,
      _localContext: BytesLike,
      _word: BytesLike,
      _size: BigNumberish,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prepares a precompile result to be read by a precompile key for the specified offset.         The precompile result data is a concatenation of the precompile call status byte and its return data.         The preimage key is `6 ++ keccak256(precompile ++ input)[1:]`.
     * @param _input The input to the precompile call.
     * @param _partOffset The offset of the precompile result being loaded.
     * @param _precompile The precompile address
     * @param _requiredGas The gas required to fully execute an L1 precompile.
     */
    loadPrecompilePreimagePart(
      _partOffset: BigNumberish,
      _precompile: string,
      _requiredGas: BigNumberish,
      _input: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prepares a preimage to be read by sha256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadSha256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the minimum size (in bytes) of a large preimage proposal.
     */
    minProposalSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Mapping of pre-image keys to pre-image lengths.
     */
    preimageLengths(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of pre-image keys to pre-image part offsets to preimage preparedness.
     */
    preimagePartOk(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of pre-image keys to pre-image offsets to pre-image parts.
     */
    preimageParts(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to blocks which leaves were added to the merkle tree.
     */
    proposalBlocks(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the length of the array with the block numbers of `addLeavesLPP` calls for a given large         preimage proposal.
     */
    proposalBlocksLen(
      _claimant: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to bond amounts.
     */
    proposalBonds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to the current branch path of the merkleization process.
     */
    proposalBranches(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the length of the `proposals` array
     */
    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to the timestamp of creation of the proposal as well as the challenged status.
     */
    proposalMetadata(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of claimants to proposal UUIDs to the preimage part picked up during the absorbtion process.
     */
    proposalParts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Append-only array of large preimage proposals for off-chain reference.
     */
    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads a preimage from the oracle.
     * @param _key The key of the preimage to read.
     * @param _offset The offset of the preimage to read.
     */
    readPreimage(
      _key: BytesLike,
      _offset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    squeezeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The semantic version of the Preimage Oracle contract.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Static padding hashes. These values are persisted in storage, but are entirely immutable         after the constructor's execution.
     */
    zeroHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The depth of the keccak256 merkle tree. Supports up to 65,536 keccak blocks, or ~8.91MB preimages.
     */
    KECCAK_TREE_DEPTH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The maximum number of keccak blocks that can fit into the merkle tree.
     */
    MAX_LEAF_COUNT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The minimum bond size for large preimage proposals.
     */
    MIN_BOND_SIZE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The reserved gas for precompile call setup.
     */
    PRECOMPILE_CALL_RESERVED_GAS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Adds a contiguous list of keccak state matrices to the merkle tree.
     */
    addLeavesLPP(
      _uuid: BigNumberish,
      _inputStartBlock: BigNumberish,
      _input: BytesLike,
      _stateCommitments: BytesLike[],
      _finalize: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    challengeFirstLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    challengeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the length of the large preimage proposal challenge period.
     */
    challengePeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the current merkle root of the large preimage proposal tree.
     */
    getTreeRootLPP(
      _owner: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initialize a large preimage proposal. Must be called before adding any leaves.
     */
    initLPP(
      _uuid: BigNumberish,
      _partOffset: BigNumberish,
      _claimedSize: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _commitment The commitment to the polynomial. 48 bytes, part of the preimage key.
     * @param _partOffset The offset of the preimage to store.
     * @param _proof The KZG proof, part of the preimage key.
     * @param _y Big endian point value. The preimage for the key.
     * @param _z Big endian point value. Part of the preimage key.
     */
    loadBlobPreimagePart(
      _z: BigNumberish,
      _y: BigNumberish,
      _commitment: BytesLike,
      _proof: BytesLike,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prepares a preimage to be read by keccak256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadKeccak256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The local data parts are loaded into the preimage oracle under the context      of the caller - no other account can write to the caller's context      specific data.      There are 5 local data identifiers:      ┌────────────┬────────────────────────┐      │ Identifier │      Data              │      ├────────────┼────────────────────────┤      │          1 │ L1 Head Hash (bytes32) │      │          2 │ Output Root (bytes32)  │      │          3 │ Root Claim (bytes32)   │      │          4 │ L2 Block Number (u64)  │      │          5 │ Chain ID (u64)         │      └────────────┴────────────────────────┘
     * Loads of local data part into the preimage oracle.
     * @param _ident The identifier of the local data.
     * @param _localContext The local key context for the preimage oracle. Optionally, can be set as a constant                      if the caller only requires one set of local keys.
     * @param _partOffset The offset of the local data part to write to the oracle.
     * @param _size The number of bytes in `_word` to load.
     * @param _word The local data word.
     */
    loadLocalData(
      _ident: BigNumberish,
      _localContext: BytesLike,
      _word: BytesLike,
      _size: BigNumberish,
      _partOffset: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prepares a precompile result to be read by a precompile key for the specified offset.         The precompile result data is a concatenation of the precompile call status byte and its return data.         The preimage key is `6 ++ keccak256(precompile ++ input)[1:]`.
     * @param _input The input to the precompile call.
     * @param _partOffset The offset of the precompile result being loaded.
     * @param _precompile The precompile address
     * @param _requiredGas The gas required to fully execute an L1 precompile.
     */
    loadPrecompilePreimagePart(
      _partOffset: BigNumberish,
      _precompile: string,
      _requiredGas: BigNumberish,
      _input: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prepares a preimage to be read by sha256 key, starting at the given offset and up to 32 bytes         (clipped at preimage length, if out of data).
     * @param _partOffset The offset of the preimage to read.
     * @param _preimage The preimage data.
     */
    loadSha256PreimagePart(
      _partOffset: BigNumberish,
      _preimage: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the minimum size (in bytes) of a large preimage proposal.
     */
    minProposalSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Mapping of pre-image keys to pre-image lengths.
     */
    preimageLengths(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of pre-image keys to pre-image part offsets to preimage preparedness.
     */
    preimagePartOk(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of pre-image keys to pre-image offsets to pre-image parts.
     */
    preimageParts(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of claimants to proposal UUIDs to blocks which leaves were added to the merkle tree.
     */
    proposalBlocks(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the length of the array with the block numbers of `addLeavesLPP` calls for a given large         preimage proposal.
     */
    proposalBlocksLen(
      _claimant: string,
      _uuid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of claimants to proposal UUIDs to bond amounts.
     */
    proposalBonds(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of claimants to proposal UUIDs to the current branch path of the merkleization process.
     */
    proposalBranches(
      arg0: string,
      arg1: BigNumberish,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the length of the `proposals` array
     */
    proposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Mapping of claimants to proposal UUIDs to the timestamp of creation of the proposal as well as the challenged status.
     */
    proposalMetadata(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of claimants to proposal UUIDs to the preimage part picked up during the absorbtion process.
     */
    proposalParts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Append-only array of large preimage proposals for off-chain reference.
     */
    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads a preimage from the oracle.
     * @param _key The key of the preimage to read.
     * @param _offset The offset of the preimage to read.
     */
    readPreimage(
      _key: BytesLike,
      _offset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    squeezeLPP(
      _claimant: string,
      _uuid: BigNumberish,
      _stateMatrix: LibKeccak.StateMatrixStruct,
      _preState: PreimageOracle.LeafStruct,
      _preStateProof: BytesLike[],
      _postState: PreimageOracle.LeafStruct,
      _postStateProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The semantic version of the Preimage Oracle contract.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Static padding hashes. These values are persisted in storage, but are entirely immutable         after the constructor's execution.
     */
    zeroHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
