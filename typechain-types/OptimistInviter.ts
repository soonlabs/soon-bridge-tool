/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace OptimistInviter {
  export type ClaimableInviteStruct = { issuer: string; nonce: BytesLike };

  export type ClaimableInviteStructOutput = [string, string] & {
    issuer: string;
    nonce: string;
  };
}

export interface OptimistInviterInterface extends utils.Interface {
  functions: {
    "ATTESTATION_STATION()": FunctionFragment;
    "CAN_INVITE_ATTESTATION_KEY()": FunctionFragment;
    "CLAIMABLE_INVITE_TYPEHASH()": FunctionFragment;
    "EIP712_VERSION()": FunctionFragment;
    "INVITE_GRANTER()": FunctionFragment;
    "MIN_COMMITMENT_PERIOD()": FunctionFragment;
    "claimInvite(address,(address,bytes32),bytes)": FunctionFragment;
    "commitInvite(bytes32)": FunctionFragment;
    "commitmentTimestamps(bytes32)": FunctionFragment;
    "initialize(string)": FunctionFragment;
    "inviteCounts(address)": FunctionFragment;
    "setInviteCounts(address[],uint256)": FunctionFragment;
    "usedNonces(address,bytes32)": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ATTESTATION_STATION"
      | "CAN_INVITE_ATTESTATION_KEY"
      | "CLAIMABLE_INVITE_TYPEHASH"
      | "EIP712_VERSION"
      | "INVITE_GRANTER"
      | "MIN_COMMITMENT_PERIOD"
      | "claimInvite"
      | "commitInvite"
      | "commitmentTimestamps"
      | "initialize"
      | "inviteCounts"
      | "setInviteCounts"
      | "usedNonces"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "ATTESTATION_STATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "CAN_INVITE_ATTESTATION_KEY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "CLAIMABLE_INVITE_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "EIP712_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "INVITE_GRANTER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_COMMITMENT_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimInvite",
    values: [string, OptimistInviter.ClaimableInviteStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "commitInvite",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "commitmentTimestamps",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "initialize", values: [string]): string;
  encodeFunctionData(
    functionFragment: "inviteCounts",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setInviteCounts",
    values: [string[], BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "usedNonces",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "ATTESTATION_STATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "CAN_INVITE_ATTESTATION_KEY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "CLAIMABLE_INVITE_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "EIP712_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "INVITE_GRANTER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_COMMITMENT_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimInvite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "commitInvite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "commitmentTimestamps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "inviteCounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setInviteCounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "usedNonces", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "InviteClaimed(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InviteClaimed"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface InviteClaimedEventObject {
  issuer: string;
  claimer: string;
}
export type InviteClaimedEvent = TypedEvent<
  [string, string],
  InviteClaimedEventObject
>;

export type InviteClaimedEventFilter = TypedEventFilter<InviteClaimedEvent>;

export interface OptimistInviter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OptimistInviterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Address of the AttestationStation contract.
     */
    ATTESTATION_STATION(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Attestation key for that signals that an account was allowed to issue invites
     */
    CAN_INVITE_ATTESTATION_KEY(overrides?: CallOverrides): Promise<[string]>;

    /**
     * EIP712 typehash for the ClaimableInvite type.
     */
    CLAIMABLE_INVITE_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Version used for the EIP712 domain separator. This version is separated from the         contract semver because the EIP712 domain separator is used to sign messages, and         changing the domain separator invalidates all existing signatures. We should only         bump this version if we make a major change to the signature scheme.
     */
    EIP712_VERSION(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Granter who can set accounts' invite counts.
     */
    INVITE_GRANTER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Minimum age of a commitment (in seconds) before it can be revealed using         claimInvite. Currently set to 60 seconds.        Prevents an attacker from front-running a commitment by taking the signature in the        claimInvite call and quickly committing and claiming it before the the claimer's        transaction succeeds. With this, frontrunning a commitment requires that an attacker        be able to prevent the honest claimer's claimInvite transaction from being included        for this long.
     */
    MIN_COMMITMENT_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    claimInvite(
      _claimer: string,
      _claimableInvite: OptimistInviter.ClaimableInviteStruct,
      _signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Allows anyone (but likely the claimer) to commit a received signature along with the         address to claim to.         Before calling this function, the claimer should have received a signature from the          issuer off-chain. The claimer then calls this function with the hash of the         claimer's address and the received signature. This is necessary to prevent         front-running when the invitee is claiming the invite. Without a commit and reveal         scheme, anyone who is watching the mempool can take the signature being submitted         and front run the transaction to claim the invite to their own address.         The same commitment can only be made once, and the function reverts if the         commitment has already been made. This prevents griefing where a malicious party can         prevent the original claimer from being able to claimInvite.
     * @param _commitment A hash of the claimer and signature concatenated.                    keccak256(abi.encode(_claimer, _signature))
     */
    commitInvite(
      _commitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Maps from hashes to the timestamp when they were committed.
     */
    commitmentTimestamps(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Initializes this contract, setting the EIP712 context.         Only update the EIP712_VERSION when there is a change to the signature scheme.         After the EIP712 version is changed, any signatures issued off-chain but not         claimed yet will no longer be accepted by the claimInvite function. Please make         sure to notify the issuers that they must re-issue their invite signatures.
     * @param _name Contract name.
     */
    initialize(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Maps from addresses to number of invites they have.
     */
    inviteCounts(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Allows invite granter to set the number of invites an address has.
     * @param _accounts An array of accounts to update the invite counts of.
     * @param _inviteCount Number of invites to set to.
     */
    setInviteCounts(
      _accounts: string[],
      _inviteCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Maps from addresses to nonces to whether or not they have been used.
     */
    usedNonces(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Address of the AttestationStation contract.
   */
  ATTESTATION_STATION(overrides?: CallOverrides): Promise<string>;

  /**
   * Attestation key for that signals that an account was allowed to issue invites
   */
  CAN_INVITE_ATTESTATION_KEY(overrides?: CallOverrides): Promise<string>;

  /**
   * EIP712 typehash for the ClaimableInvite type.
   */
  CLAIMABLE_INVITE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  /**
   * Version used for the EIP712 domain separator. This version is separated from the         contract semver because the EIP712 domain separator is used to sign messages, and         changing the domain separator invalidates all existing signatures. We should only         bump this version if we make a major change to the signature scheme.
   */
  EIP712_VERSION(overrides?: CallOverrides): Promise<string>;

  /**
   * Granter who can set accounts' invite counts.
   */
  INVITE_GRANTER(overrides?: CallOverrides): Promise<string>;

  /**
   * Minimum age of a commitment (in seconds) before it can be revealed using         claimInvite. Currently set to 60 seconds.        Prevents an attacker from front-running a commitment by taking the signature in the        claimInvite call and quickly committing and claiming it before the the claimer's        transaction succeeds. With this, frontrunning a commitment requires that an attacker        be able to prevent the honest claimer's claimInvite transaction from being included        for this long.
   */
  MIN_COMMITMENT_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  claimInvite(
    _claimer: string,
    _claimableInvite: OptimistInviter.ClaimableInviteStruct,
    _signature: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Allows anyone (but likely the claimer) to commit a received signature along with the         address to claim to.         Before calling this function, the claimer should have received a signature from the          issuer off-chain. The claimer then calls this function with the hash of the         claimer's address and the received signature. This is necessary to prevent         front-running when the invitee is claiming the invite. Without a commit and reveal         scheme, anyone who is watching the mempool can take the signature being submitted         and front run the transaction to claim the invite to their own address.         The same commitment can only be made once, and the function reverts if the         commitment has already been made. This prevents griefing where a malicious party can         prevent the original claimer from being able to claimInvite.
   * @param _commitment A hash of the claimer and signature concatenated.                    keccak256(abi.encode(_claimer, _signature))
   */
  commitInvite(
    _commitment: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Maps from hashes to the timestamp when they were committed.
   */
  commitmentTimestamps(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Initializes this contract, setting the EIP712 context.         Only update the EIP712_VERSION when there is a change to the signature scheme.         After the EIP712 version is changed, any signatures issued off-chain but not         claimed yet will no longer be accepted by the claimInvite function. Please make         sure to notify the issuers that they must re-issue their invite signatures.
   * @param _name Contract name.
   */
  initialize(
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Maps from addresses to number of invites they have.
   */
  inviteCounts(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Allows invite granter to set the number of invites an address has.
   * @param _accounts An array of accounts to update the invite counts of.
   * @param _inviteCount Number of invites to set to.
   */
  setInviteCounts(
    _accounts: string[],
    _inviteCount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Maps from addresses to nonces to whether or not they have been used.
   */
  usedNonces(
    arg0: string,
    arg1: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Address of the AttestationStation contract.
     */
    ATTESTATION_STATION(overrides?: CallOverrides): Promise<string>;

    /**
     * Attestation key for that signals that an account was allowed to issue invites
     */
    CAN_INVITE_ATTESTATION_KEY(overrides?: CallOverrides): Promise<string>;

    /**
     * EIP712 typehash for the ClaimableInvite type.
     */
    CLAIMABLE_INVITE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    /**
     * Version used for the EIP712 domain separator. This version is separated from the         contract semver because the EIP712 domain separator is used to sign messages, and         changing the domain separator invalidates all existing signatures. We should only         bump this version if we make a major change to the signature scheme.
     */
    EIP712_VERSION(overrides?: CallOverrides): Promise<string>;

    /**
     * Granter who can set accounts' invite counts.
     */
    INVITE_GRANTER(overrides?: CallOverrides): Promise<string>;

    /**
     * Minimum age of a commitment (in seconds) before it can be revealed using         claimInvite. Currently set to 60 seconds.        Prevents an attacker from front-running a commitment by taking the signature in the        claimInvite call and quickly committing and claiming it before the the claimer's        transaction succeeds. With this, frontrunning a commitment requires that an attacker        be able to prevent the honest claimer's claimInvite transaction from being included        for this long.
     */
    MIN_COMMITMENT_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    claimInvite(
      _claimer: string,
      _claimableInvite: OptimistInviter.ClaimableInviteStruct,
      _signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Allows anyone (but likely the claimer) to commit a received signature along with the         address to claim to.         Before calling this function, the claimer should have received a signature from the          issuer off-chain. The claimer then calls this function with the hash of the         claimer's address and the received signature. This is necessary to prevent         front-running when the invitee is claiming the invite. Without a commit and reveal         scheme, anyone who is watching the mempool can take the signature being submitted         and front run the transaction to claim the invite to their own address.         The same commitment can only be made once, and the function reverts if the         commitment has already been made. This prevents griefing where a malicious party can         prevent the original claimer from being able to claimInvite.
     * @param _commitment A hash of the claimer and signature concatenated.                    keccak256(abi.encode(_claimer, _signature))
     */
    commitInvite(
      _commitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Maps from hashes to the timestamp when they were committed.
     */
    commitmentTimestamps(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes this contract, setting the EIP712 context.         Only update the EIP712_VERSION when there is a change to the signature scheme.         After the EIP712 version is changed, any signatures issued off-chain but not         claimed yet will no longer be accepted by the claimInvite function. Please make         sure to notify the issuers that they must re-issue their invite signatures.
     * @param _name Contract name.
     */
    initialize(_name: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Maps from addresses to number of invites they have.
     */
    inviteCounts(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Allows invite granter to set the number of invites an address has.
     * @param _accounts An array of accounts to update the invite counts of.
     * @param _inviteCount Number of invites to set to.
     */
    setInviteCounts(
      _accounts: string[],
      _inviteCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Maps from addresses to nonces to whether or not they have been used.
     */
    usedNonces(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "InviteClaimed(address,address)"(
      issuer?: string | null,
      claimer?: string | null
    ): InviteClaimedEventFilter;
    InviteClaimed(
      issuer?: string | null,
      claimer?: string | null
    ): InviteClaimedEventFilter;
  };

  estimateGas: {
    /**
     * Address of the AttestationStation contract.
     */
    ATTESTATION_STATION(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Attestation key for that signals that an account was allowed to issue invites
     */
    CAN_INVITE_ATTESTATION_KEY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * EIP712 typehash for the ClaimableInvite type.
     */
    CLAIMABLE_INVITE_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Version used for the EIP712 domain separator. This version is separated from the         contract semver because the EIP712 domain separator is used to sign messages, and         changing the domain separator invalidates all existing signatures. We should only         bump this version if we make a major change to the signature scheme.
     */
    EIP712_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Granter who can set accounts' invite counts.
     */
    INVITE_GRANTER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Minimum age of a commitment (in seconds) before it can be revealed using         claimInvite. Currently set to 60 seconds.        Prevents an attacker from front-running a commitment by taking the signature in the        claimInvite call and quickly committing and claiming it before the the claimer's        transaction succeeds. With this, frontrunning a commitment requires that an attacker        be able to prevent the honest claimer's claimInvite transaction from being included        for this long.
     */
    MIN_COMMITMENT_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    claimInvite(
      _claimer: string,
      _claimableInvite: OptimistInviter.ClaimableInviteStruct,
      _signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Allows anyone (but likely the claimer) to commit a received signature along with the         address to claim to.         Before calling this function, the claimer should have received a signature from the          issuer off-chain. The claimer then calls this function with the hash of the         claimer's address and the received signature. This is necessary to prevent         front-running when the invitee is claiming the invite. Without a commit and reveal         scheme, anyone who is watching the mempool can take the signature being submitted         and front run the transaction to claim the invite to their own address.         The same commitment can only be made once, and the function reverts if the         commitment has already been made. This prevents griefing where a malicious party can         prevent the original claimer from being able to claimInvite.
     * @param _commitment A hash of the claimer and signature concatenated.                    keccak256(abi.encode(_claimer, _signature))
     */
    commitInvite(
      _commitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Maps from hashes to the timestamp when they were committed.
     */
    commitmentTimestamps(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes this contract, setting the EIP712 context.         Only update the EIP712_VERSION when there is a change to the signature scheme.         After the EIP712 version is changed, any signatures issued off-chain but not         claimed yet will no longer be accepted by the claimInvite function. Please make         sure to notify the issuers that they must re-issue their invite signatures.
     * @param _name Contract name.
     */
    initialize(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Maps from addresses to number of invites they have.
     */
    inviteCounts(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Allows invite granter to set the number of invites an address has.
     * @param _accounts An array of accounts to update the invite counts of.
     * @param _inviteCount Number of invites to set to.
     */
    setInviteCounts(
      _accounts: string[],
      _inviteCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Maps from addresses to nonces to whether or not they have been used.
     */
    usedNonces(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Address of the AttestationStation contract.
     */
    ATTESTATION_STATION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Attestation key for that signals that an account was allowed to issue invites
     */
    CAN_INVITE_ATTESTATION_KEY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * EIP712 typehash for the ClaimableInvite type.
     */
    CLAIMABLE_INVITE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Version used for the EIP712 domain separator. This version is separated from the         contract semver because the EIP712 domain separator is used to sign messages, and         changing the domain separator invalidates all existing signatures. We should only         bump this version if we make a major change to the signature scheme.
     */
    EIP712_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Granter who can set accounts' invite counts.
     */
    INVITE_GRANTER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Minimum age of a commitment (in seconds) before it can be revealed using         claimInvite. Currently set to 60 seconds.        Prevents an attacker from front-running a commitment by taking the signature in the        claimInvite call and quickly committing and claiming it before the the claimer's        transaction succeeds. With this, frontrunning a commitment requires that an attacker        be able to prevent the honest claimer's claimInvite transaction from being included        for this long.
     */
    MIN_COMMITMENT_PERIOD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimInvite(
      _claimer: string,
      _claimableInvite: OptimistInviter.ClaimableInviteStruct,
      _signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Allows anyone (but likely the claimer) to commit a received signature along with the         address to claim to.         Before calling this function, the claimer should have received a signature from the          issuer off-chain. The claimer then calls this function with the hash of the         claimer's address and the received signature. This is necessary to prevent         front-running when the invitee is claiming the invite. Without a commit and reveal         scheme, anyone who is watching the mempool can take the signature being submitted         and front run the transaction to claim the invite to their own address.         The same commitment can only be made once, and the function reverts if the         commitment has already been made. This prevents griefing where a malicious party can         prevent the original claimer from being able to claimInvite.
     * @param _commitment A hash of the claimer and signature concatenated.                    keccak256(abi.encode(_claimer, _signature))
     */
    commitInvite(
      _commitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Maps from hashes to the timestamp when they were committed.
     */
    commitmentTimestamps(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initializes this contract, setting the EIP712 context.         Only update the EIP712_VERSION when there is a change to the signature scheme.         After the EIP712 version is changed, any signatures issued off-chain but not         claimed yet will no longer be accepted by the claimInvite function. Please make         sure to notify the issuers that they must re-issue their invite signatures.
     * @param _name Contract name.
     */
    initialize(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Maps from addresses to number of invites they have.
     */
    inviteCounts(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Allows invite granter to set the number of invites an address has.
     * @param _accounts An array of accounts to update the invite counts of.
     * @param _inviteCount Number of invites to set to.
     */
    setInviteCounts(
      _accounts: string[],
      _inviteCount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Maps from addresses to nonces to whether or not they have been used.
     */
    usedNonces(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
