/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface ERC721BridgeInterface extends utils.Interface {
  functions: {
    "MESSENGER()": FunctionFragment;
    "OTHER_BRIDGE()": FunctionFragment;
    "bridgeERC721(address,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "bridgeERC721To(address,bytes32,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "messenger()": FunctionFragment;
    "otherBridge()": FunctionFragment;
    "paused()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MESSENGER"
      | "OTHER_BRIDGE"
      | "bridgeERC721"
      | "bridgeERC721To"
      | "messenger"
      | "otherBridge"
      | "paused"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "MESSENGER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "OTHER_BRIDGE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC721",
    values: [string, BytesLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC721To",
    values: [
      string,
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "messenger", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "otherBridge",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;

  decodeFunctionResult(functionFragment: "MESSENGER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "OTHER_BRIDGE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC721To",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "messenger", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "otherBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;

  events: {
    "ERC721BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ERC721BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "Initialized(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ERC721BridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC721BridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}

export interface ERC721BridgeFinalizedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  tokenId: BigNumber;
  extraData: string;
}
export type ERC721BridgeFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC721BridgeFinalizedEventObject
>;

export type ERC721BridgeFinalizedEventFilter =
  TypedEventFilter<ERC721BridgeFinalizedEvent>;

export interface ERC721BridgeInitiatedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  tokenId: BigNumber;
  extraData: string;
}
export type ERC721BridgeInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC721BridgeInitiatedEventObject
>;

export type ERC721BridgeInitiatedEventFilter =
  TypedEventFilter<ERC721BridgeInitiatedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface ERC721Bridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ERC721BridgeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<[boolean]>;
  };

  /**
   * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
   */
  MESSENGER(overrides?: CallOverrides): Promise<string>;

  /**
   * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
   */
  OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

  /**
   * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
   */
  bridgeERC721(
    arg0: string,
    arg1: BytesLike,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
   * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
   * @param _localToken Address of the ERC721 on this domain.
   * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
   * @param _remoteToken Address of the ERC721 on the remote domain.
   * @param _to Address to receive the token on the other domain.
   * @param _tokenId Token ID to bridge.
   */
  bridgeERC721To(
    _localToken: string,
    _remoteToken: BytesLike,
    _to: BytesLike,
    _tokenId: BigNumberish,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Messenger contract on this domain.
   */
  messenger(overrides?: CallOverrides): Promise<string>;

  /**
   * Contract of the bridge on the other network.
   */
  otherBridge(overrides?: CallOverrides): Promise<string>;

  /**
   * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<string>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<string>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<string>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    "ERC721BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeFinalizedEventFilter;
    ERC721BridgeFinalized(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeFinalizedEventFilter;

    "ERC721BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeInitiatedEventFilter;
    ERC721BridgeInitiated(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeInitiatedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;
  };

  estimateGas: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
