/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export interface ProxyAdminInterface extends utils.Interface {
  functions: {
    "addressManager()": FunctionFragment;
    "changeProxyAdmin(address,address)": FunctionFragment;
    "getProxyAdmin(address)": FunctionFragment;
    "getProxyImplementation(address)": FunctionFragment;
    "implementationName(address)": FunctionFragment;
    "isUpgrading()": FunctionFragment;
    "owner()": FunctionFragment;
    "proxyType(address)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setAddress(string,address)": FunctionFragment;
    "setAddressManager(address)": FunctionFragment;
    "setImplementationName(address,string)": FunctionFragment;
    "setProxyType(address,uint8)": FunctionFragment;
    "setUpgrading(bool)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "upgrade(address,address)": FunctionFragment;
    "upgradeAndCall(address,address,bytes)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addressManager"
      | "changeProxyAdmin"
      | "getProxyAdmin"
      | "getProxyImplementation"
      | "implementationName"
      | "isUpgrading"
      | "owner"
      | "proxyType"
      | "renounceOwnership"
      | "setAddress"
      | "setAddressManager"
      | "setImplementationName"
      | "setProxyType"
      | "setUpgrading"
      | "transferOwnership"
      | "upgrade"
      | "upgradeAndCall"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addressManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "changeProxyAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getProxyAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getProxyImplementation",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "implementationName",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isUpgrading",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "proxyType", values: [string]): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAddressManager",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setImplementationName",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setProxyType",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setUpgrading",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "upgrade",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeAndCall",
    values: [string, string, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "addressManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProxyAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProxyAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProxyImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "implementationName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUpgrading",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proxyType", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setAddress", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAddressManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setImplementationName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setProxyType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUpgrading",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeAndCall",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ProxyAdmin extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ProxyAdminInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The address of the address manager, this is required to manage the         ResolvedDelegateProxy type.
     */
    addressManager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Updates the admin of the given proxy address.
     * @param _newAdmin Address of the new proxy admin.
     * @param _proxy Address of the proxy to update.
     */
    changeProxyAdmin(
      _proxy: string,
      _newAdmin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the admin of the given proxy address.
     * @param _proxy Address of the proxy to get the admin of.
     */
    getProxyAdmin(_proxy: string, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the implementation of the given proxy address.
     * @param _proxy Address of the proxy to get the implementation of.
     */
    getProxyImplementation(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * A reverse mapping of addresses to names held in the AddressManager. This must be         manually kept up to date with changes in the AddressManager for this contract         to be able to work as an admin for the ResolvedDelegateProxy type.
     */
    implementationName(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     */
    isUpgrading(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * A mapping of proxy types, used for backwards compatibility.
     */
    proxyType(arg0: string, overrides?: CallOverrides): Promise<[number]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _address Address to attach to the given name.
     * @param _name Name to set within the AddressManager.
     */
    setAddress(
      _name: string,
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Set the address of the AddressManager. This is required to manage legacy         ResolvedDelegateProxy type proxy contracts.
     * @param _address Address of the AddressManager.
     */
    setAddressManager(
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the implementation name for a given address. Only required for         ResolvedDelegateProxy type proxies that have an implementation name.
     * @param _address Address of the ResolvedDelegateProxy.
     * @param _name Name of the implementation for the proxy.
     */
    setImplementationName(
      _address: string,
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the proxy type for a given address. Only required for non-standard (legacy)         proxy types.
     * @param _address Address of the proxy.
     * @param _type Type of the proxy.
     */
    setProxyType(
      _address: string,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _upgrading Whether or not the system is upgrading.
     */
    setUpgrading(
      _upgrading: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Changes a proxy's implementation contract.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgrade(
      _proxy: string,
      _implementation: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Changes a proxy's implementation contract and delegatecalls the new implementation         with some given data. Useful for atomic upgrade-and-initialize calls.
     * @param _data Data to trigger the new implementation with.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgradeAndCall(
      _proxy: string,
      _implementation: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * The address of the address manager, this is required to manage the         ResolvedDelegateProxy type.
   */
  addressManager(overrides?: CallOverrides): Promise<string>;

  /**
   * Updates the admin of the given proxy address.
   * @param _newAdmin Address of the new proxy admin.
   * @param _proxy Address of the proxy to update.
   */
  changeProxyAdmin(
    _proxy: string,
    _newAdmin: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the admin of the given proxy address.
   * @param _proxy Address of the proxy to get the admin of.
   */
  getProxyAdmin(_proxy: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the implementation of the given proxy address.
   * @param _proxy Address of the proxy to get the implementation of.
   */
  getProxyImplementation(
    _proxy: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * A reverse mapping of addresses to names held in the AddressManager. This must be         manually kept up to date with changes in the AddressManager for this contract         to be able to work as an admin for the ResolvedDelegateProxy type.
   */
  implementationName(arg0: string, overrides?: CallOverrides): Promise<string>;

  /**
   */
  isUpgrading(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * A mapping of proxy types, used for backwards compatibility.
   */
  proxyType(arg0: string, overrides?: CallOverrides): Promise<number>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _address Address to attach to the given name.
   * @param _name Name to set within the AddressManager.
   */
  setAddress(
    _name: string,
    _address: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Set the address of the AddressManager. This is required to manage legacy         ResolvedDelegateProxy type proxy contracts.
   * @param _address Address of the AddressManager.
   */
  setAddressManager(
    _address: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the implementation name for a given address. Only required for         ResolvedDelegateProxy type proxies that have an implementation name.
   * @param _address Address of the ResolvedDelegateProxy.
   * @param _name Name of the implementation for the proxy.
   */
  setImplementationName(
    _address: string,
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the proxy type for a given address. Only required for non-standard (legacy)         proxy types.
   * @param _address Address of the proxy.
   * @param _type Type of the proxy.
   */
  setProxyType(
    _address: string,
    _type: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _upgrading Whether or not the system is upgrading.
   */
  setUpgrading(
    _upgrading: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Changes a proxy's implementation contract.
   * @param _implementation Address of the new implementation address.
   * @param _proxy Address of the proxy to upgrade.
   */
  upgrade(
    _proxy: string,
    _implementation: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Changes a proxy's implementation contract and delegatecalls the new implementation         with some given data. Useful for atomic upgrade-and-initialize calls.
   * @param _data Data to trigger the new implementation with.
   * @param _implementation Address of the new implementation address.
   * @param _proxy Address of the proxy to upgrade.
   */
  upgradeAndCall(
    _proxy: string,
    _implementation: string,
    _data: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * The address of the address manager, this is required to manage the         ResolvedDelegateProxy type.
     */
    addressManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Updates the admin of the given proxy address.
     * @param _newAdmin Address of the new proxy admin.
     * @param _proxy Address of the proxy to update.
     */
    changeProxyAdmin(
      _proxy: string,
      _newAdmin: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the admin of the given proxy address.
     * @param _proxy Address of the proxy to get the admin of.
     */
    getProxyAdmin(_proxy: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the implementation of the given proxy address.
     * @param _proxy Address of the proxy to get the implementation of.
     */
    getProxyImplementation(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * A reverse mapping of addresses to names held in the AddressManager. This must be         manually kept up to date with changes in the AddressManager for this contract         to be able to work as an admin for the ResolvedDelegateProxy type.
     */
    implementationName(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     */
    isUpgrading(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * A mapping of proxy types, used for backwards compatibility.
     */
    proxyType(arg0: string, overrides?: CallOverrides): Promise<number>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * @param _address Address to attach to the given name.
     * @param _name Name to set within the AddressManager.
     */
    setAddress(
      _name: string,
      _address: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the address of the AddressManager. This is required to manage legacy         ResolvedDelegateProxy type proxy contracts.
     * @param _address Address of the AddressManager.
     */
    setAddressManager(
      _address: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the implementation name for a given address. Only required for         ResolvedDelegateProxy type proxies that have an implementation name.
     * @param _address Address of the ResolvedDelegateProxy.
     * @param _name Name of the implementation for the proxy.
     */
    setImplementationName(
      _address: string,
      _name: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the proxy type for a given address. Only required for non-standard (legacy)         proxy types.
     * @param _address Address of the proxy.
     * @param _type Type of the proxy.
     */
    setProxyType(
      _address: string,
      _type: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _upgrading Whether or not the system is upgrading.
     */
    setUpgrading(_upgrading: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Changes a proxy's implementation contract.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgrade(
      _proxy: string,
      _implementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Changes a proxy's implementation contract and delegatecalls the new implementation         with some given data. Useful for atomic upgrade-and-initialize calls.
     * @param _data Data to trigger the new implementation with.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgradeAndCall(
      _proxy: string,
      _implementation: string,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    /**
     * The address of the address manager, this is required to manage the         ResolvedDelegateProxy type.
     */
    addressManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Updates the admin of the given proxy address.
     * @param _newAdmin Address of the new proxy admin.
     * @param _proxy Address of the proxy to update.
     */
    changeProxyAdmin(
      _proxy: string,
      _newAdmin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the admin of the given proxy address.
     * @param _proxy Address of the proxy to get the admin of.
     */
    getProxyAdmin(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the implementation of the given proxy address.
     * @param _proxy Address of the proxy to get the implementation of.
     */
    getProxyImplementation(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * A reverse mapping of addresses to names held in the AddressManager. This must be         manually kept up to date with changes in the AddressManager for this contract         to be able to work as an admin for the ResolvedDelegateProxy type.
     */
    implementationName(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     */
    isUpgrading(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * A mapping of proxy types, used for backwards compatibility.
     */
    proxyType(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _address Address to attach to the given name.
     * @param _name Name to set within the AddressManager.
     */
    setAddress(
      _name: string,
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Set the address of the AddressManager. This is required to manage legacy         ResolvedDelegateProxy type proxy contracts.
     * @param _address Address of the AddressManager.
     */
    setAddressManager(
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the implementation name for a given address. Only required for         ResolvedDelegateProxy type proxies that have an implementation name.
     * @param _address Address of the ResolvedDelegateProxy.
     * @param _name Name of the implementation for the proxy.
     */
    setImplementationName(
      _address: string,
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the proxy type for a given address. Only required for non-standard (legacy)         proxy types.
     * @param _address Address of the proxy.
     * @param _type Type of the proxy.
     */
    setProxyType(
      _address: string,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _upgrading Whether or not the system is upgrading.
     */
    setUpgrading(
      _upgrading: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Changes a proxy's implementation contract.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgrade(
      _proxy: string,
      _implementation: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Changes a proxy's implementation contract and delegatecalls the new implementation         with some given data. Useful for atomic upgrade-and-initialize calls.
     * @param _data Data to trigger the new implementation with.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgradeAndCall(
      _proxy: string,
      _implementation: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The address of the address manager, this is required to manage the         ResolvedDelegateProxy type.
     */
    addressManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Updates the admin of the given proxy address.
     * @param _newAdmin Address of the new proxy admin.
     * @param _proxy Address of the proxy to update.
     */
    changeProxyAdmin(
      _proxy: string,
      _newAdmin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin of the given proxy address.
     * @param _proxy Address of the proxy to get the admin of.
     */
    getProxyAdmin(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the implementation of the given proxy address.
     * @param _proxy Address of the proxy to get the implementation of.
     */
    getProxyImplementation(
      _proxy: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * A reverse mapping of addresses to names held in the AddressManager. This must be         manually kept up to date with changes in the AddressManager for this contract         to be able to work as an admin for the ResolvedDelegateProxy type.
     */
    implementationName(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    isUpgrading(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * A mapping of proxy types, used for backwards compatibility.
     */
    proxyType(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _address Address to attach to the given name.
     * @param _name Name to set within the AddressManager.
     */
    setAddress(
      _name: string,
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the address of the AddressManager. This is required to manage legacy         ResolvedDelegateProxy type proxy contracts.
     * @param _address Address of the AddressManager.
     */
    setAddressManager(
      _address: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the implementation name for a given address. Only required for         ResolvedDelegateProxy type proxies that have an implementation name.
     * @param _address Address of the ResolvedDelegateProxy.
     * @param _name Name of the implementation for the proxy.
     */
    setImplementationName(
      _address: string,
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the proxy type for a given address. Only required for non-standard (legacy)         proxy types.
     * @param _address Address of the proxy.
     * @param _type Type of the proxy.
     */
    setProxyType(
      _address: string,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _upgrading Whether or not the system is upgrading.
     */
    setUpgrading(
      _upgrading: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Changes a proxy's implementation contract.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgrade(
      _proxy: string,
      _implementation: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Changes a proxy's implementation contract and delegatecalls the new implementation         with some given data. Useful for atomic upgrade-and-initialize calls.
     * @param _data Data to trigger the new implementation with.
     * @param _implementation Address of the new implementation address.
     * @param _proxy Address of the proxy to upgrade.
     */
    upgradeAndCall(
      _proxy: string,
      _implementation: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
