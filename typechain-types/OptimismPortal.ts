/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace Types {
  export type WithdrawalTransactionStruct = {
    nonce: BigNumberish;
    sender: BytesLike;
    target: string;
    value: BigNumberish;
    gasLimit: BigNumberish;
    data: BytesLike;
  };

  export type WithdrawalTransactionStructOutput = [
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    string
  ] & {
    nonce: BigNumber;
    sender: string;
    target: string;
    value: BigNumber;
    gasLimit: BigNumber;
    data: string;
  };

  export type OutputRootProofStruct = {
    version: BytesLike;
    stateRoot: BytesLike;
    messagePasserStorageRoot: BytesLike;
    latestBlockhash: BytesLike;
  };

  export type OutputRootProofStructOutput = [string, string, string, string] & {
    version: string;
    stateRoot: string;
    messagePasserStorageRoot: string;
    latestBlockhash: string;
  };
}

export interface OptimismPortalInterface extends utils.Interface {
  functions: {
    "MIN_BRIDGE_VALUE()": FunctionFragment;
    "balance()": FunctionFragment;
    "depositERC20Transaction(bytes32,uint256,uint256,uint64,bool,bytes)": FunctionFragment;
    "depositTransaction(bytes32,uint256,uint64,bool,bytes)": FunctionFragment;
    "donateETH()": FunctionFragment;
    "finalizeWithdrawalTransaction((uint256,bytes32,address,uint256,uint256,bytes))": FunctionFragment;
    "finalizedWithdrawals(bytes32)": FunctionFragment;
    "guardian()": FunctionFragment;
    "initialize(address,address,address)": FunctionFragment;
    "isOutputFinalized(uint256)": FunctionFragment;
    "l2Oracle()": FunctionFragment;
    "l2Sender()": FunctionFragment;
    "minimumGasLimit(uint64)": FunctionFragment;
    "params()": FunctionFragment;
    "paused()": FunctionFragment;
    "proveWithdrawalTransaction((uint256,bytes32,address,uint256,uint256,bytes),uint256,bytes32,(bytes32,bytes32,bytes32,bytes32),bytes[])": FunctionFragment;
    "provenWithdrawals(bytes32)": FunctionFragment;
    "superchainConfig()": FunctionFragment;
    "systemConfig()": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MIN_BRIDGE_VALUE"
      | "balance"
      | "depositERC20Transaction"
      | "depositTransaction"
      | "donateETH"
      | "finalizeWithdrawalTransaction"
      | "finalizedWithdrawals"
      | "guardian"
      | "initialize"
      | "isOutputFinalized"
      | "l2Oracle"
      | "l2Sender"
      | "minimumGasLimit"
      | "params"
      | "paused"
      | "proveWithdrawalTransaction"
      | "provenWithdrawals"
      | "superchainConfig"
      | "systemConfig"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MIN_BRIDGE_VALUE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "balance", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "depositERC20Transaction",
    values: [
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositTransaction",
    values: [BytesLike, BigNumberish, BigNumberish, boolean, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "donateETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "finalizeWithdrawalTransaction",
    values: [Types.WithdrawalTransactionStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizedWithdrawals",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "guardian", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isOutputFinalized",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "l2Oracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "l2Sender", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "minimumGasLimit",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "params", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proveWithdrawalTransaction",
    values: [
      Types.WithdrawalTransactionStruct,
      BigNumberish,
      BytesLike,
      Types.OutputRootProofStruct,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "provenWithdrawals",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "superchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "systemConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "MIN_BRIDGE_VALUE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20Transaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "donateETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalizeWithdrawalTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizedWithdrawals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "guardian", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isOutputFinalized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "l2Oracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "l2Sender", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "minimumGasLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "params", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proveWithdrawalTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "provenWithdrawals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "superchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "systemConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "TransactionDeposited(address,bytes32,uint256,bytes)": EventFragment;
    "WithdrawalFinalized(bytes32,bool)": EventFragment;
    "WithdrawalProven(bytes32,bytes32,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionDeposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalProven"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface TransactionDepositedEventObject {
  from: string;
  to: string;
  version: BigNumber;
  opaqueData: string;
}
export type TransactionDepositedEvent = TypedEvent<
  [string, string, BigNumber, string],
  TransactionDepositedEventObject
>;

export type TransactionDepositedEventFilter =
  TypedEventFilter<TransactionDepositedEvent>;

export interface WithdrawalFinalizedEventObject {
  withdrawalHash: string;
  success: boolean;
}
export type WithdrawalFinalizedEvent = TypedEvent<
  [string, boolean],
  WithdrawalFinalizedEventObject
>;

export type WithdrawalFinalizedEventFilter =
  TypedEventFilter<WithdrawalFinalizedEvent>;

export interface WithdrawalProvenEventObject {
  withdrawalHash: string;
  from: string;
  to: string;
}
export type WithdrawalProvenEvent = TypedEvent<
  [string, string, string],
  WithdrawalProvenEventObject
>;

export type WithdrawalProvenEventFilter =
  TypedEventFilter<WithdrawalProvenEvent>;

export interface OptimismPortal extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OptimismPortalInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Minimal deposit value
     */
    MIN_BRIDGE_VALUE(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Getter for the balance of the contract.
     */
    balance(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Entrypoint to depositing an ERC20 token as a custom gas token.         This function depends on a well formed ERC20 token. There are only         so many checks that can be done on chain for this so it is assumed         that chain operators will deploy chains with well formed ERC20 tokens.
     */
    depositERC20Transaction(
      arg0: BytesLike,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: boolean,
      arg5: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in         deriving deposit transactions. Note that if a deposit is made by a contract, its         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider         using the CrossDomainMessenger contracts for a simpler developer experience.
     * @param _data Data to trigger the recipient with.
     * @param _gasLimit Amount of L2 gas to purchase by burning gas on L1.
     * @param _isCreation Whether or not the transaction is a contract creation.
     * @param _to Target address on L2.
     * @param _value ETH value to send to the recipient.
     */
    depositTransaction(
      _to: BytesLike,
      _value: BigNumberish,
      _gasLimit: BigNumberish,
      _isCreation: boolean,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Accepts ETH value without triggering a deposit to L2.         This function mainly exists for the sake of the migration between the legacy         Optimism system and Bedrock.
     */
    donateETH(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    finalizeWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * A list of withdrawal hashes which have been successfully finalized.
     */
    finalizedWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Getter function for the address of the guardian.         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.
     */
    guardian(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Initializer.
     * @param _l2Oracle Contract of the L2OutputOracle.
     * @param _superchainConfig Contract of the SuperchainConfig.
     * @param _systemConfig Contract of the SystemConfig.
     */
    initialize(
      _l2Oracle: string,
      _systemConfig: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Determine if a given output is finalized.         Reverts if the call to l2Oracle.getL2Output reverts.         Returns a boolean otherwise.
     * @param _l2OutputIndex Index of the L2 output to check.
     */
    isOutputFinalized(
      _l2OutputIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Contract of the L2OutputOracle.
     */
    l2Oracle(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Address of the L2 account which initiated a withdrawal in this transaction.         If the of this variable is the default L2 sender address, then we are NOT inside of         a call to finalizeWithdrawalTransaction.
     */
    l2Sender(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Computes the minimum gas limit for a deposit.         The minimum gas limit linearly increases based on the size of the calldata.         This is to prevent users from creating L2 resource usage without paying for it.         This function can be used when interacting with the portal to ensure forwards         compatibility.
     * @param _byteCount Number of bytes in the calldata.
     */
    minimumGasLimit(
      _byteCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * EIP-1559 style gas parameters.
     */
    params(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        prevBaseFee: BigNumber;
        prevBoughtGas: BigNumber;
        prevBlockNum: BigNumber;
      }
    >;

    /**
     * Getter for the current paused status.
     */
    paused(
      overrides?: CallOverrides
    ): Promise<[boolean] & { paused_: boolean }>;

    proveWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      _l2OutputIndex: BigNumberish,
      _pdaPubkey: BytesLike,
      _outputRootProof: Types.OutputRootProofStruct,
      _withdrawalProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * A mapping of withdrawal hashes to `ProvenWithdrawal` data.
     */
    provenWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        outputRoot: string;
        timestamp: BigNumber;
        l2OutputIndex: BigNumber;
      }
    >;

    /**
     * Contract of the Superchain Config.
     */
    superchainConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Contract of the SystemConfig.
     */
    systemConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Minimal deposit value
   */
  MIN_BRIDGE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Getter for the balance of the contract.
   */
  balance(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Entrypoint to depositing an ERC20 token as a custom gas token.         This function depends on a well formed ERC20 token. There are only         so many checks that can be done on chain for this so it is assumed         that chain operators will deploy chains with well formed ERC20 tokens.
   */
  depositERC20Transaction(
    arg0: BytesLike,
    arg1: BigNumberish,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: boolean,
    arg5: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in         deriving deposit transactions. Note that if a deposit is made by a contract, its         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider         using the CrossDomainMessenger contracts for a simpler developer experience.
   * @param _data Data to trigger the recipient with.
   * @param _gasLimit Amount of L2 gas to purchase by burning gas on L1.
   * @param _isCreation Whether or not the transaction is a contract creation.
   * @param _to Target address on L2.
   * @param _value ETH value to send to the recipient.
   */
  depositTransaction(
    _to: BytesLike,
    _value: BigNumberish,
    _gasLimit: BigNumberish,
    _isCreation: boolean,
    _data: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Accepts ETH value without triggering a deposit to L2.         This function mainly exists for the sake of the migration between the legacy         Optimism system and Bedrock.
   */
  donateETH(
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  finalizeWithdrawalTransaction(
    _tx: Types.WithdrawalTransactionStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * A list of withdrawal hashes which have been successfully finalized.
   */
  finalizedWithdrawals(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Getter function for the address of the guardian.         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.
   */
  guardian(overrides?: CallOverrides): Promise<string>;

  /**
   * Initializer.
   * @param _l2Oracle Contract of the L2OutputOracle.
   * @param _superchainConfig Contract of the SuperchainConfig.
   * @param _systemConfig Contract of the SystemConfig.
   */
  initialize(
    _l2Oracle: string,
    _systemConfig: string,
    _superchainConfig: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Determine if a given output is finalized.         Reverts if the call to l2Oracle.getL2Output reverts.         Returns a boolean otherwise.
   * @param _l2OutputIndex Index of the L2 output to check.
   */
  isOutputFinalized(
    _l2OutputIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Contract of the L2OutputOracle.
   */
  l2Oracle(overrides?: CallOverrides): Promise<string>;

  /**
   * Address of the L2 account which initiated a withdrawal in this transaction.         If the of this variable is the default L2 sender address, then we are NOT inside of         a call to finalizeWithdrawalTransaction.
   */
  l2Sender(overrides?: CallOverrides): Promise<string>;

  /**
   * Computes the minimum gas limit for a deposit.         The minimum gas limit linearly increases based on the size of the calldata.         This is to prevent users from creating L2 resource usage without paying for it.         This function can be used when interacting with the portal to ensure forwards         compatibility.
   * @param _byteCount Number of bytes in the calldata.
   */
  minimumGasLimit(
    _byteCount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * EIP-1559 style gas parameters.
   */
  params(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      prevBaseFee: BigNumber;
      prevBoughtGas: BigNumber;
      prevBlockNum: BigNumber;
    }
  >;

  /**
   * Getter for the current paused status.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  proveWithdrawalTransaction(
    _tx: Types.WithdrawalTransactionStruct,
    _l2OutputIndex: BigNumberish,
    _pdaPubkey: BytesLike,
    _outputRootProof: Types.OutputRootProofStruct,
    _withdrawalProof: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * A mapping of withdrawal hashes to `ProvenWithdrawal` data.
   */
  provenWithdrawals(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber] & {
      outputRoot: string;
      timestamp: BigNumber;
      l2OutputIndex: BigNumber;
    }
  >;

  /**
   * Contract of the Superchain Config.
   */
  superchainConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Contract of the SystemConfig.
   */
  systemConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Minimal deposit value
     */
    MIN_BRIDGE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the balance of the contract.
     */
    balance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Entrypoint to depositing an ERC20 token as a custom gas token.         This function depends on a well formed ERC20 token. There are only         so many checks that can be done on chain for this so it is assumed         that chain operators will deploy chains with well formed ERC20 tokens.
     */
    depositERC20Transaction(
      arg0: BytesLike,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: boolean,
      arg5: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in         deriving deposit transactions. Note that if a deposit is made by a contract, its         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider         using the CrossDomainMessenger contracts for a simpler developer experience.
     * @param _data Data to trigger the recipient with.
     * @param _gasLimit Amount of L2 gas to purchase by burning gas on L1.
     * @param _isCreation Whether or not the transaction is a contract creation.
     * @param _to Target address on L2.
     * @param _value ETH value to send to the recipient.
     */
    depositTransaction(
      _to: BytesLike,
      _value: BigNumberish,
      _gasLimit: BigNumberish,
      _isCreation: boolean,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accepts ETH value without triggering a deposit to L2.         This function mainly exists for the sake of the migration between the legacy         Optimism system and Bedrock.
     */
    donateETH(overrides?: CallOverrides): Promise<void>;

    finalizeWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * A list of withdrawal hashes which have been successfully finalized.
     */
    finalizedWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Getter function for the address of the guardian.         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.
     */
    guardian(overrides?: CallOverrides): Promise<string>;

    /**
     * Initializer.
     * @param _l2Oracle Contract of the L2OutputOracle.
     * @param _superchainConfig Contract of the SuperchainConfig.
     * @param _systemConfig Contract of the SystemConfig.
     */
    initialize(
      _l2Oracle: string,
      _systemConfig: string,
      _superchainConfig: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Determine if a given output is finalized.         Reverts if the call to l2Oracle.getL2Output reverts.         Returns a boolean otherwise.
     * @param _l2OutputIndex Index of the L2 output to check.
     */
    isOutputFinalized(
      _l2OutputIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Contract of the L2OutputOracle.
     */
    l2Oracle(overrides?: CallOverrides): Promise<string>;

    /**
     * Address of the L2 account which initiated a withdrawal in this transaction.         If the of this variable is the default L2 sender address, then we are NOT inside of         a call to finalizeWithdrawalTransaction.
     */
    l2Sender(overrides?: CallOverrides): Promise<string>;

    /**
     * Computes the minimum gas limit for a deposit.         The minimum gas limit linearly increases based on the size of the calldata.         This is to prevent users from creating L2 resource usage without paying for it.         This function can be used when interacting with the portal to ensure forwards         compatibility.
     * @param _byteCount Number of bytes in the calldata.
     */
    minimumGasLimit(
      _byteCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * EIP-1559 style gas parameters.
     */
    params(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        prevBaseFee: BigNumber;
        prevBoughtGas: BigNumber;
        prevBlockNum: BigNumber;
      }
    >;

    /**
     * Getter for the current paused status.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;

    proveWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      _l2OutputIndex: BigNumberish,
      _pdaPubkey: BytesLike,
      _outputRootProof: Types.OutputRootProofStruct,
      _withdrawalProof: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * A mapping of withdrawal hashes to `ProvenWithdrawal` data.
     */
    provenWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        outputRoot: string;
        timestamp: BigNumber;
        l2OutputIndex: BigNumber;
      }
    >;

    /**
     * Contract of the Superchain Config.
     */
    superchainConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Contract of the SystemConfig.
     */
    systemConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "TransactionDeposited(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      version?: BigNumberish | null,
      opaqueData?: null
    ): TransactionDepositedEventFilter;
    TransactionDeposited(
      from?: string | null,
      to?: BytesLike | null,
      version?: BigNumberish | null,
      opaqueData?: null
    ): TransactionDepositedEventFilter;

    "WithdrawalFinalized(bytes32,bool)"(
      withdrawalHash?: BytesLike | null,
      success?: null
    ): WithdrawalFinalizedEventFilter;
    WithdrawalFinalized(
      withdrawalHash?: BytesLike | null,
      success?: null
    ): WithdrawalFinalizedEventFilter;

    "WithdrawalProven(bytes32,bytes32,address)"(
      withdrawalHash?: BytesLike | null,
      from?: BytesLike | null,
      to?: string | null
    ): WithdrawalProvenEventFilter;
    WithdrawalProven(
      withdrawalHash?: BytesLike | null,
      from?: BytesLike | null,
      to?: string | null
    ): WithdrawalProvenEventFilter;
  };

  estimateGas: {
    /**
     * Minimal deposit value
     */
    MIN_BRIDGE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the balance of the contract.
     */
    balance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Entrypoint to depositing an ERC20 token as a custom gas token.         This function depends on a well formed ERC20 token. There are only         so many checks that can be done on chain for this so it is assumed         that chain operators will deploy chains with well formed ERC20 tokens.
     */
    depositERC20Transaction(
      arg0: BytesLike,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: boolean,
      arg5: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in         deriving deposit transactions. Note that if a deposit is made by a contract, its         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider         using the CrossDomainMessenger contracts for a simpler developer experience.
     * @param _data Data to trigger the recipient with.
     * @param _gasLimit Amount of L2 gas to purchase by burning gas on L1.
     * @param _isCreation Whether or not the transaction is a contract creation.
     * @param _to Target address on L2.
     * @param _value ETH value to send to the recipient.
     */
    depositTransaction(
      _to: BytesLike,
      _value: BigNumberish,
      _gasLimit: BigNumberish,
      _isCreation: boolean,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Accepts ETH value without triggering a deposit to L2.         This function mainly exists for the sake of the migration between the legacy         Optimism system and Bedrock.
     */
    donateETH(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    finalizeWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * A list of withdrawal hashes which have been successfully finalized.
     */
    finalizedWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Getter function for the address of the guardian.         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.
     */
    guardian(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Initializer.
     * @param _l2Oracle Contract of the L2OutputOracle.
     * @param _superchainConfig Contract of the SuperchainConfig.
     * @param _systemConfig Contract of the SystemConfig.
     */
    initialize(
      _l2Oracle: string,
      _systemConfig: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Determine if a given output is finalized.         Reverts if the call to l2Oracle.getL2Output reverts.         Returns a boolean otherwise.
     * @param _l2OutputIndex Index of the L2 output to check.
     */
    isOutputFinalized(
      _l2OutputIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Contract of the L2OutputOracle.
     */
    l2Oracle(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the L2 account which initiated a withdrawal in this transaction.         If the of this variable is the default L2 sender address, then we are NOT inside of         a call to finalizeWithdrawalTransaction.
     */
    l2Sender(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Computes the minimum gas limit for a deposit.         The minimum gas limit linearly increases based on the size of the calldata.         This is to prevent users from creating L2 resource usage without paying for it.         This function can be used when interacting with the portal to ensure forwards         compatibility.
     * @param _byteCount Number of bytes in the calldata.
     */
    minimumGasLimit(
      _byteCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * EIP-1559 style gas parameters.
     */
    params(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the current paused status.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;

    proveWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      _l2OutputIndex: BigNumberish,
      _pdaPubkey: BytesLike,
      _outputRootProof: Types.OutputRootProofStruct,
      _withdrawalProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * A mapping of withdrawal hashes to `ProvenWithdrawal` data.
     */
    provenWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Contract of the Superchain Config.
     */
    superchainConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Contract of the SystemConfig.
     */
    systemConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Minimal deposit value
     */
    MIN_BRIDGE_VALUE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Getter for the balance of the contract.
     */
    balance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Entrypoint to depositing an ERC20 token as a custom gas token.         This function depends on a well formed ERC20 token. There are only         so many checks that can be done on chain for this so it is assumed         that chain operators will deploy chains with well formed ERC20 tokens.
     */
    depositERC20Transaction(
      arg0: BytesLike,
      arg1: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: boolean,
      arg5: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in         deriving deposit transactions. Note that if a deposit is made by a contract, its         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider         using the CrossDomainMessenger contracts for a simpler developer experience.
     * @param _data Data to trigger the recipient with.
     * @param _gasLimit Amount of L2 gas to purchase by burning gas on L1.
     * @param _isCreation Whether or not the transaction is a contract creation.
     * @param _to Target address on L2.
     * @param _value ETH value to send to the recipient.
     */
    depositTransaction(
      _to: BytesLike,
      _value: BigNumberish,
      _gasLimit: BigNumberish,
      _isCreation: boolean,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Accepts ETH value without triggering a deposit to L2.         This function mainly exists for the sake of the migration between the legacy         Optimism system and Bedrock.
     */
    donateETH(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    finalizeWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * A list of withdrawal hashes which have been successfully finalized.
     */
    finalizedWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Getter function for the address of the guardian.         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.
     */
    guardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Initializer.
     * @param _l2Oracle Contract of the L2OutputOracle.
     * @param _superchainConfig Contract of the SuperchainConfig.
     * @param _systemConfig Contract of the SystemConfig.
     */
    initialize(
      _l2Oracle: string,
      _systemConfig: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Determine if a given output is finalized.         Reverts if the call to l2Oracle.getL2Output reverts.         Returns a boolean otherwise.
     * @param _l2OutputIndex Index of the L2 output to check.
     */
    isOutputFinalized(
      _l2OutputIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Contract of the L2OutputOracle.
     */
    l2Oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the L2 account which initiated a withdrawal in this transaction.         If the of this variable is the default L2 sender address, then we are NOT inside of         a call to finalizeWithdrawalTransaction.
     */
    l2Sender(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Computes the minimum gas limit for a deposit.         The minimum gas limit linearly increases based on the size of the calldata.         This is to prevent users from creating L2 resource usage without paying for it.         This function can be used when interacting with the portal to ensure forwards         compatibility.
     * @param _byteCount Number of bytes in the calldata.
     */
    minimumGasLimit(
      _byteCount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * EIP-1559 style gas parameters.
     */
    params(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Getter for the current paused status.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proveWithdrawalTransaction(
      _tx: Types.WithdrawalTransactionStruct,
      _l2OutputIndex: BigNumberish,
      _pdaPubkey: BytesLike,
      _outputRootProof: Types.OutputRootProofStruct,
      _withdrawalProof: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * A mapping of withdrawal hashes to `ProvenWithdrawal` data.
     */
    provenWithdrawals(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Contract of the Superchain Config.
     */
    superchainConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Contract of the SystemConfig.
     */
    systemConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
