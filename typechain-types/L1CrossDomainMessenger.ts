/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface L1CrossDomainMessengerInterface extends utils.Interface {
  functions: {
    "MESSAGE_VERSION()": FunctionFragment;
    "MIN_GAS_CALLDATA_OVERHEAD()": FunctionFragment;
    "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR()": FunctionFragment;
    "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR()": FunctionFragment;
    "OTHER_MESSENGER()": FunctionFragment;
    "PORTAL()": FunctionFragment;
    "RELAY_CALL_OVERHEAD()": FunctionFragment;
    "RELAY_CONSTANT_OVERHEAD()": FunctionFragment;
    "RELAY_GAS_CHECK_BUFFER()": FunctionFragment;
    "RELAY_RESERVED_GAS()": FunctionFragment;
    "baseGas(bytes,uint32)": FunctionFragment;
    "encodeRelayL2Message(uint256,address,bytes32,uint256,uint256,bytes)": FunctionFragment;
    "failedMessages(bytes32)": FunctionFragment;
    "initialize(address,address,address)": FunctionFragment;
    "messageNonce()": FunctionFragment;
    "otherMessenger()": FunctionFragment;
    "paused()": FunctionFragment;
    "portal()": FunctionFragment;
    "relayMessage(uint256,bytes32,address,uint256,uint256,bytes)": FunctionFragment;
    "sendMessage(bytes32,bytes,uint32)": FunctionFragment;
    "successfulMessages(bytes32)": FunctionFragment;
    "superchainConfig()": FunctionFragment;
    "systemConfig()": FunctionFragment;
    "version()": FunctionFragment;
    "xDomainMessageSender()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MESSAGE_VERSION"
      | "MIN_GAS_CALLDATA_OVERHEAD"
      | "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR"
      | "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR"
      | "OTHER_MESSENGER"
      | "PORTAL"
      | "RELAY_CALL_OVERHEAD"
      | "RELAY_CONSTANT_OVERHEAD"
      | "RELAY_GAS_CHECK_BUFFER"
      | "RELAY_RESERVED_GAS"
      | "baseGas"
      | "encodeRelayL2Message"
      | "failedMessages"
      | "initialize"
      | "messageNonce"
      | "otherMessenger"
      | "paused"
      | "portal"
      | "relayMessage"
      | "sendMessage"
      | "successfulMessages"
      | "superchainConfig"
      | "systemConfig"
      | "version"
      | "xDomainMessageSender"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MESSAGE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_GAS_CALLDATA_OVERHEAD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OTHER_MESSENGER",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "PORTAL", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "RELAY_CALL_OVERHEAD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RELAY_CONSTANT_OVERHEAD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RELAY_GAS_CHECK_BUFFER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RELAY_RESERVED_GAS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "baseGas",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeRelayL2Message",
    values: [
      BigNumberish,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "failedMessages",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "messageNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "otherMessenger",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(functionFragment: "portal", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "relayMessage",
    values: [
      BigNumberish,
      BytesLike,
      string,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendMessage",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "successfulMessages",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "superchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "systemConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "xDomainMessageSender",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "MESSAGE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_GAS_CALLDATA_OVERHEAD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OTHER_MESSENGER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "PORTAL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "RELAY_CALL_OVERHEAD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RELAY_CONSTANT_OVERHEAD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RELAY_GAS_CHECK_BUFFER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RELAY_RESERVED_GAS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "baseGas", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "encodeRelayL2Message",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "failedMessages",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "messageNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "otherMessenger",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "portal", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "relayMessage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendMessage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "successfulMessages",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "superchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "systemConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "xDomainMessageSender",
    data: BytesLike
  ): Result;

  events: {
    "FailedRelayedMessage(bytes32)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "RelayedMessage(bytes32)": EventFragment;
    "SentMessage(bytes32,address,bytes,uint256,uint256)": EventFragment;
    "SentMessageExtension1(address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "FailedRelayedMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayedMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SentMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SentMessageExtension1"): EventFragment;
}

export interface FailedRelayedMessageEventObject {
  msgHash: string;
}
export type FailedRelayedMessageEvent = TypedEvent<
  [string],
  FailedRelayedMessageEventObject
>;

export type FailedRelayedMessageEventFilter =
  TypedEventFilter<FailedRelayedMessageEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface RelayedMessageEventObject {
  msgHash: string;
}
export type RelayedMessageEvent = TypedEvent<
  [string],
  RelayedMessageEventObject
>;

export type RelayedMessageEventFilter = TypedEventFilter<RelayedMessageEvent>;

export interface SentMessageEventObject {
  target: string;
  sender: string;
  message: string;
  messageNonce: BigNumber;
  gasLimit: BigNumber;
}
export type SentMessageEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  SentMessageEventObject
>;

export type SentMessageEventFilter = TypedEventFilter<SentMessageEvent>;

export interface SentMessageExtension1EventObject {
  sender: string;
  value: BigNumber;
}
export type SentMessageExtension1Event = TypedEvent<
  [string, BigNumber],
  SentMessageExtension1EventObject
>;

export type SentMessageExtension1EventFilter =
  TypedEventFilter<SentMessageExtension1Event>;

export interface L1CrossDomainMessenger extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L1CrossDomainMessengerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Current message version identifier.
     */
    MESSAGE_VERSION(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Extra gas added to base gas for each byte of calldata in a message.
     */
    MIN_GAS_CALLDATA_OVERHEAD(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Denominator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Numerator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Retrieves the address of the paired CrossDomainMessenger contract on the other chain         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.
     */
    OTHER_MESSENGER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Getter function for the OptimismPortal contract on this chain.         Public getter is legacy and will be removed in the future. Use `portal()` instead.
     */
    PORTAL(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Gas reserved for performing the external call in `relayMessage`.
     */
    RELAY_CALL_OVERHEAD(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Constant overhead added to the base gas for a message.
     */
    RELAY_CONSTANT_OVERHEAD(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Gas reserved for the execution between the `hasMinGas` check and the external         call in `relayMessage`.
     */
    RELAY_GAS_CHECK_BUFFER(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Gas reserved for finalizing the execution of `relayMessage` after the safe call.
     */
    RELAY_RESERVED_GAS(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Computes the amount of gas required to guarantee that a given message will be         received on the other chain without running out of gas. Guaranteeing that a message         will not run out of gas is important because this ensures that a message can always         be replayed on the other chain if it fails to execute completely.
     * @param _message Message to compute the amount of required gas for.
     * @param _minGasLimit Minimum desired gas limit when message goes to target.
     */
    baseGas(
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Encode L2 message to relay on L2.
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    encodeRelayL2Message(
      _nonce: BigNumberish,
      _sender: string,
      _target: BytesLike,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Mapping of message hashes to a boolean if and only if the message has failed to be         executed at least once. A message will not be present in this mapping if it         successfully executed on the first attempt.
     */
    failedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Initializes the contract.
     * @param _portal Contract of the OptimismPortal contract on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     * @param _systemConfig Contract of the SystemConfig contract on this network.
     */
    initialize(
      _superchainConfig: string,
      _portal: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.
     */
    messageNonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * CrossDomainMessenger contract on the other chain.
     */
    otherMessenger(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Contract of the OptimismPortal.
     */
    portal(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.
     * @param _message Message to send to the target.
     * @param _minGasLimit Minimum amount of gas that the message can be executed with.
     * @param _nonce Nonce of the message being relayed.
     * @param _sender Address of the user who sent the message.
     * @param _target Address that the message is targeted at.
     * @param _value ETH value to send with the message.
     */
    relayMessage(
      _nonce: BigNumberish,
      _sender: BytesLike,
      _target: string,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sends a message to some target address on the other chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    sendMessage(
      _target: BytesLike,
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.
     */
    successfulMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Contract of the SuperchainConfig.
     */
    superchainConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Retrieves the address of the contract or wallet that initiated the currently         executing message on the other chain. Will throw an error if there is no message         currently being executed. Allows the recipient of a call to see who triggered it.
     */
    xDomainMessageSender(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Current message version identifier.
   */
  MESSAGE_VERSION(overrides?: CallOverrides): Promise<number>;

  /**
   * Extra gas added to base gas for each byte of calldata in a message.
   */
  MIN_GAS_CALLDATA_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Denominator for dynamic overhead added to the base gas for a message.
   */
  MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Numerator for dynamic overhead added to the base gas for a message.
   */
  MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Retrieves the address of the paired CrossDomainMessenger contract on the other chain         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.
   */
  OTHER_MESSENGER(overrides?: CallOverrides): Promise<string>;

  /**
   * Getter function for the OptimismPortal contract on this chain.         Public getter is legacy and will be removed in the future. Use `portal()` instead.
   */
  PORTAL(overrides?: CallOverrides): Promise<string>;

  /**
   * Gas reserved for performing the external call in `relayMessage`.
   */
  RELAY_CALL_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Constant overhead added to the base gas for a message.
   */
  RELAY_CONSTANT_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gas reserved for the execution between the `hasMinGas` check and the external         call in `relayMessage`.
   */
  RELAY_GAS_CHECK_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gas reserved for finalizing the execution of `relayMessage` after the safe call.
   */
  RELAY_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Computes the amount of gas required to guarantee that a given message will be         received on the other chain without running out of gas. Guaranteeing that a message         will not run out of gas is important because this ensures that a message can always         be replayed on the other chain if it fails to execute completely.
   * @param _message Message to compute the amount of required gas for.
   * @param _minGasLimit Minimum desired gas limit when message goes to target.
   */
  baseGas(
    _message: BytesLike,
    _minGasLimit: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Encode L2 message to relay on L2.
   * @param _message Message to trigger the target address with.
   * @param _minGasLimit Minimum gas limit that the message can be executed with.
   * @param _target Target contract or wallet address.
   */
  encodeRelayL2Message(
    _nonce: BigNumberish,
    _sender: string,
    _target: BytesLike,
    _value: BigNumberish,
    _minGasLimit: BigNumberish,
    _message: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Mapping of message hashes to a boolean if and only if the message has failed to be         executed at least once. A message will not be present in this mapping if it         successfully executed on the first attempt.
   */
  failedMessages(arg0: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Initializes the contract.
   * @param _portal Contract of the OptimismPortal contract on this network.
   * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
   * @param _systemConfig Contract of the SystemConfig contract on this network.
   */
  initialize(
    _superchainConfig: string,
    _portal: string,
    _systemConfig: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.
   */
  messageNonce(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * CrossDomainMessenger contract on the other chain.
   */
  otherMessenger(overrides?: CallOverrides): Promise<string>;

  /**
   * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Contract of the OptimismPortal.
   */
  portal(overrides?: CallOverrides): Promise<string>;

  /**
   * Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.
   * @param _message Message to send to the target.
   * @param _minGasLimit Minimum amount of gas that the message can be executed with.
   * @param _nonce Nonce of the message being relayed.
   * @param _sender Address of the user who sent the message.
   * @param _target Address that the message is targeted at.
   * @param _value ETH value to send with the message.
   */
  relayMessage(
    _nonce: BigNumberish,
    _sender: BytesLike,
    _target: string,
    _value: BigNumberish,
    _minGasLimit: BigNumberish,
    _message: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sends a message to some target address on the other chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).
   * @param _message Message to trigger the target address with.
   * @param _minGasLimit Minimum gas limit that the message can be executed with.
   * @param _target Target contract or wallet address.
   */
  sendMessage(
    _target: BytesLike,
    _message: BytesLike,
    _minGasLimit: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.
   */
  successfulMessages(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Contract of the SuperchainConfig.
   */
  superchainConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Address of the SystemConfig contract.
   */
  systemConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  /**
   * Retrieves the address of the contract or wallet that initiated the currently         executing message on the other chain. Will throw an error if there is no message         currently being executed. Allows the recipient of a call to see who triggered it.
   */
  xDomainMessageSender(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Current message version identifier.
     */
    MESSAGE_VERSION(overrides?: CallOverrides): Promise<number>;

    /**
     * Extra gas added to base gas for each byte of calldata in a message.
     */
    MIN_GAS_CALLDATA_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Denominator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Numerator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieves the address of the paired CrossDomainMessenger contract on the other chain         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.
     */
    OTHER_MESSENGER(overrides?: CallOverrides): Promise<string>;

    /**
     * Getter function for the OptimismPortal contract on this chain.         Public getter is legacy and will be removed in the future. Use `portal()` instead.
     */
    PORTAL(overrides?: CallOverrides): Promise<string>;

    /**
     * Gas reserved for performing the external call in `relayMessage`.
     */
    RELAY_CALL_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Constant overhead added to the base gas for a message.
     */
    RELAY_CONSTANT_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gas reserved for the execution between the `hasMinGas` check and the external         call in `relayMessage`.
     */
    RELAY_GAS_CHECK_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gas reserved for finalizing the execution of `relayMessage` after the safe call.
     */
    RELAY_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Computes the amount of gas required to guarantee that a given message will be         received on the other chain without running out of gas. Guaranteeing that a message         will not run out of gas is important because this ensures that a message can always         be replayed on the other chain if it fails to execute completely.
     * @param _message Message to compute the amount of required gas for.
     * @param _minGasLimit Minimum desired gas limit when message goes to target.
     */
    baseGas(
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message to relay on L2.
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    encodeRelayL2Message(
      _nonce: BigNumberish,
      _sender: string,
      _target: BytesLike,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Mapping of message hashes to a boolean if and only if the message has failed to be         executed at least once. A message will not be present in this mapping if it         successfully executed on the first attempt.
     */
    failedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Initializes the contract.
     * @param _portal Contract of the OptimismPortal contract on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     * @param _systemConfig Contract of the SystemConfig contract on this network.
     */
    initialize(
      _superchainConfig: string,
      _portal: string,
      _systemConfig: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.
     */
    messageNonce(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * CrossDomainMessenger contract on the other chain.
     */
    otherMessenger(overrides?: CallOverrides): Promise<string>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Contract of the OptimismPortal.
     */
    portal(overrides?: CallOverrides): Promise<string>;

    /**
     * Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.
     * @param _message Message to send to the target.
     * @param _minGasLimit Minimum amount of gas that the message can be executed with.
     * @param _nonce Nonce of the message being relayed.
     * @param _sender Address of the user who sent the message.
     * @param _target Address that the message is targeted at.
     * @param _value ETH value to send with the message.
     */
    relayMessage(
      _nonce: BigNumberish,
      _sender: BytesLike,
      _target: string,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sends a message to some target address on the other chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    sendMessage(
      _target: BytesLike,
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.
     */
    successfulMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Contract of the SuperchainConfig.
     */
    superchainConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;

    /**
     * Retrieves the address of the contract or wallet that initiated the currently         executing message on the other chain. Will throw an error if there is no message         currently being executed. Allows the recipient of a call to see who triggered it.
     */
    xDomainMessageSender(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "FailedRelayedMessage(bytes32)"(
      msgHash?: BytesLike | null
    ): FailedRelayedMessageEventFilter;
    FailedRelayedMessage(
      msgHash?: BytesLike | null
    ): FailedRelayedMessageEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "RelayedMessage(bytes32)"(
      msgHash?: BytesLike | null
    ): RelayedMessageEventFilter;
    RelayedMessage(msgHash?: BytesLike | null): RelayedMessageEventFilter;

    "SentMessage(bytes32,address,bytes,uint256,uint256)"(
      target?: BytesLike | null,
      sender?: null,
      message?: null,
      messageNonce?: null,
      gasLimit?: null
    ): SentMessageEventFilter;
    SentMessage(
      target?: BytesLike | null,
      sender?: null,
      message?: null,
      messageNonce?: null,
      gasLimit?: null
    ): SentMessageEventFilter;

    "SentMessageExtension1(address,uint256)"(
      sender?: string | null,
      value?: null
    ): SentMessageExtension1EventFilter;
    SentMessageExtension1(
      sender?: string | null,
      value?: null
    ): SentMessageExtension1EventFilter;
  };

  estimateGas: {
    /**
     * Current message version identifier.
     */
    MESSAGE_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Extra gas added to base gas for each byte of calldata in a message.
     */
    MIN_GAS_CALLDATA_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Denominator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Numerator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieves the address of the paired CrossDomainMessenger contract on the other chain         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.
     */
    OTHER_MESSENGER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter function for the OptimismPortal contract on this chain.         Public getter is legacy and will be removed in the future. Use `portal()` instead.
     */
    PORTAL(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gas reserved for performing the external call in `relayMessage`.
     */
    RELAY_CALL_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Constant overhead added to the base gas for a message.
     */
    RELAY_CONSTANT_OVERHEAD(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gas reserved for the execution between the `hasMinGas` check and the external         call in `relayMessage`.
     */
    RELAY_GAS_CHECK_BUFFER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gas reserved for finalizing the execution of `relayMessage` after the safe call.
     */
    RELAY_RESERVED_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Computes the amount of gas required to guarantee that a given message will be         received on the other chain without running out of gas. Guaranteeing that a message         will not run out of gas is important because this ensures that a message can always         be replayed on the other chain if it fails to execute completely.
     * @param _message Message to compute the amount of required gas for.
     * @param _minGasLimit Minimum desired gas limit when message goes to target.
     */
    baseGas(
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message to relay on L2.
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    encodeRelayL2Message(
      _nonce: BigNumberish,
      _sender: string,
      _target: BytesLike,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Mapping of message hashes to a boolean if and only if the message has failed to be         executed at least once. A message will not be present in this mapping if it         successfully executed on the first attempt.
     */
    failedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes the contract.
     * @param _portal Contract of the OptimismPortal contract on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     * @param _systemConfig Contract of the SystemConfig contract on this network.
     */
    initialize(
      _superchainConfig: string,
      _portal: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.
     */
    messageNonce(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * CrossDomainMessenger contract on the other chain.
     */
    otherMessenger(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Contract of the OptimismPortal.
     */
    portal(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.
     * @param _message Message to send to the target.
     * @param _minGasLimit Minimum amount of gas that the message can be executed with.
     * @param _nonce Nonce of the message being relayed.
     * @param _sender Address of the user who sent the message.
     * @param _target Address that the message is targeted at.
     * @param _value ETH value to send with the message.
     */
    relayMessage(
      _nonce: BigNumberish,
      _sender: BytesLike,
      _target: string,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sends a message to some target address on the other chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    sendMessage(
      _target: BytesLike,
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.
     */
    successfulMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Contract of the SuperchainConfig.
     */
    superchainConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Retrieves the address of the contract or wallet that initiated the currently         executing message on the other chain. Will throw an error if there is no message         currently being executed. Allows the recipient of a call to see who triggered it.
     */
    xDomainMessageSender(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Current message version identifier.
     */
    MESSAGE_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Extra gas added to base gas for each byte of calldata in a message.
     */
    MIN_GAS_CALLDATA_OVERHEAD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Denominator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Numerator for dynamic overhead added to the base gas for a message.
     */
    MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieves the address of the paired CrossDomainMessenger contract on the other chain         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.
     */
    OTHER_MESSENGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Getter function for the OptimismPortal contract on this chain.         Public getter is legacy and will be removed in the future. Use `portal()` instead.
     */
    PORTAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gas reserved for performing the external call in `relayMessage`.
     */
    RELAY_CALL_OVERHEAD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Constant overhead added to the base gas for a message.
     */
    RELAY_CONSTANT_OVERHEAD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gas reserved for the execution between the `hasMinGas` check and the external         call in `relayMessage`.
     */
    RELAY_GAS_CHECK_BUFFER(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gas reserved for finalizing the execution of `relayMessage` after the safe call.
     */
    RELAY_RESERVED_GAS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Computes the amount of gas required to guarantee that a given message will be         received on the other chain without running out of gas. Guaranteeing that a message         will not run out of gas is important because this ensures that a message can always         be replayed on the other chain if it fails to execute completely.
     * @param _message Message to compute the amount of required gas for.
     * @param _minGasLimit Minimum desired gas limit when message goes to target.
     */
    baseGas(
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encode L2 message to relay on L2.
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    encodeRelayL2Message(
      _nonce: BigNumberish,
      _sender: string,
      _target: BytesLike,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of message hashes to a boolean if and only if the message has failed to be         executed at least once. A message will not be present in this mapping if it         successfully executed on the first attempt.
     */
    failedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initializes the contract.
     * @param _portal Contract of the OptimismPortal contract on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     * @param _systemConfig Contract of the SystemConfig contract on this network.
     */
    initialize(
      _superchainConfig: string,
      _portal: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.
     */
    messageNonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * CrossDomainMessenger contract on the other chain.
     */
    otherMessenger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Contract of the OptimismPortal.
     */
    portal(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.
     * @param _message Message to send to the target.
     * @param _minGasLimit Minimum amount of gas that the message can be executed with.
     * @param _nonce Nonce of the message being relayed.
     * @param _sender Address of the user who sent the message.
     * @param _target Address that the message is targeted at.
     * @param _value ETH value to send with the message.
     */
    relayMessage(
      _nonce: BigNumberish,
      _sender: BytesLike,
      _target: string,
      _value: BigNumberish,
      _minGasLimit: BigNumberish,
      _message: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sends a message to some target address on the other chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).
     * @param _message Message to trigger the target address with.
     * @param _minGasLimit Minimum gas limit that the message can be executed with.
     * @param _target Target contract or wallet address.
     */
    sendMessage(
      _target: BytesLike,
      _message: BytesLike,
      _minGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.
     */
    successfulMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Contract of the SuperchainConfig.
     */
    superchainConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Retrieves the address of the contract or wallet that initiated the currently         executing message on the other chain. Will throw an error if there is no message         currently being executed. Allows the recipient of a call to see who triggered it.
     */
    xDomainMessageSender(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
