/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface SetupInterface extends utils.Interface {
  functions: {
    "L1()": FunctionFragment;
    "setUp()": FunctionFragment;
  };

  getFunction(nameOrSignatureOrTopic: "L1" | "setUp"): FunctionFragment;

  encodeFunctionData(functionFragment: "L1", values?: undefined): string;
  encodeFunctionData(functionFragment: "setUp", values?: undefined): string;

  decodeFunctionResult(functionFragment: "L1", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;

  events: {};
}

export interface Setup extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SetupInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * Sets up the L1 contracts.
   */
  L1(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  /**
   * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
   */
  setUp(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: CallOverrides): Promise<void>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(overrides?: CallOverrides): Promise<void>;
  };

  filters: {};

  estimateGas: {
    /**
     * Sets up the L1 contracts.
     */
    L1(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(overrides?: Overrides & { from?: string }): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Sets up the L1 contracts.
     */
    L1(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deploys the Deploy contract without including its bytecode in the bytecode      of this contract by fetching the bytecode dynamically using `vm.getCode()`.      If the Deploy bytecode is included in this contract, then it will double      the compile time and bloat all of the test contract artifacts since they      will also need to include the bytecode for the Deploy contract.      This is a hack as we are pushing solidity to the edge.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
