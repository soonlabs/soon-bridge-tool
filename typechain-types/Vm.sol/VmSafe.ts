/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace VmSafe {
  export type WalletStruct = {
    addr: string;
    publicKeyX: BigNumberish;
    publicKeyY: BigNumberish;
    privateKey: BigNumberish;
  };

  export type WalletStructOutput = [string, BigNumber, BigNumber, BigNumber] & {
    addr: string;
    publicKeyX: BigNumber;
    publicKeyY: BigNumber;
    privateKey: BigNumber;
  };

  export type EthGetLogsStruct = {
    emitter: string;
    topics: BytesLike[];
    data: BytesLike;
    blockHash: BytesLike;
    blockNumber: BigNumberish;
    transactionHash: BytesLike;
    transactionIndex: BigNumberish;
    logIndex: BigNumberish;
    removed: boolean;
  };

  export type EthGetLogsStructOutput = [
    string,
    string[],
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    emitter: string;
    topics: string[];
    data: string;
    blockHash: string;
    blockNumber: BigNumber;
    transactionHash: string;
    transactionIndex: BigNumber;
    logIndex: BigNumber;
    removed: boolean;
  };

  export type FsMetadataStruct = {
    isDir: boolean;
    isSymlink: boolean;
    length: BigNumberish;
    readOnly: boolean;
    modified: BigNumberish;
    accessed: BigNumberish;
    created: BigNumberish;
  };

  export type FsMetadataStructOutput = [
    boolean,
    boolean,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isDir: boolean;
    isSymlink: boolean;
    length: BigNumber;
    readOnly: boolean;
    modified: BigNumber;
    accessed: BigNumber;
    created: BigNumber;
  };

  export type LogStruct = {
    topics: BytesLike[];
    data: BytesLike;
    emitter: string;
  };

  export type LogStructOutput = [string[], string, string] & {
    topics: string[];
    data: string;
    emitter: string;
  };

  export type GasStruct = {
    gasLimit: BigNumberish;
    gasTotalUsed: BigNumberish;
    gasMemoryUsed: BigNumberish;
    gasRefunded: BigNumberish;
    gasRemaining: BigNumberish;
  };

  export type GasStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    gasLimit: BigNumber;
    gasTotalUsed: BigNumber;
    gasMemoryUsed: BigNumber;
    gasRefunded: BigNumber;
    gasRemaining: BigNumber;
  };

  export type DirEntryStruct = {
    errorMessage: string;
    path: string;
    depth: BigNumberish;
    isDir: boolean;
    isSymlink: boolean;
  };

  export type DirEntryStructOutput = [
    string,
    string,
    BigNumber,
    boolean,
    boolean
  ] & {
    errorMessage: string;
    path: string;
    depth: BigNumber;
    isDir: boolean;
    isSymlink: boolean;
  };

  export type RpcStruct = { key: string; url: string };

  export type RpcStructOutput = [string, string] & { key: string; url: string };

  export type ChainInfoStruct = { forkId: BigNumberish; chainId: BigNumberish };

  export type ChainInfoStructOutput = [BigNumber, BigNumber] & {
    forkId: BigNumber;
    chainId: BigNumber;
  };

  export type StorageAccessStruct = {
    account: string;
    slot: BytesLike;
    isWrite: boolean;
    previousValue: BytesLike;
    newValue: BytesLike;
    reverted: boolean;
  };

  export type StorageAccessStructOutput = [
    string,
    string,
    boolean,
    string,
    string,
    boolean
  ] & {
    account: string;
    slot: string;
    isWrite: boolean;
    previousValue: string;
    newValue: string;
    reverted: boolean;
  };

  export type AccountAccessStruct = {
    chainInfo: VmSafe.ChainInfoStruct;
    kind: BigNumberish;
    account: string;
    accessor: string;
    initialized: boolean;
    oldBalance: BigNumberish;
    newBalance: BigNumberish;
    deployedCode: BytesLike;
    value: BigNumberish;
    data: BytesLike;
    reverted: boolean;
    storageAccesses: VmSafe.StorageAccessStruct[];
    depth: BigNumberish;
  };

  export type AccountAccessStructOutput = [
    VmSafe.ChainInfoStructOutput,
    number,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    string,
    boolean,
    VmSafe.StorageAccessStructOutput[],
    BigNumber
  ] & {
    chainInfo: VmSafe.ChainInfoStructOutput;
    kind: number;
    account: string;
    accessor: string;
    initialized: boolean;
    oldBalance: BigNumber;
    newBalance: BigNumber;
    deployedCode: string;
    value: BigNumber;
    data: string;
    reverted: boolean;
    storageAccesses: VmSafe.StorageAccessStructOutput[];
    depth: BigNumber;
  };

  export type FfiResultStruct = {
    exitCode: BigNumberish;
    stdout: BytesLike;
    stderr: BytesLike;
  };

  export type FfiResultStructOutput = [number, string, string] & {
    exitCode: number;
    stdout: string;
    stderr: string;
  };
}

export interface VmSafeInterface extends utils.Interface {
  functions: {
    "accesses(address)": FunctionFragment;
    "addr(uint256)": FunctionFragment;
    "assertApproxEqAbs(uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbs(int256,int256,uint256)": FunctionFragment;
    "assertApproxEqAbs(int256,int256,uint256,string)": FunctionFragment;
    "assertApproxEqAbs(uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRel(int256,int256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(int256,int256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)": FunctionFragment;
    "assertEq(bytes32[],bytes32[])": FunctionFragment;
    "assertEq(int256[],int256[],string)": FunctionFragment;
    "assertEq(address,address,string)": FunctionFragment;
    "assertEq(string,string,string)": FunctionFragment;
    "assertEq(address[],address[])": FunctionFragment;
    "assertEq(address[],address[],string)": FunctionFragment;
    "assertEq(bool,bool,string)": FunctionFragment;
    "assertEq(address,address)": FunctionFragment;
    "assertEq(uint256[],uint256[],string)": FunctionFragment;
    "assertEq(bool[],bool[])": FunctionFragment;
    "assertEq(int256[],int256[])": FunctionFragment;
    "assertEq(int256,int256,string)": FunctionFragment;
    "assertEq(bytes32,bytes32)": FunctionFragment;
    "assertEq(uint256,uint256,string)": FunctionFragment;
    "assertEq(uint256[],uint256[])": FunctionFragment;
    "assertEq(bytes,bytes)": FunctionFragment;
    "assertEq(uint256,uint256)": FunctionFragment;
    "assertEq(bytes32,bytes32,string)": FunctionFragment;
    "assertEq(string[],string[])": FunctionFragment;
    "assertEq(bytes32[],bytes32[],string)": FunctionFragment;
    "assertEq(bytes,bytes,string)": FunctionFragment;
    "assertEq(bool[],bool[],string)": FunctionFragment;
    "assertEq(bytes[],bytes[])": FunctionFragment;
    "assertEq(string[],string[],string)": FunctionFragment;
    "assertEq(string,string)": FunctionFragment;
    "assertEq(bytes[],bytes[],string)": FunctionFragment;
    "assertEq(bool,bool)": FunctionFragment;
    "assertEq(int256,int256)": FunctionFragment;
    "assertEqDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertEqDecimal(int256,int256,uint256)": FunctionFragment;
    "assertEqDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertEqDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertFalse(bool,string)": FunctionFragment;
    "assertFalse(bool)": FunctionFragment;
    "assertGe(int256,int256)": FunctionFragment;
    "assertGe(int256,int256,string)": FunctionFragment;
    "assertGe(uint256,uint256)": FunctionFragment;
    "assertGe(uint256,uint256,string)": FunctionFragment;
    "assertGeDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertGeDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertGeDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertGeDecimal(int256,int256,uint256)": FunctionFragment;
    "assertGt(int256,int256)": FunctionFragment;
    "assertGt(uint256,uint256,string)": FunctionFragment;
    "assertGt(uint256,uint256)": FunctionFragment;
    "assertGt(int256,int256,string)": FunctionFragment;
    "assertGtDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertGtDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertGtDecimal(int256,int256,uint256)": FunctionFragment;
    "assertGtDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLe(int256,int256,string)": FunctionFragment;
    "assertLe(uint256,uint256)": FunctionFragment;
    "assertLe(int256,int256)": FunctionFragment;
    "assertLe(uint256,uint256,string)": FunctionFragment;
    "assertLeDecimal(int256,int256,uint256)": FunctionFragment;
    "assertLeDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertLeDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertLeDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLt(int256,int256)": FunctionFragment;
    "assertLt(uint256,uint256,string)": FunctionFragment;
    "assertLt(int256,int256,string)": FunctionFragment;
    "assertLt(uint256,uint256)": FunctionFragment;
    "assertLtDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLtDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertLtDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertLtDecimal(int256,int256,uint256)": FunctionFragment;
    "assertNotEq(bytes32[],bytes32[])": FunctionFragment;
    "assertNotEq(int256[],int256[])": FunctionFragment;
    "assertNotEq(bool,bool,string)": FunctionFragment;
    "assertNotEq(bytes[],bytes[],string)": FunctionFragment;
    "assertNotEq(bool,bool)": FunctionFragment;
    "assertNotEq(bool[],bool[])": FunctionFragment;
    "assertNotEq(bytes,bytes)": FunctionFragment;
    "assertNotEq(address[],address[])": FunctionFragment;
    "assertNotEq(int256,int256,string)": FunctionFragment;
    "assertNotEq(uint256[],uint256[])": FunctionFragment;
    "assertNotEq(bool[],bool[],string)": FunctionFragment;
    "assertNotEq(string,string)": FunctionFragment;
    "assertNotEq(address[],address[],string)": FunctionFragment;
    "assertNotEq(string,string,string)": FunctionFragment;
    "assertNotEq(address,address,string)": FunctionFragment;
    "assertNotEq(bytes32,bytes32)": FunctionFragment;
    "assertNotEq(bytes,bytes,string)": FunctionFragment;
    "assertNotEq(uint256,uint256,string)": FunctionFragment;
    "assertNotEq(uint256[],uint256[],string)": FunctionFragment;
    "assertNotEq(address,address)": FunctionFragment;
    "assertNotEq(bytes32,bytes32,string)": FunctionFragment;
    "assertNotEq(string[],string[],string)": FunctionFragment;
    "assertNotEq(uint256,uint256)": FunctionFragment;
    "assertNotEq(bytes32[],bytes32[],string)": FunctionFragment;
    "assertNotEq(string[],string[])": FunctionFragment;
    "assertNotEq(int256[],int256[],string)": FunctionFragment;
    "assertNotEq(bytes[],bytes[])": FunctionFragment;
    "assertNotEq(int256,int256)": FunctionFragment;
    "assertNotEqDecimal(int256,int256,uint256)": FunctionFragment;
    "assertNotEqDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertNotEqDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertNotEqDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertTrue(bool)": FunctionFragment;
    "assertTrue(bool,string)": FunctionFragment;
    "assume(bool)": FunctionFragment;
    "breakpoint(string)": FunctionFragment;
    "breakpoint(string,bool)": FunctionFragment;
    "broadcast()": FunctionFragment;
    "broadcast(address)": FunctionFragment;
    "broadcast(uint256)": FunctionFragment;
    "closeFile(string)": FunctionFragment;
    "computeCreate2Address(bytes32,bytes32)": FunctionFragment;
    "computeCreate2Address(bytes32,bytes32,address)": FunctionFragment;
    "computeCreateAddress(address,uint256)": FunctionFragment;
    "copyFile(string,string)": FunctionFragment;
    "createDir(string,bool)": FunctionFragment;
    "createWallet(string)": FunctionFragment;
    "createWallet(uint256)": FunctionFragment;
    "createWallet(uint256,string)": FunctionFragment;
    "deriveKey(string,string,uint32,string)": FunctionFragment;
    "deriveKey(string,uint32,string)": FunctionFragment;
    "deriveKey(string,uint32)": FunctionFragment;
    "deriveKey(string,string,uint32)": FunctionFragment;
    "envAddress(string)": FunctionFragment;
    "envAddress(string,string)": FunctionFragment;
    "envBool(string)": FunctionFragment;
    "envBool(string,string)": FunctionFragment;
    "envBytes(string)": FunctionFragment;
    "envBytes(string,string)": FunctionFragment;
    "envBytes32(string,string)": FunctionFragment;
    "envBytes32(string)": FunctionFragment;
    "envExists(string)": FunctionFragment;
    "envInt(string,string)": FunctionFragment;
    "envInt(string)": FunctionFragment;
    "envOr(string,string,bytes32[])": FunctionFragment;
    "envOr(string,string,int256[])": FunctionFragment;
    "envOr(string,bool)": FunctionFragment;
    "envOr(string,address)": FunctionFragment;
    "envOr(string,uint256)": FunctionFragment;
    "envOr(string,string,bytes[])": FunctionFragment;
    "envOr(string,string,uint256[])": FunctionFragment;
    "envOr(string,string,string[])": FunctionFragment;
    "envOr(string,bytes)": FunctionFragment;
    "envOr(string,bytes32)": FunctionFragment;
    "envOr(string,int256)": FunctionFragment;
    "envOr(string,string,address[])": FunctionFragment;
    "envOr(string,string)": FunctionFragment;
    "envOr(string,string,bool[])": FunctionFragment;
    "envString(string,string)": FunctionFragment;
    "envString(string)": FunctionFragment;
    "envUint(string)": FunctionFragment;
    "envUint(string,string)": FunctionFragment;
    "eth_getLogs(uint256,uint256,address,bytes32[])": FunctionFragment;
    "exists(string)": FunctionFragment;
    "ffi(string[])": FunctionFragment;
    "fsMetadata(string)": FunctionFragment;
    "getBlobBaseFee()": FunctionFragment;
    "getBlockNumber()": FunctionFragment;
    "getBlockTimestamp()": FunctionFragment;
    "getCode(string)": FunctionFragment;
    "getDeployedCode(string)": FunctionFragment;
    "getLabel(address)": FunctionFragment;
    "getMappingKeyAndParentOf(address,bytes32)": FunctionFragment;
    "getMappingLength(address,bytes32)": FunctionFragment;
    "getMappingSlotAt(address,bytes32,uint256)": FunctionFragment;
    "getNonce(address)": FunctionFragment;
    "getNonce((address,uint256,uint256,uint256))": FunctionFragment;
    "getRecordedLogs()": FunctionFragment;
    "indexOf(string,string)": FunctionFragment;
    "isContext(uint8)": FunctionFragment;
    "isDir(string)": FunctionFragment;
    "isFile(string)": FunctionFragment;
    "keyExists(string,string)": FunctionFragment;
    "keyExistsJson(string,string)": FunctionFragment;
    "keyExistsToml(string,string)": FunctionFragment;
    "label(address,string)": FunctionFragment;
    "lastCallGas()": FunctionFragment;
    "load(address,bytes32)": FunctionFragment;
    "parseAddress(string)": FunctionFragment;
    "parseBool(string)": FunctionFragment;
    "parseBytes(string)": FunctionFragment;
    "parseBytes32(string)": FunctionFragment;
    "parseInt(string)": FunctionFragment;
    "parseJson(string)": FunctionFragment;
    "parseJson(string,string)": FunctionFragment;
    "parseJsonAddress(string,string)": FunctionFragment;
    "parseJsonAddressArray(string,string)": FunctionFragment;
    "parseJsonBool(string,string)": FunctionFragment;
    "parseJsonBoolArray(string,string)": FunctionFragment;
    "parseJsonBytes(string,string)": FunctionFragment;
    "parseJsonBytes32(string,string)": FunctionFragment;
    "parseJsonBytes32Array(string,string)": FunctionFragment;
    "parseJsonBytesArray(string,string)": FunctionFragment;
    "parseJsonInt(string,string)": FunctionFragment;
    "parseJsonIntArray(string,string)": FunctionFragment;
    "parseJsonKeys(string,string)": FunctionFragment;
    "parseJsonString(string,string)": FunctionFragment;
    "parseJsonStringArray(string,string)": FunctionFragment;
    "parseJsonUint(string,string)": FunctionFragment;
    "parseJsonUintArray(string,string)": FunctionFragment;
    "parseToml(string,string)": FunctionFragment;
    "parseToml(string)": FunctionFragment;
    "parseTomlAddress(string,string)": FunctionFragment;
    "parseTomlAddressArray(string,string)": FunctionFragment;
    "parseTomlBool(string,string)": FunctionFragment;
    "parseTomlBoolArray(string,string)": FunctionFragment;
    "parseTomlBytes(string,string)": FunctionFragment;
    "parseTomlBytes32(string,string)": FunctionFragment;
    "parseTomlBytes32Array(string,string)": FunctionFragment;
    "parseTomlBytesArray(string,string)": FunctionFragment;
    "parseTomlInt(string,string)": FunctionFragment;
    "parseTomlIntArray(string,string)": FunctionFragment;
    "parseTomlKeys(string,string)": FunctionFragment;
    "parseTomlString(string,string)": FunctionFragment;
    "parseTomlStringArray(string,string)": FunctionFragment;
    "parseTomlUint(string,string)": FunctionFragment;
    "parseTomlUintArray(string,string)": FunctionFragment;
    "parseUint(string)": FunctionFragment;
    "pauseGasMetering()": FunctionFragment;
    "projectRoot()": FunctionFragment;
    "prompt(string)": FunctionFragment;
    "promptAddress(string)": FunctionFragment;
    "promptSecret(string)": FunctionFragment;
    "promptUint(string)": FunctionFragment;
    "readDir(string,uint64)": FunctionFragment;
    "readDir(string,uint64,bool)": FunctionFragment;
    "readDir(string)": FunctionFragment;
    "readFile(string)": FunctionFragment;
    "readFileBinary(string)": FunctionFragment;
    "readLine(string)": FunctionFragment;
    "readLink(string)": FunctionFragment;
    "record()": FunctionFragment;
    "recordLogs()": FunctionFragment;
    "rememberKey(uint256)": FunctionFragment;
    "removeDir(string,bool)": FunctionFragment;
    "removeFile(string)": FunctionFragment;
    "replace(string,string,string)": FunctionFragment;
    "resumeGasMetering()": FunctionFragment;
    "rpc(string,string)": FunctionFragment;
    "rpcUrl(string)": FunctionFragment;
    "rpcUrlStructs()": FunctionFragment;
    "rpcUrls()": FunctionFragment;
    "serializeAddress(string,string,address[])": FunctionFragment;
    "serializeAddress(string,string,address)": FunctionFragment;
    "serializeBool(string,string,bool[])": FunctionFragment;
    "serializeBool(string,string,bool)": FunctionFragment;
    "serializeBytes(string,string,bytes[])": FunctionFragment;
    "serializeBytes(string,string,bytes)": FunctionFragment;
    "serializeBytes32(string,string,bytes32[])": FunctionFragment;
    "serializeBytes32(string,string,bytes32)": FunctionFragment;
    "serializeInt(string,string,int256)": FunctionFragment;
    "serializeInt(string,string,int256[])": FunctionFragment;
    "serializeJson(string,string)": FunctionFragment;
    "serializeString(string,string,string[])": FunctionFragment;
    "serializeString(string,string,string)": FunctionFragment;
    "serializeUint(string,string,uint256)": FunctionFragment;
    "serializeUint(string,string,uint256[])": FunctionFragment;
    "serializeUintToHex(string,string,uint256)": FunctionFragment;
    "setEnv(string,string)": FunctionFragment;
    "sign(bytes32)": FunctionFragment;
    "sign(address,bytes32)": FunctionFragment;
    "sign((address,uint256,uint256,uint256),bytes32)": FunctionFragment;
    "sign(uint256,bytes32)": FunctionFragment;
    "signP256(uint256,bytes32)": FunctionFragment;
    "sleep(uint256)": FunctionFragment;
    "split(string,string)": FunctionFragment;
    "startBroadcast()": FunctionFragment;
    "startBroadcast(address)": FunctionFragment;
    "startBroadcast(uint256)": FunctionFragment;
    "startMappingRecording()": FunctionFragment;
    "startStateDiffRecording()": FunctionFragment;
    "stopAndReturnStateDiff()": FunctionFragment;
    "stopBroadcast()": FunctionFragment;
    "stopMappingRecording()": FunctionFragment;
    "toBase64(string)": FunctionFragment;
    "toBase64(bytes)": FunctionFragment;
    "toBase64URL(string)": FunctionFragment;
    "toBase64URL(bytes)": FunctionFragment;
    "toLowercase(string)": FunctionFragment;
    "toString(address)": FunctionFragment;
    "toString(uint256)": FunctionFragment;
    "toString(bytes)": FunctionFragment;
    "toString(bool)": FunctionFragment;
    "toString(int256)": FunctionFragment;
    "toString(bytes32)": FunctionFragment;
    "toUppercase(string)": FunctionFragment;
    "trim(string)": FunctionFragment;
    "tryFfi(string[])": FunctionFragment;
    "unixTime()": FunctionFragment;
    "writeFile(string,string)": FunctionFragment;
    "writeFileBinary(string,bytes)": FunctionFragment;
    "writeJson(string,string,string)": FunctionFragment;
    "writeJson(string,string)": FunctionFragment;
    "writeLine(string,string)": FunctionFragment;
    "writeToml(string,string,string)": FunctionFragment;
    "writeToml(string,string)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "accesses"
      | "addr"
      | "assertApproxEqAbs(uint256,uint256,uint256)"
      | "assertApproxEqAbs(int256,int256,uint256)"
      | "assertApproxEqAbs(int256,int256,uint256,string)"
      | "assertApproxEqAbs(uint256,uint256,uint256,string)"
      | "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"
      | "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"
      | "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"
      | "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"
      | "assertApproxEqRel(uint256,uint256,uint256,string)"
      | "assertApproxEqRel(uint256,uint256,uint256)"
      | "assertApproxEqRel(int256,int256,uint256,string)"
      | "assertApproxEqRel(int256,int256,uint256)"
      | "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"
      | "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"
      | "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"
      | "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"
      | "assertEq(bytes32[],bytes32[])"
      | "assertEq(int256[],int256[],string)"
      | "assertEq(address,address,string)"
      | "assertEq(string,string,string)"
      | "assertEq(address[],address[])"
      | "assertEq(address[],address[],string)"
      | "assertEq(bool,bool,string)"
      | "assertEq(address,address)"
      | "assertEq(uint256[],uint256[],string)"
      | "assertEq(bool[],bool[])"
      | "assertEq(int256[],int256[])"
      | "assertEq(int256,int256,string)"
      | "assertEq(bytes32,bytes32)"
      | "assertEq(uint256,uint256,string)"
      | "assertEq(uint256[],uint256[])"
      | "assertEq(bytes,bytes)"
      | "assertEq(uint256,uint256)"
      | "assertEq(bytes32,bytes32,string)"
      | "assertEq(string[],string[])"
      | "assertEq(bytes32[],bytes32[],string)"
      | "assertEq(bytes,bytes,string)"
      | "assertEq(bool[],bool[],string)"
      | "assertEq(bytes[],bytes[])"
      | "assertEq(string[],string[],string)"
      | "assertEq(string,string)"
      | "assertEq(bytes[],bytes[],string)"
      | "assertEq(bool,bool)"
      | "assertEq(int256,int256)"
      | "assertEqDecimal(uint256,uint256,uint256)"
      | "assertEqDecimal(int256,int256,uint256)"
      | "assertEqDecimal(int256,int256,uint256,string)"
      | "assertEqDecimal(uint256,uint256,uint256,string)"
      | "assertFalse(bool,string)"
      | "assertFalse(bool)"
      | "assertGe(int256,int256)"
      | "assertGe(int256,int256,string)"
      | "assertGe(uint256,uint256)"
      | "assertGe(uint256,uint256,string)"
      | "assertGeDecimal(uint256,uint256,uint256)"
      | "assertGeDecimal(int256,int256,uint256,string)"
      | "assertGeDecimal(uint256,uint256,uint256,string)"
      | "assertGeDecimal(int256,int256,uint256)"
      | "assertGt(int256,int256)"
      | "assertGt(uint256,uint256,string)"
      | "assertGt(uint256,uint256)"
      | "assertGt(int256,int256,string)"
      | "assertGtDecimal(int256,int256,uint256,string)"
      | "assertGtDecimal(uint256,uint256,uint256,string)"
      | "assertGtDecimal(int256,int256,uint256)"
      | "assertGtDecimal(uint256,uint256,uint256)"
      | "assertLe(int256,int256,string)"
      | "assertLe(uint256,uint256)"
      | "assertLe(int256,int256)"
      | "assertLe(uint256,uint256,string)"
      | "assertLeDecimal(int256,int256,uint256)"
      | "assertLeDecimal(uint256,uint256,uint256,string)"
      | "assertLeDecimal(int256,int256,uint256,string)"
      | "assertLeDecimal(uint256,uint256,uint256)"
      | "assertLt(int256,int256)"
      | "assertLt(uint256,uint256,string)"
      | "assertLt(int256,int256,string)"
      | "assertLt(uint256,uint256)"
      | "assertLtDecimal(uint256,uint256,uint256)"
      | "assertLtDecimal(int256,int256,uint256,string)"
      | "assertLtDecimal(uint256,uint256,uint256,string)"
      | "assertLtDecimal(int256,int256,uint256)"
      | "assertNotEq(bytes32[],bytes32[])"
      | "assertNotEq(int256[],int256[])"
      | "assertNotEq(bool,bool,string)"
      | "assertNotEq(bytes[],bytes[],string)"
      | "assertNotEq(bool,bool)"
      | "assertNotEq(bool[],bool[])"
      | "assertNotEq(bytes,bytes)"
      | "assertNotEq(address[],address[])"
      | "assertNotEq(int256,int256,string)"
      | "assertNotEq(uint256[],uint256[])"
      | "assertNotEq(bool[],bool[],string)"
      | "assertNotEq(string,string)"
      | "assertNotEq(address[],address[],string)"
      | "assertNotEq(string,string,string)"
      | "assertNotEq(address,address,string)"
      | "assertNotEq(bytes32,bytes32)"
      | "assertNotEq(bytes,bytes,string)"
      | "assertNotEq(uint256,uint256,string)"
      | "assertNotEq(uint256[],uint256[],string)"
      | "assertNotEq(address,address)"
      | "assertNotEq(bytes32,bytes32,string)"
      | "assertNotEq(string[],string[],string)"
      | "assertNotEq(uint256,uint256)"
      | "assertNotEq(bytes32[],bytes32[],string)"
      | "assertNotEq(string[],string[])"
      | "assertNotEq(int256[],int256[],string)"
      | "assertNotEq(bytes[],bytes[])"
      | "assertNotEq(int256,int256)"
      | "assertNotEqDecimal(int256,int256,uint256)"
      | "assertNotEqDecimal(int256,int256,uint256,string)"
      | "assertNotEqDecimal(uint256,uint256,uint256)"
      | "assertNotEqDecimal(uint256,uint256,uint256,string)"
      | "assertTrue(bool)"
      | "assertTrue(bool,string)"
      | "assume"
      | "breakpoint(string)"
      | "breakpoint(string,bool)"
      | "broadcast()"
      | "broadcast(address)"
      | "broadcast(uint256)"
      | "closeFile"
      | "computeCreate2Address(bytes32,bytes32)"
      | "computeCreate2Address(bytes32,bytes32,address)"
      | "computeCreateAddress"
      | "copyFile"
      | "createDir"
      | "createWallet(string)"
      | "createWallet(uint256)"
      | "createWallet(uint256,string)"
      | "deriveKey(string,string,uint32,string)"
      | "deriveKey(string,uint32,string)"
      | "deriveKey(string,uint32)"
      | "deriveKey(string,string,uint32)"
      | "envAddress(string)"
      | "envAddress(string,string)"
      | "envBool(string)"
      | "envBool(string,string)"
      | "envBytes(string)"
      | "envBytes(string,string)"
      | "envBytes32(string,string)"
      | "envBytes32(string)"
      | "envExists"
      | "envInt(string,string)"
      | "envInt(string)"
      | "envOr(string,string,bytes32[])"
      | "envOr(string,string,int256[])"
      | "envOr(string,bool)"
      | "envOr(string,address)"
      | "envOr(string,uint256)"
      | "envOr(string,string,bytes[])"
      | "envOr(string,string,uint256[])"
      | "envOr(string,string,string[])"
      | "envOr(string,bytes)"
      | "envOr(string,bytes32)"
      | "envOr(string,int256)"
      | "envOr(string,string,address[])"
      | "envOr(string,string)"
      | "envOr(string,string,bool[])"
      | "envString(string,string)"
      | "envString(string)"
      | "envUint(string)"
      | "envUint(string,string)"
      | "eth_getLogs"
      | "exists"
      | "ffi"
      | "fsMetadata"
      | "getBlobBaseFee"
      | "getBlockNumber"
      | "getBlockTimestamp"
      | "getCode"
      | "getDeployedCode"
      | "getLabel"
      | "getMappingKeyAndParentOf"
      | "getMappingLength"
      | "getMappingSlotAt"
      | "getNonce(address)"
      | "getNonce((address,uint256,uint256,uint256))"
      | "getRecordedLogs"
      | "indexOf"
      | "isContext"
      | "isDir"
      | "isFile"
      | "keyExists"
      | "keyExistsJson"
      | "keyExistsToml"
      | "label"
      | "lastCallGas"
      | "load"
      | "parseAddress"
      | "parseBool"
      | "parseBytes"
      | "parseBytes32"
      | "parseInt"
      | "parseJson(string)"
      | "parseJson(string,string)"
      | "parseJsonAddress"
      | "parseJsonAddressArray"
      | "parseJsonBool"
      | "parseJsonBoolArray"
      | "parseJsonBytes"
      | "parseJsonBytes32"
      | "parseJsonBytes32Array"
      | "parseJsonBytesArray"
      | "parseJsonInt"
      | "parseJsonIntArray"
      | "parseJsonKeys"
      | "parseJsonString"
      | "parseJsonStringArray"
      | "parseJsonUint"
      | "parseJsonUintArray"
      | "parseToml(string,string)"
      | "parseToml(string)"
      | "parseTomlAddress"
      | "parseTomlAddressArray"
      | "parseTomlBool"
      | "parseTomlBoolArray"
      | "parseTomlBytes"
      | "parseTomlBytes32"
      | "parseTomlBytes32Array"
      | "parseTomlBytesArray"
      | "parseTomlInt"
      | "parseTomlIntArray"
      | "parseTomlKeys"
      | "parseTomlString"
      | "parseTomlStringArray"
      | "parseTomlUint"
      | "parseTomlUintArray"
      | "parseUint"
      | "pauseGasMetering"
      | "projectRoot"
      | "prompt"
      | "promptAddress"
      | "promptSecret"
      | "promptUint"
      | "readDir(string,uint64)"
      | "readDir(string,uint64,bool)"
      | "readDir(string)"
      | "readFile"
      | "readFileBinary"
      | "readLine"
      | "readLink"
      | "record"
      | "recordLogs"
      | "rememberKey"
      | "removeDir"
      | "removeFile"
      | "replace"
      | "resumeGasMetering"
      | "rpc"
      | "rpcUrl"
      | "rpcUrlStructs"
      | "rpcUrls"
      | "serializeAddress(string,string,address[])"
      | "serializeAddress(string,string,address)"
      | "serializeBool(string,string,bool[])"
      | "serializeBool(string,string,bool)"
      | "serializeBytes(string,string,bytes[])"
      | "serializeBytes(string,string,bytes)"
      | "serializeBytes32(string,string,bytes32[])"
      | "serializeBytes32(string,string,bytes32)"
      | "serializeInt(string,string,int256)"
      | "serializeInt(string,string,int256[])"
      | "serializeJson"
      | "serializeString(string,string,string[])"
      | "serializeString(string,string,string)"
      | "serializeUint(string,string,uint256)"
      | "serializeUint(string,string,uint256[])"
      | "serializeUintToHex"
      | "setEnv"
      | "sign(bytes32)"
      | "sign(address,bytes32)"
      | "sign((address,uint256,uint256,uint256),bytes32)"
      | "sign(uint256,bytes32)"
      | "signP256"
      | "sleep"
      | "split"
      | "startBroadcast()"
      | "startBroadcast(address)"
      | "startBroadcast(uint256)"
      | "startMappingRecording"
      | "startStateDiffRecording"
      | "stopAndReturnStateDiff"
      | "stopBroadcast"
      | "stopMappingRecording"
      | "toBase64(string)"
      | "toBase64(bytes)"
      | "toBase64URL(string)"
      | "toBase64URL(bytes)"
      | "toLowercase"
      | "toString(address)"
      | "toString(uint256)"
      | "toString(bytes)"
      | "toString(bool)"
      | "toString(int256)"
      | "toString(bytes32)"
      | "toUppercase"
      | "trim"
      | "tryFfi"
      | "unixTime"
      | "writeFile"
      | "writeFileBinary"
      | "writeJson(string,string,string)"
      | "writeJson(string,string)"
      | "writeLine"
      | "writeToml(string,string,string)"
      | "writeToml(string,string)"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "accesses", values: [string]): string;
  encodeFunctionData(functionFragment: "addr", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32[],bytes32[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256[],int256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address,address,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address[],address[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address[],address[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool,bool,string)",
    values: [boolean, boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256[],uint256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool[],bool[])",
    values: [boolean[], boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256[],int256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256[],uint256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32,bytes32,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string[],string[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32[],bytes32[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes,bytes,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool[],bool[],string)",
    values: [boolean[], boolean[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes[],bytes[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string[],string[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes[],bytes[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool,bool)",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertFalse(bool,string)",
    values: [boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertFalse(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32[],bytes32[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256[],int256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool,bool,string)",
    values: [boolean, boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes[],bytes[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool,bool)",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool[],bool[])",
    values: [boolean[], boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address[],address[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256[],uint256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool[],bool[],string)",
    values: [boolean[], boolean[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address[],address[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address,address,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes,bytes,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256[],uint256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32,bytes32,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string[],string[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32[],bytes32[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string[],string[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256[],int256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes[],bytes[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertTrue(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertTrue(bool,string)",
    values: [boolean, string]
  ): string;
  encodeFunctionData(functionFragment: "assume", values: [boolean]): string;
  encodeFunctionData(
    functionFragment: "breakpoint(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "breakpoint(string,bool)",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "closeFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "computeCreate2Address(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "computeCreate2Address(bytes32,bytes32,address)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "computeCreateAddress",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "copyFile",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "createDir",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(uint256,string)",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,string,uint32,string)",
    values: [string, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,uint32,string)",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,uint32)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,string,uint32)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "envAddress(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envAddress(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBool(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBool(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes32(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes32(string)",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "envExists", values: [string]): string;
  encodeFunctionData(
    functionFragment: "envInt(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envInt(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bytes32[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,int256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bool)",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bytes[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,uint256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,string[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bytes)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,int256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,address[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bool[])",
    values: [string, string, boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envString(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envString(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envUint(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envUint(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "eth_getLogs",
    values: [BigNumberish, BigNumberish, string, BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "exists", values: [string]): string;
  encodeFunctionData(functionFragment: "ffi", values: [string[]]): string;
  encodeFunctionData(functionFragment: "fsMetadata", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getBlobBaseFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getCode", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getDeployedCode",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getLabel", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getMappingKeyAndParentOf",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMappingLength",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMappingSlotAt",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonce(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonce((address,uint256,uint256,uint256))",
    values: [VmSafe.WalletStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getRecordedLogs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "indexOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isContext",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "isDir", values: [string]): string;
  encodeFunctionData(functionFragment: "isFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "keyExists",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyExistsJson",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyExistsToml",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "label",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "lastCallGas",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "load",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "parseAddress",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "parseBool", values: [string]): string;
  encodeFunctionData(functionFragment: "parseBytes", values: [string]): string;
  encodeFunctionData(
    functionFragment: "parseBytes32",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "parseInt", values: [string]): string;
  encodeFunctionData(
    functionFragment: "parseJson(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJson(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonAddressArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBool",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBoolArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes32",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes32Array",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytesArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonInt",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonIntArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonKeys",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonString",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonStringArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonUint",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonUintArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseToml(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseToml(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlAddressArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBool",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBoolArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes32",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes32Array",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytesArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlInt",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlIntArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlKeys",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlString",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlStringArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlUint",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlUintArray",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "parseUint", values: [string]): string;
  encodeFunctionData(
    functionFragment: "pauseGasMetering",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "projectRoot",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "prompt", values: [string]): string;
  encodeFunctionData(
    functionFragment: "promptAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "promptSecret",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "promptUint", values: [string]): string;
  encodeFunctionData(
    functionFragment: "readDir(string,uint64)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readDir(string,uint64,bool)",
    values: [string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "readDir(string)",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "readFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "readFileBinary",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "readLine", values: [string]): string;
  encodeFunctionData(functionFragment: "readLink", values: [string]): string;
  encodeFunctionData(functionFragment: "record", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recordLogs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rememberKey",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeDir",
    values: [string, boolean]
  ): string;
  encodeFunctionData(functionFragment: "removeFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "replace",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "resumeGasMetering",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rpc", values: [string, string]): string;
  encodeFunctionData(functionFragment: "rpcUrl", values: [string]): string;
  encodeFunctionData(
    functionFragment: "rpcUrlStructs",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rpcUrls", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "serializeAddress(string,string,address[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeAddress(string,string,address)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBool(string,string,bool[])",
    values: [string, string, boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBool(string,string,bool)",
    values: [string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes(string,string,bytes[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes(string,string,bytes)",
    values: [string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes32(string,string,bytes32[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes32(string,string,bytes32)",
    values: [string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeInt(string,string,int256)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeInt(string,string,int256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeJson",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeString(string,string,string[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeString(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUint(string,string,uint256)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUint(string,string,uint256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUintToHex",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setEnv",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(address,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign((address,uint256,uint256,uint256),bytes32)",
    values: [VmSafe.WalletStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(uint256,bytes32)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "signP256",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "sleep", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "split",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "startMappingRecording",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startStateDiffRecording",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopAndReturnStateDiff",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopBroadcast",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopMappingRecording",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64URL(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64URL(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "toLowercase", values: [string]): string;
  encodeFunctionData(
    functionFragment: "toString(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(int256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "toUppercase", values: [string]): string;
  encodeFunctionData(functionFragment: "trim", values: [string]): string;
  encodeFunctionData(functionFragment: "tryFfi", values: [string[]]): string;
  encodeFunctionData(functionFragment: "unixTime", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "writeFile",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeFileBinary",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "writeJson(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeJson(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeLine",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeToml(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeToml(string,string)",
    values: [string, string]
  ): string;

  decodeFunctionResult(functionFragment: "accesses", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addr", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32[],bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256[],int256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address,address,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address[],address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address[],address[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool,bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256[],uint256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool[],bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256[],int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256[],uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32,bytes32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string[],string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32[],bytes32[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes,bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool[],bool[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes[],bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string[],string[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes[],bytes[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertFalse(bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertFalse(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32[],bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256[],int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool,bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes[],bytes[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool[],bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address[],address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256[],uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool[],bool[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address[],address[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address,address,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes,bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256[],uint256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32,bytes32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string[],string[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32[],bytes32[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string[],string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256[],int256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes[],bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertTrue(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertTrue(bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assume", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "breakpoint(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "breakpoint(string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "closeFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "computeCreate2Address(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "computeCreate2Address(bytes32,bytes32,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "computeCreateAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "copyFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createDir", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,string,uint32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,uint32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,string,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envAddress(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envAddress(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBool(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBool(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes32(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes32(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "envExists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "envInt(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envInt(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envString(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envString(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envUint(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envUint(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eth_getLogs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "exists", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ffi", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fsMetadata", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBlobBaseFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCode", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeployedCode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getLabel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMappingKeyAndParentOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMappingLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMappingSlotAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonce(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonce((address,uint256,uint256,uint256))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRecordedLogs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "indexOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isContext", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isDir", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "keyExists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "keyExistsJson",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "keyExistsToml",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "label", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastCallGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "load", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parseAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseBool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "parseBytes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parseBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseInt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parseJson(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJson(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonAddressArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBoolArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes32Array",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytesArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonInt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonIntArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonStringArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonUint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonUintArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseToml(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseToml(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlAddressArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBoolArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes32Array",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytesArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlInt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlIntArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlStringArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlUint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlUintArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseUint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pauseGasMetering",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "projectRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "prompt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "promptAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "promptSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "promptUint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string,uint64,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "readFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "readFileBinary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "readLine", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "readLink", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "record", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "recordLogs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rememberKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "removeDir", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "replace", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resumeGasMetering",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rpc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rpcUrl", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rpcUrlStructs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rpcUrls", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "serializeAddress(string,string,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeAddress(string,string,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBool(string,string,bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBool(string,string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes(string,string,bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes(string,string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes32(string,string,bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes32(string,string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeInt(string,string,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeInt(string,string,int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeJson",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeString(string,string,string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeString(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUint(string,string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUint(string,string,uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUintToHex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setEnv", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sign(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign(address,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign((address,uint256,uint256,uint256),bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign(uint256,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "signP256", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sleep", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "split", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startMappingRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startStateDiffRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopAndReturnStateDiff",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopBroadcast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopMappingRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64URL(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64URL(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toLowercase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toUppercase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "trim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tryFfi", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unixTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "writeFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "writeFileBinary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeJson(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeJson(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "writeLine", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "writeToml(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeToml(string,string)",
    data: BytesLike
  ): Result;

  events: {};
}

export interface VmSafe extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VmSafeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { keyAddr: string }>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<[void]>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { value: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]] & { value: boolean[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(
      name: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<[boolean] & { value: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<[boolean[]] & { value: boolean[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.FsMetadataStructOutput] & {
        metadata: VmSafe.FsMetadataStructOutput;
      }
    >;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blobBaseFee: BigNumber }>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { height: BigNumber }>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { timestamp: BigNumber }>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { creationBytecode: string }>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { runtimeBytecode: string }>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(
      account: string,
      overrides?: CallOverrides
    ): Promise<[string] & { currentLabel: string }>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(
      overrides?: CallOverrides
    ): Promise<[VmSafe.GasStructOutput] & { gas: VmSafe.GasStructOutput }>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { parsedValue: boolean }>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { parsedValue: BigNumber }>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { keys: string[] }>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { keys: string[] }>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { parsedValue: BigNumber }>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(
      overrides?: CallOverrides
    ): Promise<[string] & { path: string }>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Reads next line of file to string.
     */
    readLine(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { line: string }>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(
      linkPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { targetPath: string }>;

    /**
     * Records all storage reads and writes.
     */
    record(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(
      rpcAlias: string,
      overrides?: CallOverrides
    ): Promise<[string] & { json: string }>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(
      overrides?: CallOverrides
    ): Promise<[VmSafe.RpcStructOutput[]] & { urls: VmSafe.RpcStructOutput[] }>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(
      overrides?: CallOverrides
    ): Promise<[[string, string][]] & { urls: [string, string][] }>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { r: string; s: string }>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { outputs: string[] }>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
   */
  accesses(
    target: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the address for a given private key.
   */
  addr(privateKey: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
   */
  "assertApproxEqAbs(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
   */
  "assertApproxEqAbs(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
   */
  "assertApproxEqAbs(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
   */
  "assertApproxEqAbs(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
   */
  "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
   */
  "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
   */
  "assertApproxEqRel(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
   */
  "assertApproxEqRel(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
   */
  "assertApproxEqRel(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
   */
  "assertApproxEqRel(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
   */
  "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
   */
  "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are equal.
   */
  "assertEq(bytes32[],bytes32[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(int256[],int256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are equal and includes error message into revert string on failure.
   */
  "assertEq(address,address,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are equal and includes error message into revert string on failure.
   */
  "assertEq(string,string,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are equal.
   */
  "assertEq(address[],address[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
   */
  "assertEq(address[],address[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bool,bool,string)"(
    left: boolean,
    right: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are equal.
   */
  "assertEq(address,address)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(uint256[],uint256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are equal.
   */
  "assertEq(bool[],bool[])"(
    left: boolean[],
    right: boolean[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are equal.
   */
  "assertEq(int256[],int256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are equal.
   */
  "assertEq(bytes32,bytes32)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256 values are equal.
   */
  "assertEq(uint256[],uint256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are equal.
   */
  "assertEq(bytes,bytes)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal.
   */
  "assertEq(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes32,bytes32,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are equal.
   */
  "assertEq(string[],string[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes32[],bytes32[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes,bytes,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bool[],bool[],string)"(
    left: boolean[],
    right: boolean[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are equal.
   */
  "assertEq(bytes[],bytes[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
   */
  "assertEq(string[],string[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are equal.
   */
  "assertEq(string,string)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes[],bytes[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are equal.
   */
  "assertEq(bool,bool)"(
    left: boolean,
    right: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal.
   */
  "assertEq(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
   */
  "assertEqDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
   */
  "assertEqDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertEqDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertEqDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is false and includes error message into revert string on failure.
   */
  "assertFalse(bool,string)"(
    condition: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is false.
   */
  "assertFalse(bool)"(
    condition: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second.
   */
  "assertGe(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
   */
  "assertGe(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second.
   */
  "assertGe(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
   */
  "assertGe(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
   */
  "assertGeDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGeDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGeDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
   */
  "assertGeDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second.
   */
  "assertGt(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
   */
  "assertGt(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second.
   */
  "assertGt(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
   */
  "assertGt(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGtDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGtDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
   */
  "assertGtDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
   */
  "assertGtDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
   */
  "assertLe(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second.
   */
  "assertLe(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second.
   */
  "assertLe(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
   */
  "assertLe(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
   */
  "assertLeDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLeDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLeDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
   */
  "assertLeDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second.
   */
  "assertLt(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
   */
  "assertLt(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
   */
  "assertLt(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second.
   */
  "assertLt(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
   */
  "assertLtDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLtDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLtDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
   */
  "assertLtDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are not equal.
   */
  "assertNotEq(bytes32[],bytes32[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are not equal.
   */
  "assertNotEq(int256[],int256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bool,bool,string)"(
    left: boolean,
    right: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes[],bytes[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are not equal.
   */
  "assertNotEq(bool,bool)"(
    left: boolean,
    right: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are not equal.
   */
  "assertNotEq(bool[],bool[])"(
    left: boolean[],
    right: boolean[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are not equal.
   */
  "assertNotEq(bytes,bytes)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are not equal.
   */
  "assertNotEq(address[],address[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are not equal.
   */
  "assertNotEq(uint256[],uint256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bool[],bool[],string)"(
    left: boolean[],
    right: boolean[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are not equal.
   */
  "assertNotEq(string,string)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(address[],address[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(string,string,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(address,address,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are not equal.
   */
  "assertNotEq(bytes32,bytes32)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes,bytes,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(uint256[],uint256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are not equal.
   */
  "assertNotEq(address,address)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes32,bytes32,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(string[],string[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal.
   */
  "assertNotEq(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes32[],bytes32[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are not equal.
   */
  "assertNotEq(string[],string[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(int256[],int256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are not equal.
   */
  "assertNotEq(bytes[],bytes[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal.
   */
  "assertNotEq(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
   */
  "assertNotEqDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertNotEqDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
   */
  "assertNotEqDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertNotEqDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is true.
   */
  "assertTrue(bool)"(
    condition: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is true and includes error message into revert string on failure.
   */
  "assertTrue(bool,string)"(
    condition: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * If the condition is false, discard this run's fuzz inputs and generate new ones.
   */
  assume(condition: boolean, overrides?: CallOverrides): Promise<void>;

  /**
   * Writes a breakpoint to jump to in the debugger.
   */
  "breakpoint(string)"(
    char: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes a conditional breakpoint to jump to in the debugger.
   */
  "breakpoint(string,bool)"(
    char: string,
    value: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
   */
  "broadcast()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
   */
  "broadcast(address)"(
    signer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
   */
  "broadcast(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
   */
  closeFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
   */
  "computeCreate2Address(bytes32,bytes32)"(
    salt: BytesLike,
    initCodeHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
   */
  "computeCreate2Address(bytes32,bytes32,address)"(
    salt: BytesLike,
    initCodeHash: BytesLike,
    deployer: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Compute the address a contract will be deployed at for a given deployer address and nonce.
   */
  computeCreateAddress(
    deployer: string,
    nonce: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
   */
  copyFile(
    from: string,
    to: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
   */
  createDir(
    path: string,
    recursive: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Derives a private key from the name, labels the account with that name, and returns the wallet.
   */
  "createWallet(string)"(
    walletLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Generates a wallet from the private key and returns the wallet.
   */
  "createWallet(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
   */
  "createWallet(uint256,string)"(
    privateKey: BigNumberish,
    walletLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
   */
  "deriveKey(string,string,uint32,string)"(
    mnemonic: string,
    derivationPath: string,
    index: BigNumberish,
    language: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
   */
  "deriveKey(string,uint32,string)"(
    mnemonic: string,
    index: BigNumberish,
    language: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
   */
  "deriveKey(string,uint32)"(
    mnemonic: string,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
   */
  "deriveKey(string,string,uint32)"(
    mnemonic: string,
    derivationPath: string,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
   */
  "envAddress(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envAddress(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
   */
  "envBool(string)"(name: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBool(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes(string)"(name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes32(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes32(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and returns true if it exists, else returns false.
   */
  envExists(name: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envInt(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
   */
  "envInt(string)"(name: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bytes32[])"(
    name: string,
    delim: string,
    defaultValue: BytesLike[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,int256[])"(
    name: string,
    delim: string,
    defaultValue: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bool)"(
    name: string,
    defaultValue: boolean,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,address)"(
    name: string,
    defaultValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,uint256)"(
    name: string,
    defaultValue: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bytes[])"(
    name: string,
    delim: string,
    defaultValue: BytesLike[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,uint256[])"(
    name: string,
    delim: string,
    defaultValue: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,string[])"(
    name: string,
    delim: string,
    defaultValue: string[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bytes)"(
    name: string,
    defaultValue: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bytes32)"(
    name: string,
    defaultValue: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,int256)"(
    name: string,
    defaultValue: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,address[])"(
    name: string,
    delim: string,
    defaultValue: string[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string)"(
    name: string,
    defaultValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bool[])"(
    name: string,
    delim: string,
    defaultValue: boolean[],
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envString(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
   */
  "envString(string)"(name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
   */
  "envUint(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envUint(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets all the logs according to specified filter.
   */
  eth_getLogs(
    fromBlock: BigNumberish,
    toBlock: BigNumberish,
    target: string,
    topics: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the given path points to an existing entity, else returns false.
   */
  exists(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Performs a foreign function call via the terminal.
   */
  ffi(
    commandInput: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Given a path, query the file system to get information about a file, directory, etc.
   */
  fsMetadata(
    path: string,
    overrides?: CallOverrides
  ): Promise<VmSafe.FsMetadataStructOutput>;

  /**
   * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
   */
  getCode(artifactPath: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
   */
  getDeployedCode(
    artifactPath: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the label for the specified address.
   */
  getLabel(account: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the map key and parent of a mapping at a given slot, for a given address.
   */
  getMappingKeyAndParentOf(
    target: string,
    elementSlot: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the number of elements in the mapping at the given slot, for a given address.
   */
  getMappingLength(
    target: string,
    mappingSlot: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
   */
  getMappingSlotAt(
    target: string,
    mappingSlot: BytesLike,
    idx: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the nonce of an account.
   */
  "getNonce(address)"(
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getNonce((address,uint256,uint256,uint256))"(
    wallet: VmSafe.WalletStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets all the recorded logs.
   */
  getRecordedLogs(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
   */
  indexOf(
    input: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns true if `forge` command was executed in given context.
   */
  isContext(context: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns true if the path exists on disk and is pointing at a directory, else returns false.
   */
  isDir(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
   */
  isFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
   */
  keyExists(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Checks if `key` exists in a JSON object.
   */
  keyExistsJson(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Checks if `key` exists in a TOML table.
   */
  keyExistsToml(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Labels an address in call traces.
   */
  label(
    account: string,
    newLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the gas used in the last call.
   */
  lastCallGas(overrides?: CallOverrides): Promise<VmSafe.GasStructOutput>;

  /**
   * Loads a storage slot from an address.
   */
  load(
    target: string,
    slot: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into an `address`.
   */
  parseAddress(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `bool`.
   */
  parseBool(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses the given `string` into `bytes`.
   */
  parseBytes(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `bytes32`.
   */
  parseBytes32(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `int256`.
   */
  parseInt(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * ABI-encodes a JSON object.
   */
  "parseJson(string)"(json: string, overrides?: CallOverrides): Promise<string>;

  /**
   * ABI-encodes a JSON object at `key`.
   */
  "parseJson(string,string)"(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `address`.
   */
  parseJsonAddress(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `address[]`.
   */
  parseJsonAddressArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bool`.
   */
  parseJsonBool(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bool[]`.
   */
  parseJsonBoolArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes`.
   */
  parseJsonBytes(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes32`.
   */
  parseJsonBytes32(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
   */
  parseJsonBytes32Array(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
   */
  parseJsonBytesArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `int256`.
   */
  parseJsonInt(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `int256[]`.
   */
  parseJsonIntArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Returns an array of all the keys in a JSON object.
   */
  parseJsonKeys(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `string`.
   */
  parseJsonString(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `string[]`.
   */
  parseJsonStringArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `uint256`.
   */
  parseJsonUint(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
   */
  parseJsonUintArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * ABI-encodes a TOML table at `key`.
   */
  "parseToml(string,string)"(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * ABI-encodes a TOML table.
   */
  "parseToml(string)"(toml: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `address`.
   */
  parseTomlAddress(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `address[]`.
   */
  parseTomlAddressArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bool`.
   */
  parseTomlBool(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bool[]`.
   */
  parseTomlBoolArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes`.
   */
  parseTomlBytes(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes32`.
   */
  parseTomlBytes32(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
   */
  parseTomlBytes32Array(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
   */
  parseTomlBytesArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `int256`.
   */
  parseTomlInt(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `int256[]`.
   */
  parseTomlIntArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Returns an array of all the keys in a TOML table.
   */
  parseTomlKeys(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `string`.
   */
  parseTomlString(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `string[]`.
   */
  parseTomlStringArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `uint256`.
   */
  parseTomlUint(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
   */
  parseTomlUintArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Parses the given `string` into a `uint256`.
   */
  parseUint(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
   */
  pauseGasMetering(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the path of the current project root.
   */
  projectRoot(overrides?: CallOverrides): Promise<string>;

  /**
   * Prompts the user for a string value in the terminal.
   */
  prompt(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for an address in the terminal.
   */
  promptAddress(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for a hidden string value in the terminal.
   */
  promptSecret(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for uint256 in the terminal.
   */
  promptUint(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `readDir(string)`.
   */
  "readDir(string,uint64)"(
    path: string,
    maxDepth: BigNumberish,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * See `readDir(string)`.
   */
  "readDir(string,uint64,bool)"(
    path: string,
    maxDepth: BigNumberish,
    followLinks: boolean,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
   */
  "readDir(string)"(
    path: string,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * Reads the entire content of file to string. `path` is relative to the project root.
   */
  readFile(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads the entire content of file as binary. `path` is relative to the project root.
   */
  readFileBinary(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads next line of file to string.
   */
  readLine(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
   */
  readLink(linkPath: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Records all storage reads and writes.
   */
  record(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Record all the transaction logs.
   */
  recordLogs(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Adds a private key to the local forge wallet and returns the address.
   */
  rememberKey(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
   */
  removeDir(
    path: string,
    recursive: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
   */
  removeFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Replaces occurrences of `from` in the given `string` with `to`.
   */
  replace(
    input: string,
    from: string,
    to: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
   */
  resumeGasMetering(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Performs an Ethereum JSON-RPC request to the current fork URL.
   */
  rpc(
    method: string,
    params: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the RPC url for the given alias.
   */
  rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns all rpc urls and their aliases as structs.
   */
  rpcUrlStructs(overrides?: CallOverrides): Promise<VmSafe.RpcStructOutput[]>;

  /**
   * Returns all rpc urls and their aliases `[alias, url][]`.
   */
  rpcUrls(overrides?: CallOverrides): Promise<[string, string][]>;

  /**
   * See `serializeJson`.
   */
  "serializeAddress(string,string,address[])"(
    objectKey: string,
    valueKey: string,
    values: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeAddress(string,string,address)"(
    objectKey: string,
    valueKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBool(string,string,bool[])"(
    objectKey: string,
    valueKey: string,
    values: boolean[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBool(string,string,bool)"(
    objectKey: string,
    valueKey: string,
    value: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes(string,string,bytes[])"(
    objectKey: string,
    valueKey: string,
    values: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes(string,string,bytes)"(
    objectKey: string,
    valueKey: string,
    value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes32(string,string,bytes32[])"(
    objectKey: string,
    valueKey: string,
    values: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes32(string,string,bytes32)"(
    objectKey: string,
    valueKey: string,
    value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeInt(string,string,int256)"(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeInt(string,string,int256[])"(
    objectKey: string,
    valueKey: string,
    values: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
   */
  serializeJson(
    objectKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeString(string,string,string[])"(
    objectKey: string,
    valueKey: string,
    values: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeString(string,string,string)"(
    objectKey: string,
    valueKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeUint(string,string,uint256)"(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeUint(string,string,uint256[])"(
    objectKey: string,
    valueKey: string,
    values: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  serializeUintToHex(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets environment variables.
   */
  setEnv(
    name: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
   */
  "sign(bytes32)"(
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  /**
   * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
   */
  "sign(address,bytes32)"(
    signer: string,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  "sign((address,uint256,uint256,uint256),bytes32)"(
    wallet: VmSafe.WalletStruct,
    digest: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Signs `digest` with `privateKey` using the secp256k1 curve.
   */
  "sign(uint256,bytes32)"(
    privateKey: BigNumberish,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  /**
   * Signs `digest` with `privateKey` using the secp256r1 curve.
   */
  signP256(
    privateKey: BigNumberish,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[string, string] & { r: string; s: string }>;

  /**
   * Suspends execution of the main thread for `duration` milliseconds.
   */
  sleep(
    duration: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Splits the given `string` into an array of strings divided by the `delimiter`.
   */
  split(
    input: string,
    delimiter: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
   */
  "startBroadcast()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
   */
  "startBroadcast(address)"(
    signer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
   */
  "startBroadcast(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Starts recording all map SSTOREs for later retrieval.
   */
  startMappingRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
   */
  startStateDiffRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
   */
  stopAndReturnStateDiff(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stops collecting onchain transactions.
   */
  stopBroadcast(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
   */
  stopMappingRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Encodes a `string` value to a base64 string.
   */
  "toBase64(string)"(data: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Encodes a `bytes` value to a base64 string.
   */
  "toBase64(bytes)"(
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Encodes a `string` value to a base64url string.
   */
  "toBase64URL(string)"(
    data: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Encodes a `bytes` value to a base64url string.
   */
  "toBase64URL(bytes)"(
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given `string` value to Lowercase.
   */
  toLowercase(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(address)"(
    value: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(uint256)"(
    value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bytes)"(
    value: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bool)"(value: boolean, overrides?: CallOverrides): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(int256)"(
    value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bytes32)"(
    value: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given `string` value to Uppercase.
   */
  toUppercase(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Trims leading and trailing whitespace from the given `string` value.
   */
  trim(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
   */
  tryFfi(
    commandInput: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the time since unix epoch in milliseconds.
   */
  unixTime(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
   */
  writeFile(
    path: string,
    data: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
   */
  writeFileBinary(
    path: string,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
   */
  "writeJson(string,string,string)"(
    json: string,
    path: string,
    valueKey: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
   */
  "writeJson(string,string)"(
    json: string,
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
   */
  writeLine(
    path: string,
    data: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
   */
  "writeToml(string,string,string)"(
    json: string,
    path: string,
    valueKey: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
   */
  "writeToml(string,string)"(
    json: string,
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: CallOverrides
    ): Promise<
      [string[], string[]] & { readSlots: string[]; writeSlots: string[] }
    >;

    /**
     * Gets the address for a given private key.
     */
    addr(privateKey: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(path: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(name: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: CallOverrides
    ): Promise<VmSafe.EthGetLogsStructOutput[]>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(commandInput: string[], overrides?: CallOverrides): Promise<string>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.FsMetadataStructOutput>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(artifactPath: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(account: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, string, string] & {
        found: boolean;
        key: string;
        parent: string;
      }
    >;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: CallOverrides
    ): Promise<VmSafe.LogStructOutput[]>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<VmSafe.GasStructOutput>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(overrides?: CallOverrides): Promise<void>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<string>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(promptText: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads next line of file to string.
     */
    readLine(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(linkPath: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Records all storage reads and writes.
     */
    record(overrides?: CallOverrides): Promise<void>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(overrides?: CallOverrides): Promise<void>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(path: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(overrides?: CallOverrides): Promise<void>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<VmSafe.RpcStructOutput[]>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<[string, string][]>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { r: string; s: string }>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(duration: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: CallOverrides
    ): Promise<VmSafe.AccountAccessStructOutput[]>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(overrides?: CallOverrides): Promise<void>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: CallOverrides
    ): Promise<VmSafe.FfiResultStructOutput>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads next line of file to string.
     */
    readLine(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(linkPath: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Records all storage reads and writes.
     */
    record(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads next line of file to string.
     */
    readLine(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(
      linkPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Records all storage reads and writes.
     */
    record(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(
      rpcAlias: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
