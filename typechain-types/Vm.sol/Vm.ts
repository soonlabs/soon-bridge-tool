/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace VmSafe {
  export type WalletStruct = {
    addr: string;
    publicKeyX: BigNumberish;
    publicKeyY: BigNumberish;
    privateKey: BigNumberish;
  };

  export type WalletStructOutput = [string, BigNumber, BigNumber, BigNumber] & {
    addr: string;
    publicKeyX: BigNumber;
    publicKeyY: BigNumber;
    privateKey: BigNumber;
  };

  export type EthGetLogsStruct = {
    emitter: string;
    topics: BytesLike[];
    data: BytesLike;
    blockHash: BytesLike;
    blockNumber: BigNumberish;
    transactionHash: BytesLike;
    transactionIndex: BigNumberish;
    logIndex: BigNumberish;
    removed: boolean;
  };

  export type EthGetLogsStructOutput = [
    string,
    string[],
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    emitter: string;
    topics: string[];
    data: string;
    blockHash: string;
    blockNumber: BigNumber;
    transactionHash: string;
    transactionIndex: BigNumber;
    logIndex: BigNumber;
    removed: boolean;
  };

  export type FsMetadataStruct = {
    isDir: boolean;
    isSymlink: boolean;
    length: BigNumberish;
    readOnly: boolean;
    modified: BigNumberish;
    accessed: BigNumberish;
    created: BigNumberish;
  };

  export type FsMetadataStructOutput = [
    boolean,
    boolean,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isDir: boolean;
    isSymlink: boolean;
    length: BigNumber;
    readOnly: boolean;
    modified: BigNumber;
    accessed: BigNumber;
    created: BigNumber;
  };

  export type LogStruct = {
    topics: BytesLike[];
    data: BytesLike;
    emitter: string;
  };

  export type LogStructOutput = [string[], string, string] & {
    topics: string[];
    data: string;
    emitter: string;
  };

  export type GasStruct = {
    gasLimit: BigNumberish;
    gasTotalUsed: BigNumberish;
    gasMemoryUsed: BigNumberish;
    gasRefunded: BigNumberish;
    gasRemaining: BigNumberish;
  };

  export type GasStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    gasLimit: BigNumber;
    gasTotalUsed: BigNumber;
    gasMemoryUsed: BigNumber;
    gasRefunded: BigNumber;
    gasRemaining: BigNumber;
  };

  export type DirEntryStruct = {
    errorMessage: string;
    path: string;
    depth: BigNumberish;
    isDir: boolean;
    isSymlink: boolean;
  };

  export type DirEntryStructOutput = [
    string,
    string,
    BigNumber,
    boolean,
    boolean
  ] & {
    errorMessage: string;
    path: string;
    depth: BigNumber;
    isDir: boolean;
    isSymlink: boolean;
  };

  export type RpcStruct = { key: string; url: string };

  export type RpcStructOutput = [string, string] & { key: string; url: string };

  export type ChainInfoStruct = { forkId: BigNumberish; chainId: BigNumberish };

  export type ChainInfoStructOutput = [BigNumber, BigNumber] & {
    forkId: BigNumber;
    chainId: BigNumber;
  };

  export type StorageAccessStruct = {
    account: string;
    slot: BytesLike;
    isWrite: boolean;
    previousValue: BytesLike;
    newValue: BytesLike;
    reverted: boolean;
  };

  export type StorageAccessStructOutput = [
    string,
    string,
    boolean,
    string,
    string,
    boolean
  ] & {
    account: string;
    slot: string;
    isWrite: boolean;
    previousValue: string;
    newValue: string;
    reverted: boolean;
  };

  export type AccountAccessStruct = {
    chainInfo: VmSafe.ChainInfoStruct;
    kind: BigNumberish;
    account: string;
    accessor: string;
    initialized: boolean;
    oldBalance: BigNumberish;
    newBalance: BigNumberish;
    deployedCode: BytesLike;
    value: BigNumberish;
    data: BytesLike;
    reverted: boolean;
    storageAccesses: VmSafe.StorageAccessStruct[];
    depth: BigNumberish;
  };

  export type AccountAccessStructOutput = [
    VmSafe.ChainInfoStructOutput,
    number,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    string,
    boolean,
    VmSafe.StorageAccessStructOutput[],
    BigNumber
  ] & {
    chainInfo: VmSafe.ChainInfoStructOutput;
    kind: number;
    account: string;
    accessor: string;
    initialized: boolean;
    oldBalance: BigNumber;
    newBalance: BigNumber;
    deployedCode: string;
    value: BigNumber;
    data: string;
    reverted: boolean;
    storageAccesses: VmSafe.StorageAccessStructOutput[];
    depth: BigNumber;
  };

  export type FfiResultStruct = {
    exitCode: BigNumberish;
    stdout: BytesLike;
    stderr: BytesLike;
  };

  export type FfiResultStructOutput = [number, string, string] & {
    exitCode: number;
    stdout: string;
    stderr: string;
  };
}

export interface VmInterface extends utils.Interface {
  functions: {
    "accesses(address)": FunctionFragment;
    "activeFork()": FunctionFragment;
    "addr(uint256)": FunctionFragment;
    "allowCheatcodes(address)": FunctionFragment;
    "assertApproxEqAbs(uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbs(int256,int256,uint256)": FunctionFragment;
    "assertApproxEqAbs(int256,int256,uint256,string)": FunctionFragment;
    "assertApproxEqAbs(uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)": FunctionFragment;
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRel(int256,int256,uint256,string)": FunctionFragment;
    "assertApproxEqRel(int256,int256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)": FunctionFragment;
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)": FunctionFragment;
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)": FunctionFragment;
    "assertEq(bytes32[],bytes32[])": FunctionFragment;
    "assertEq(int256[],int256[],string)": FunctionFragment;
    "assertEq(address,address,string)": FunctionFragment;
    "assertEq(string,string,string)": FunctionFragment;
    "assertEq(address[],address[])": FunctionFragment;
    "assertEq(address[],address[],string)": FunctionFragment;
    "assertEq(bool,bool,string)": FunctionFragment;
    "assertEq(address,address)": FunctionFragment;
    "assertEq(uint256[],uint256[],string)": FunctionFragment;
    "assertEq(bool[],bool[])": FunctionFragment;
    "assertEq(int256[],int256[])": FunctionFragment;
    "assertEq(int256,int256,string)": FunctionFragment;
    "assertEq(bytes32,bytes32)": FunctionFragment;
    "assertEq(uint256,uint256,string)": FunctionFragment;
    "assertEq(uint256[],uint256[])": FunctionFragment;
    "assertEq(bytes,bytes)": FunctionFragment;
    "assertEq(uint256,uint256)": FunctionFragment;
    "assertEq(bytes32,bytes32,string)": FunctionFragment;
    "assertEq(string[],string[])": FunctionFragment;
    "assertEq(bytes32[],bytes32[],string)": FunctionFragment;
    "assertEq(bytes,bytes,string)": FunctionFragment;
    "assertEq(bool[],bool[],string)": FunctionFragment;
    "assertEq(bytes[],bytes[])": FunctionFragment;
    "assertEq(string[],string[],string)": FunctionFragment;
    "assertEq(string,string)": FunctionFragment;
    "assertEq(bytes[],bytes[],string)": FunctionFragment;
    "assertEq(bool,bool)": FunctionFragment;
    "assertEq(int256,int256)": FunctionFragment;
    "assertEqDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertEqDecimal(int256,int256,uint256)": FunctionFragment;
    "assertEqDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertEqDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertFalse(bool,string)": FunctionFragment;
    "assertFalse(bool)": FunctionFragment;
    "assertGe(int256,int256)": FunctionFragment;
    "assertGe(int256,int256,string)": FunctionFragment;
    "assertGe(uint256,uint256)": FunctionFragment;
    "assertGe(uint256,uint256,string)": FunctionFragment;
    "assertGeDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertGeDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertGeDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertGeDecimal(int256,int256,uint256)": FunctionFragment;
    "assertGt(int256,int256)": FunctionFragment;
    "assertGt(uint256,uint256,string)": FunctionFragment;
    "assertGt(uint256,uint256)": FunctionFragment;
    "assertGt(int256,int256,string)": FunctionFragment;
    "assertGtDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertGtDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertGtDecimal(int256,int256,uint256)": FunctionFragment;
    "assertGtDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLe(int256,int256,string)": FunctionFragment;
    "assertLe(uint256,uint256)": FunctionFragment;
    "assertLe(int256,int256)": FunctionFragment;
    "assertLe(uint256,uint256,string)": FunctionFragment;
    "assertLeDecimal(int256,int256,uint256)": FunctionFragment;
    "assertLeDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertLeDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertLeDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLt(int256,int256)": FunctionFragment;
    "assertLt(uint256,uint256,string)": FunctionFragment;
    "assertLt(int256,int256,string)": FunctionFragment;
    "assertLt(uint256,uint256)": FunctionFragment;
    "assertLtDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertLtDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertLtDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertLtDecimal(int256,int256,uint256)": FunctionFragment;
    "assertNotEq(bytes32[],bytes32[])": FunctionFragment;
    "assertNotEq(int256[],int256[])": FunctionFragment;
    "assertNotEq(bool,bool,string)": FunctionFragment;
    "assertNotEq(bytes[],bytes[],string)": FunctionFragment;
    "assertNotEq(bool,bool)": FunctionFragment;
    "assertNotEq(bool[],bool[])": FunctionFragment;
    "assertNotEq(bytes,bytes)": FunctionFragment;
    "assertNotEq(address[],address[])": FunctionFragment;
    "assertNotEq(int256,int256,string)": FunctionFragment;
    "assertNotEq(uint256[],uint256[])": FunctionFragment;
    "assertNotEq(bool[],bool[],string)": FunctionFragment;
    "assertNotEq(string,string)": FunctionFragment;
    "assertNotEq(address[],address[],string)": FunctionFragment;
    "assertNotEq(string,string,string)": FunctionFragment;
    "assertNotEq(address,address,string)": FunctionFragment;
    "assertNotEq(bytes32,bytes32)": FunctionFragment;
    "assertNotEq(bytes,bytes,string)": FunctionFragment;
    "assertNotEq(uint256,uint256,string)": FunctionFragment;
    "assertNotEq(uint256[],uint256[],string)": FunctionFragment;
    "assertNotEq(address,address)": FunctionFragment;
    "assertNotEq(bytes32,bytes32,string)": FunctionFragment;
    "assertNotEq(string[],string[],string)": FunctionFragment;
    "assertNotEq(uint256,uint256)": FunctionFragment;
    "assertNotEq(bytes32[],bytes32[],string)": FunctionFragment;
    "assertNotEq(string[],string[])": FunctionFragment;
    "assertNotEq(int256[],int256[],string)": FunctionFragment;
    "assertNotEq(bytes[],bytes[])": FunctionFragment;
    "assertNotEq(int256,int256)": FunctionFragment;
    "assertNotEqDecimal(int256,int256,uint256)": FunctionFragment;
    "assertNotEqDecimal(int256,int256,uint256,string)": FunctionFragment;
    "assertNotEqDecimal(uint256,uint256,uint256)": FunctionFragment;
    "assertNotEqDecimal(uint256,uint256,uint256,string)": FunctionFragment;
    "assertTrue(bool)": FunctionFragment;
    "assertTrue(bool,string)": FunctionFragment;
    "assume(bool)": FunctionFragment;
    "blobBaseFee(uint256)": FunctionFragment;
    "breakpoint(string)": FunctionFragment;
    "breakpoint(string,bool)": FunctionFragment;
    "broadcast()": FunctionFragment;
    "broadcast(address)": FunctionFragment;
    "broadcast(uint256)": FunctionFragment;
    "chainId(uint256)": FunctionFragment;
    "clearMockedCalls()": FunctionFragment;
    "closeFile(string)": FunctionFragment;
    "coinbase(address)": FunctionFragment;
    "computeCreate2Address(bytes32,bytes32)": FunctionFragment;
    "computeCreate2Address(bytes32,bytes32,address)": FunctionFragment;
    "computeCreateAddress(address,uint256)": FunctionFragment;
    "copyFile(string,string)": FunctionFragment;
    "createDir(string,bool)": FunctionFragment;
    "createFork(string)": FunctionFragment;
    "createFork(string,uint256)": FunctionFragment;
    "createFork(string,bytes32)": FunctionFragment;
    "createSelectFork(string,uint256)": FunctionFragment;
    "createSelectFork(string,bytes32)": FunctionFragment;
    "createSelectFork(string)": FunctionFragment;
    "createWallet(string)": FunctionFragment;
    "createWallet(uint256)": FunctionFragment;
    "createWallet(uint256,string)": FunctionFragment;
    "deal(address,uint256)": FunctionFragment;
    "deleteSnapshot(uint256)": FunctionFragment;
    "deleteSnapshots()": FunctionFragment;
    "deriveKey(string,string,uint32,string)": FunctionFragment;
    "deriveKey(string,uint32,string)": FunctionFragment;
    "deriveKey(string,uint32)": FunctionFragment;
    "deriveKey(string,string,uint32)": FunctionFragment;
    "difficulty(uint256)": FunctionFragment;
    "dumpState(string)": FunctionFragment;
    "envAddress(string)": FunctionFragment;
    "envAddress(string,string)": FunctionFragment;
    "envBool(string)": FunctionFragment;
    "envBool(string,string)": FunctionFragment;
    "envBytes(string)": FunctionFragment;
    "envBytes(string,string)": FunctionFragment;
    "envBytes32(string,string)": FunctionFragment;
    "envBytes32(string)": FunctionFragment;
    "envExists(string)": FunctionFragment;
    "envInt(string,string)": FunctionFragment;
    "envInt(string)": FunctionFragment;
    "envOr(string,string,bytes32[])": FunctionFragment;
    "envOr(string,string,int256[])": FunctionFragment;
    "envOr(string,bool)": FunctionFragment;
    "envOr(string,address)": FunctionFragment;
    "envOr(string,uint256)": FunctionFragment;
    "envOr(string,string,bytes[])": FunctionFragment;
    "envOr(string,string,uint256[])": FunctionFragment;
    "envOr(string,string,string[])": FunctionFragment;
    "envOr(string,bytes)": FunctionFragment;
    "envOr(string,bytes32)": FunctionFragment;
    "envOr(string,int256)": FunctionFragment;
    "envOr(string,string,address[])": FunctionFragment;
    "envOr(string,string)": FunctionFragment;
    "envOr(string,string,bool[])": FunctionFragment;
    "envString(string,string)": FunctionFragment;
    "envString(string)": FunctionFragment;
    "envUint(string)": FunctionFragment;
    "envUint(string,string)": FunctionFragment;
    "etch(address,bytes)": FunctionFragment;
    "eth_getLogs(uint256,uint256,address,bytes32[])": FunctionFragment;
    "exists(string)": FunctionFragment;
    "expectCall(address,uint256,uint64,bytes)": FunctionFragment;
    "expectCall(address,uint256,uint64,bytes,uint64)": FunctionFragment;
    "expectCall(address,uint256,bytes,uint64)": FunctionFragment;
    "expectCall(address,bytes)": FunctionFragment;
    "expectCall(address,bytes,uint64)": FunctionFragment;
    "expectCall(address,uint256,bytes)": FunctionFragment;
    "expectCallMinGas(address,uint256,uint64,bytes)": FunctionFragment;
    "expectCallMinGas(address,uint256,uint64,bytes,uint64)": FunctionFragment;
    "expectEmit()": FunctionFragment;
    "expectEmit(bool,bool,bool,bool)": FunctionFragment;
    "expectEmit(bool,bool,bool,bool,address)": FunctionFragment;
    "expectEmit(address)": FunctionFragment;
    "expectRevert(bytes4)": FunctionFragment;
    "expectRevert(bytes)": FunctionFragment;
    "expectRevert()": FunctionFragment;
    "expectSafeMemory(uint64,uint64)": FunctionFragment;
    "expectSafeMemoryCall(uint64,uint64)": FunctionFragment;
    "fee(uint256)": FunctionFragment;
    "ffi(string[])": FunctionFragment;
    "fsMetadata(string)": FunctionFragment;
    "getBlobBaseFee()": FunctionFragment;
    "getBlockNumber()": FunctionFragment;
    "getBlockTimestamp()": FunctionFragment;
    "getCode(string)": FunctionFragment;
    "getDeployedCode(string)": FunctionFragment;
    "getLabel(address)": FunctionFragment;
    "getMappingKeyAndParentOf(address,bytes32)": FunctionFragment;
    "getMappingLength(address,bytes32)": FunctionFragment;
    "getMappingSlotAt(address,bytes32,uint256)": FunctionFragment;
    "getNonce(address)": FunctionFragment;
    "getNonce((address,uint256,uint256,uint256))": FunctionFragment;
    "getRecordedLogs()": FunctionFragment;
    "indexOf(string,string)": FunctionFragment;
    "isContext(uint8)": FunctionFragment;
    "isDir(string)": FunctionFragment;
    "isFile(string)": FunctionFragment;
    "isPersistent(address)": FunctionFragment;
    "keyExists(string,string)": FunctionFragment;
    "keyExistsJson(string,string)": FunctionFragment;
    "keyExistsToml(string,string)": FunctionFragment;
    "label(address,string)": FunctionFragment;
    "lastCallGas()": FunctionFragment;
    "load(address,bytes32)": FunctionFragment;
    "loadAllocs(string)": FunctionFragment;
    "makePersistent(address[])": FunctionFragment;
    "makePersistent(address,address)": FunctionFragment;
    "makePersistent(address)": FunctionFragment;
    "makePersistent(address,address,address)": FunctionFragment;
    "mockCall(address,uint256,bytes,bytes)": FunctionFragment;
    "mockCall(address,bytes,bytes)": FunctionFragment;
    "mockCallRevert(address,uint256,bytes,bytes)": FunctionFragment;
    "mockCallRevert(address,bytes,bytes)": FunctionFragment;
    "parseAddress(string)": FunctionFragment;
    "parseBool(string)": FunctionFragment;
    "parseBytes(string)": FunctionFragment;
    "parseBytes32(string)": FunctionFragment;
    "parseInt(string)": FunctionFragment;
    "parseJson(string)": FunctionFragment;
    "parseJson(string,string)": FunctionFragment;
    "parseJsonAddress(string,string)": FunctionFragment;
    "parseJsonAddressArray(string,string)": FunctionFragment;
    "parseJsonBool(string,string)": FunctionFragment;
    "parseJsonBoolArray(string,string)": FunctionFragment;
    "parseJsonBytes(string,string)": FunctionFragment;
    "parseJsonBytes32(string,string)": FunctionFragment;
    "parseJsonBytes32Array(string,string)": FunctionFragment;
    "parseJsonBytesArray(string,string)": FunctionFragment;
    "parseJsonInt(string,string)": FunctionFragment;
    "parseJsonIntArray(string,string)": FunctionFragment;
    "parseJsonKeys(string,string)": FunctionFragment;
    "parseJsonString(string,string)": FunctionFragment;
    "parseJsonStringArray(string,string)": FunctionFragment;
    "parseJsonUint(string,string)": FunctionFragment;
    "parseJsonUintArray(string,string)": FunctionFragment;
    "parseToml(string,string)": FunctionFragment;
    "parseToml(string)": FunctionFragment;
    "parseTomlAddress(string,string)": FunctionFragment;
    "parseTomlAddressArray(string,string)": FunctionFragment;
    "parseTomlBool(string,string)": FunctionFragment;
    "parseTomlBoolArray(string,string)": FunctionFragment;
    "parseTomlBytes(string,string)": FunctionFragment;
    "parseTomlBytes32(string,string)": FunctionFragment;
    "parseTomlBytes32Array(string,string)": FunctionFragment;
    "parseTomlBytesArray(string,string)": FunctionFragment;
    "parseTomlInt(string,string)": FunctionFragment;
    "parseTomlIntArray(string,string)": FunctionFragment;
    "parseTomlKeys(string,string)": FunctionFragment;
    "parseTomlString(string,string)": FunctionFragment;
    "parseTomlStringArray(string,string)": FunctionFragment;
    "parseTomlUint(string,string)": FunctionFragment;
    "parseTomlUintArray(string,string)": FunctionFragment;
    "parseUint(string)": FunctionFragment;
    "pauseGasMetering()": FunctionFragment;
    "prank(address,address)": FunctionFragment;
    "prank(address)": FunctionFragment;
    "prevrandao(bytes32)": FunctionFragment;
    "prevrandao(uint256)": FunctionFragment;
    "projectRoot()": FunctionFragment;
    "prompt(string)": FunctionFragment;
    "promptAddress(string)": FunctionFragment;
    "promptSecret(string)": FunctionFragment;
    "promptUint(string)": FunctionFragment;
    "readCallers()": FunctionFragment;
    "readDir(string,uint64)": FunctionFragment;
    "readDir(string,uint64,bool)": FunctionFragment;
    "readDir(string)": FunctionFragment;
    "readFile(string)": FunctionFragment;
    "readFileBinary(string)": FunctionFragment;
    "readLine(string)": FunctionFragment;
    "readLink(string)": FunctionFragment;
    "record()": FunctionFragment;
    "recordLogs()": FunctionFragment;
    "rememberKey(uint256)": FunctionFragment;
    "removeDir(string,bool)": FunctionFragment;
    "removeFile(string)": FunctionFragment;
    "replace(string,string,string)": FunctionFragment;
    "resetNonce(address)": FunctionFragment;
    "resumeGasMetering()": FunctionFragment;
    "revertTo(uint256)": FunctionFragment;
    "revertToAndDelete(uint256)": FunctionFragment;
    "revokePersistent(address[])": FunctionFragment;
    "revokePersistent(address)": FunctionFragment;
    "roll(uint256)": FunctionFragment;
    "rollFork(bytes32)": FunctionFragment;
    "rollFork(uint256,uint256)": FunctionFragment;
    "rollFork(uint256)": FunctionFragment;
    "rollFork(uint256,bytes32)": FunctionFragment;
    "rpc(string,string)": FunctionFragment;
    "rpcUrl(string)": FunctionFragment;
    "rpcUrlStructs()": FunctionFragment;
    "rpcUrls()": FunctionFragment;
    "selectFork(uint256)": FunctionFragment;
    "serializeAddress(string,string,address[])": FunctionFragment;
    "serializeAddress(string,string,address)": FunctionFragment;
    "serializeBool(string,string,bool[])": FunctionFragment;
    "serializeBool(string,string,bool)": FunctionFragment;
    "serializeBytes(string,string,bytes[])": FunctionFragment;
    "serializeBytes(string,string,bytes)": FunctionFragment;
    "serializeBytes32(string,string,bytes32[])": FunctionFragment;
    "serializeBytes32(string,string,bytes32)": FunctionFragment;
    "serializeInt(string,string,int256)": FunctionFragment;
    "serializeInt(string,string,int256[])": FunctionFragment;
    "serializeJson(string,string)": FunctionFragment;
    "serializeString(string,string,string[])": FunctionFragment;
    "serializeString(string,string,string)": FunctionFragment;
    "serializeUint(string,string,uint256)": FunctionFragment;
    "serializeUint(string,string,uint256[])": FunctionFragment;
    "serializeUintToHex(string,string,uint256)": FunctionFragment;
    "setEnv(string,string)": FunctionFragment;
    "setNonce(address,uint64)": FunctionFragment;
    "setNonceUnsafe(address,uint64)": FunctionFragment;
    "sign(bytes32)": FunctionFragment;
    "sign(address,bytes32)": FunctionFragment;
    "sign((address,uint256,uint256,uint256),bytes32)": FunctionFragment;
    "sign(uint256,bytes32)": FunctionFragment;
    "signP256(uint256,bytes32)": FunctionFragment;
    "skip(bool)": FunctionFragment;
    "sleep(uint256)": FunctionFragment;
    "snapshot()": FunctionFragment;
    "split(string,string)": FunctionFragment;
    "startBroadcast()": FunctionFragment;
    "startBroadcast(address)": FunctionFragment;
    "startBroadcast(uint256)": FunctionFragment;
    "startMappingRecording()": FunctionFragment;
    "startPrank(address)": FunctionFragment;
    "startPrank(address,address)": FunctionFragment;
    "startStateDiffRecording()": FunctionFragment;
    "stopAndReturnStateDiff()": FunctionFragment;
    "stopBroadcast()": FunctionFragment;
    "stopExpectSafeMemory()": FunctionFragment;
    "stopMappingRecording()": FunctionFragment;
    "stopPrank()": FunctionFragment;
    "store(address,bytes32,bytes32)": FunctionFragment;
    "toBase64(string)": FunctionFragment;
    "toBase64(bytes)": FunctionFragment;
    "toBase64URL(string)": FunctionFragment;
    "toBase64URL(bytes)": FunctionFragment;
    "toLowercase(string)": FunctionFragment;
    "toString(address)": FunctionFragment;
    "toString(uint256)": FunctionFragment;
    "toString(bytes)": FunctionFragment;
    "toString(bool)": FunctionFragment;
    "toString(int256)": FunctionFragment;
    "toString(bytes32)": FunctionFragment;
    "toUppercase(string)": FunctionFragment;
    "transact(uint256,bytes32)": FunctionFragment;
    "transact(bytes32)": FunctionFragment;
    "trim(string)": FunctionFragment;
    "tryFfi(string[])": FunctionFragment;
    "txGasPrice(uint256)": FunctionFragment;
    "unixTime()": FunctionFragment;
    "warp(uint256)": FunctionFragment;
    "writeFile(string,string)": FunctionFragment;
    "writeFileBinary(string,bytes)": FunctionFragment;
    "writeJson(string,string,string)": FunctionFragment;
    "writeJson(string,string)": FunctionFragment;
    "writeLine(string,string)": FunctionFragment;
    "writeToml(string,string,string)": FunctionFragment;
    "writeToml(string,string)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "accesses"
      | "activeFork"
      | "addr"
      | "allowCheatcodes"
      | "assertApproxEqAbs(uint256,uint256,uint256)"
      | "assertApproxEqAbs(int256,int256,uint256)"
      | "assertApproxEqAbs(int256,int256,uint256,string)"
      | "assertApproxEqAbs(uint256,uint256,uint256,string)"
      | "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"
      | "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"
      | "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"
      | "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"
      | "assertApproxEqRel(uint256,uint256,uint256,string)"
      | "assertApproxEqRel(uint256,uint256,uint256)"
      | "assertApproxEqRel(int256,int256,uint256,string)"
      | "assertApproxEqRel(int256,int256,uint256)"
      | "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"
      | "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"
      | "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"
      | "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"
      | "assertEq(bytes32[],bytes32[])"
      | "assertEq(int256[],int256[],string)"
      | "assertEq(address,address,string)"
      | "assertEq(string,string,string)"
      | "assertEq(address[],address[])"
      | "assertEq(address[],address[],string)"
      | "assertEq(bool,bool,string)"
      | "assertEq(address,address)"
      | "assertEq(uint256[],uint256[],string)"
      | "assertEq(bool[],bool[])"
      | "assertEq(int256[],int256[])"
      | "assertEq(int256,int256,string)"
      | "assertEq(bytes32,bytes32)"
      | "assertEq(uint256,uint256,string)"
      | "assertEq(uint256[],uint256[])"
      | "assertEq(bytes,bytes)"
      | "assertEq(uint256,uint256)"
      | "assertEq(bytes32,bytes32,string)"
      | "assertEq(string[],string[])"
      | "assertEq(bytes32[],bytes32[],string)"
      | "assertEq(bytes,bytes,string)"
      | "assertEq(bool[],bool[],string)"
      | "assertEq(bytes[],bytes[])"
      | "assertEq(string[],string[],string)"
      | "assertEq(string,string)"
      | "assertEq(bytes[],bytes[],string)"
      | "assertEq(bool,bool)"
      | "assertEq(int256,int256)"
      | "assertEqDecimal(uint256,uint256,uint256)"
      | "assertEqDecimal(int256,int256,uint256)"
      | "assertEqDecimal(int256,int256,uint256,string)"
      | "assertEqDecimal(uint256,uint256,uint256,string)"
      | "assertFalse(bool,string)"
      | "assertFalse(bool)"
      | "assertGe(int256,int256)"
      | "assertGe(int256,int256,string)"
      | "assertGe(uint256,uint256)"
      | "assertGe(uint256,uint256,string)"
      | "assertGeDecimal(uint256,uint256,uint256)"
      | "assertGeDecimal(int256,int256,uint256,string)"
      | "assertGeDecimal(uint256,uint256,uint256,string)"
      | "assertGeDecimal(int256,int256,uint256)"
      | "assertGt(int256,int256)"
      | "assertGt(uint256,uint256,string)"
      | "assertGt(uint256,uint256)"
      | "assertGt(int256,int256,string)"
      | "assertGtDecimal(int256,int256,uint256,string)"
      | "assertGtDecimal(uint256,uint256,uint256,string)"
      | "assertGtDecimal(int256,int256,uint256)"
      | "assertGtDecimal(uint256,uint256,uint256)"
      | "assertLe(int256,int256,string)"
      | "assertLe(uint256,uint256)"
      | "assertLe(int256,int256)"
      | "assertLe(uint256,uint256,string)"
      | "assertLeDecimal(int256,int256,uint256)"
      | "assertLeDecimal(uint256,uint256,uint256,string)"
      | "assertLeDecimal(int256,int256,uint256,string)"
      | "assertLeDecimal(uint256,uint256,uint256)"
      | "assertLt(int256,int256)"
      | "assertLt(uint256,uint256,string)"
      | "assertLt(int256,int256,string)"
      | "assertLt(uint256,uint256)"
      | "assertLtDecimal(uint256,uint256,uint256)"
      | "assertLtDecimal(int256,int256,uint256,string)"
      | "assertLtDecimal(uint256,uint256,uint256,string)"
      | "assertLtDecimal(int256,int256,uint256)"
      | "assertNotEq(bytes32[],bytes32[])"
      | "assertNotEq(int256[],int256[])"
      | "assertNotEq(bool,bool,string)"
      | "assertNotEq(bytes[],bytes[],string)"
      | "assertNotEq(bool,bool)"
      | "assertNotEq(bool[],bool[])"
      | "assertNotEq(bytes,bytes)"
      | "assertNotEq(address[],address[])"
      | "assertNotEq(int256,int256,string)"
      | "assertNotEq(uint256[],uint256[])"
      | "assertNotEq(bool[],bool[],string)"
      | "assertNotEq(string,string)"
      | "assertNotEq(address[],address[],string)"
      | "assertNotEq(string,string,string)"
      | "assertNotEq(address,address,string)"
      | "assertNotEq(bytes32,bytes32)"
      | "assertNotEq(bytes,bytes,string)"
      | "assertNotEq(uint256,uint256,string)"
      | "assertNotEq(uint256[],uint256[],string)"
      | "assertNotEq(address,address)"
      | "assertNotEq(bytes32,bytes32,string)"
      | "assertNotEq(string[],string[],string)"
      | "assertNotEq(uint256,uint256)"
      | "assertNotEq(bytes32[],bytes32[],string)"
      | "assertNotEq(string[],string[])"
      | "assertNotEq(int256[],int256[],string)"
      | "assertNotEq(bytes[],bytes[])"
      | "assertNotEq(int256,int256)"
      | "assertNotEqDecimal(int256,int256,uint256)"
      | "assertNotEqDecimal(int256,int256,uint256,string)"
      | "assertNotEqDecimal(uint256,uint256,uint256)"
      | "assertNotEqDecimal(uint256,uint256,uint256,string)"
      | "assertTrue(bool)"
      | "assertTrue(bool,string)"
      | "assume"
      | "blobBaseFee"
      | "breakpoint(string)"
      | "breakpoint(string,bool)"
      | "broadcast()"
      | "broadcast(address)"
      | "broadcast(uint256)"
      | "chainId"
      | "clearMockedCalls"
      | "closeFile"
      | "coinbase"
      | "computeCreate2Address(bytes32,bytes32)"
      | "computeCreate2Address(bytes32,bytes32,address)"
      | "computeCreateAddress"
      | "copyFile"
      | "createDir"
      | "createFork(string)"
      | "createFork(string,uint256)"
      | "createFork(string,bytes32)"
      | "createSelectFork(string,uint256)"
      | "createSelectFork(string,bytes32)"
      | "createSelectFork(string)"
      | "createWallet(string)"
      | "createWallet(uint256)"
      | "createWallet(uint256,string)"
      | "deal"
      | "deleteSnapshot"
      | "deleteSnapshots"
      | "deriveKey(string,string,uint32,string)"
      | "deriveKey(string,uint32,string)"
      | "deriveKey(string,uint32)"
      | "deriveKey(string,string,uint32)"
      | "difficulty"
      | "dumpState"
      | "envAddress(string)"
      | "envAddress(string,string)"
      | "envBool(string)"
      | "envBool(string,string)"
      | "envBytes(string)"
      | "envBytes(string,string)"
      | "envBytes32(string,string)"
      | "envBytes32(string)"
      | "envExists"
      | "envInt(string,string)"
      | "envInt(string)"
      | "envOr(string,string,bytes32[])"
      | "envOr(string,string,int256[])"
      | "envOr(string,bool)"
      | "envOr(string,address)"
      | "envOr(string,uint256)"
      | "envOr(string,string,bytes[])"
      | "envOr(string,string,uint256[])"
      | "envOr(string,string,string[])"
      | "envOr(string,bytes)"
      | "envOr(string,bytes32)"
      | "envOr(string,int256)"
      | "envOr(string,string,address[])"
      | "envOr(string,string)"
      | "envOr(string,string,bool[])"
      | "envString(string,string)"
      | "envString(string)"
      | "envUint(string)"
      | "envUint(string,string)"
      | "etch"
      | "eth_getLogs"
      | "exists"
      | "expectCall(address,uint256,uint64,bytes)"
      | "expectCall(address,uint256,uint64,bytes,uint64)"
      | "expectCall(address,uint256,bytes,uint64)"
      | "expectCall(address,bytes)"
      | "expectCall(address,bytes,uint64)"
      | "expectCall(address,uint256,bytes)"
      | "expectCallMinGas(address,uint256,uint64,bytes)"
      | "expectCallMinGas(address,uint256,uint64,bytes,uint64)"
      | "expectEmit()"
      | "expectEmit(bool,bool,bool,bool)"
      | "expectEmit(bool,bool,bool,bool,address)"
      | "expectEmit(address)"
      | "expectRevert(bytes4)"
      | "expectRevert(bytes)"
      | "expectRevert()"
      | "expectSafeMemory"
      | "expectSafeMemoryCall"
      | "fee"
      | "ffi"
      | "fsMetadata"
      | "getBlobBaseFee"
      | "getBlockNumber"
      | "getBlockTimestamp"
      | "getCode"
      | "getDeployedCode"
      | "getLabel"
      | "getMappingKeyAndParentOf"
      | "getMappingLength"
      | "getMappingSlotAt"
      | "getNonce(address)"
      | "getNonce((address,uint256,uint256,uint256))"
      | "getRecordedLogs"
      | "indexOf"
      | "isContext"
      | "isDir"
      | "isFile"
      | "isPersistent"
      | "keyExists"
      | "keyExistsJson"
      | "keyExistsToml"
      | "label"
      | "lastCallGas"
      | "load"
      | "loadAllocs"
      | "makePersistent(address[])"
      | "makePersistent(address,address)"
      | "makePersistent(address)"
      | "makePersistent(address,address,address)"
      | "mockCall(address,uint256,bytes,bytes)"
      | "mockCall(address,bytes,bytes)"
      | "mockCallRevert(address,uint256,bytes,bytes)"
      | "mockCallRevert(address,bytes,bytes)"
      | "parseAddress"
      | "parseBool"
      | "parseBytes"
      | "parseBytes32"
      | "parseInt"
      | "parseJson(string)"
      | "parseJson(string,string)"
      | "parseJsonAddress"
      | "parseJsonAddressArray"
      | "parseJsonBool"
      | "parseJsonBoolArray"
      | "parseJsonBytes"
      | "parseJsonBytes32"
      | "parseJsonBytes32Array"
      | "parseJsonBytesArray"
      | "parseJsonInt"
      | "parseJsonIntArray"
      | "parseJsonKeys"
      | "parseJsonString"
      | "parseJsonStringArray"
      | "parseJsonUint"
      | "parseJsonUintArray"
      | "parseToml(string,string)"
      | "parseToml(string)"
      | "parseTomlAddress"
      | "parseTomlAddressArray"
      | "parseTomlBool"
      | "parseTomlBoolArray"
      | "parseTomlBytes"
      | "parseTomlBytes32"
      | "parseTomlBytes32Array"
      | "parseTomlBytesArray"
      | "parseTomlInt"
      | "parseTomlIntArray"
      | "parseTomlKeys"
      | "parseTomlString"
      | "parseTomlStringArray"
      | "parseTomlUint"
      | "parseTomlUintArray"
      | "parseUint"
      | "pauseGasMetering"
      | "prank(address,address)"
      | "prank(address)"
      | "prevrandao(bytes32)"
      | "prevrandao(uint256)"
      | "projectRoot"
      | "prompt"
      | "promptAddress"
      | "promptSecret"
      | "promptUint"
      | "readCallers"
      | "readDir(string,uint64)"
      | "readDir(string,uint64,bool)"
      | "readDir(string)"
      | "readFile"
      | "readFileBinary"
      | "readLine"
      | "readLink"
      | "record"
      | "recordLogs"
      | "rememberKey"
      | "removeDir"
      | "removeFile"
      | "replace"
      | "resetNonce"
      | "resumeGasMetering"
      | "revertTo"
      | "revertToAndDelete"
      | "revokePersistent(address[])"
      | "revokePersistent(address)"
      | "roll"
      | "rollFork(bytes32)"
      | "rollFork(uint256,uint256)"
      | "rollFork(uint256)"
      | "rollFork(uint256,bytes32)"
      | "rpc"
      | "rpcUrl"
      | "rpcUrlStructs"
      | "rpcUrls"
      | "selectFork"
      | "serializeAddress(string,string,address[])"
      | "serializeAddress(string,string,address)"
      | "serializeBool(string,string,bool[])"
      | "serializeBool(string,string,bool)"
      | "serializeBytes(string,string,bytes[])"
      | "serializeBytes(string,string,bytes)"
      | "serializeBytes32(string,string,bytes32[])"
      | "serializeBytes32(string,string,bytes32)"
      | "serializeInt(string,string,int256)"
      | "serializeInt(string,string,int256[])"
      | "serializeJson"
      | "serializeString(string,string,string[])"
      | "serializeString(string,string,string)"
      | "serializeUint(string,string,uint256)"
      | "serializeUint(string,string,uint256[])"
      | "serializeUintToHex"
      | "setEnv"
      | "setNonce"
      | "setNonceUnsafe"
      | "sign(bytes32)"
      | "sign(address,bytes32)"
      | "sign((address,uint256,uint256,uint256),bytes32)"
      | "sign(uint256,bytes32)"
      | "signP256"
      | "skip"
      | "sleep"
      | "snapshot"
      | "split"
      | "startBroadcast()"
      | "startBroadcast(address)"
      | "startBroadcast(uint256)"
      | "startMappingRecording"
      | "startPrank(address)"
      | "startPrank(address,address)"
      | "startStateDiffRecording"
      | "stopAndReturnStateDiff"
      | "stopBroadcast"
      | "stopExpectSafeMemory"
      | "stopMappingRecording"
      | "stopPrank"
      | "store"
      | "toBase64(string)"
      | "toBase64(bytes)"
      | "toBase64URL(string)"
      | "toBase64URL(bytes)"
      | "toLowercase"
      | "toString(address)"
      | "toString(uint256)"
      | "toString(bytes)"
      | "toString(bool)"
      | "toString(int256)"
      | "toString(bytes32)"
      | "toUppercase"
      | "transact(uint256,bytes32)"
      | "transact(bytes32)"
      | "trim"
      | "tryFfi"
      | "txGasPrice"
      | "unixTime"
      | "warp"
      | "writeFile"
      | "writeFileBinary"
      | "writeJson(string,string,string)"
      | "writeJson(string,string)"
      | "writeLine"
      | "writeToml(string,string,string)"
      | "writeToml(string,string)"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "accesses", values: [string]): string;
  encodeFunctionData(
    functionFragment: "activeFork",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "addr", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "allowCheatcodes",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRel(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32[],bytes32[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256[],int256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address,address,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address[],address[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address[],address[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool,bool,string)",
    values: [boolean, boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256[],uint256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool[],bool[])",
    values: [boolean[], boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256[],int256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256[],uint256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32,bytes32,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string[],string[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes32[],bytes32[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes,bytes,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool[],bool[],string)",
    values: [boolean[], boolean[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes[],bytes[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string[],string[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bytes[],bytes[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(bool,bool)",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEq(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertFalse(bool,string)",
    values: [boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertFalse(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGe(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGeDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGt(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLe(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLt(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertLtDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32[],bytes32[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256[],int256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool,bool,string)",
    values: [boolean, boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes[],bytes[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool,bool)",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool[],bool[])",
    values: [boolean[], boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address[],address[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256,int256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256[],uint256[])",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bool[],bool[],string)",
    values: [boolean[], boolean[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address[],address[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address,address,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes,bytes,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256[],uint256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32,bytes32,string)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string[],string[],string)",
    values: [string[], string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes32[],bytes32[],string)",
    values: [BytesLike[], BytesLike[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(string[],string[])",
    values: [string[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256[],int256[],string)",
    values: [BigNumberish[], BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(bytes[],bytes[])",
    values: [BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEq(int256,int256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertTrue(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "assertTrue(bool,string)",
    values: [boolean, string]
  ): string;
  encodeFunctionData(functionFragment: "assume", values: [boolean]): string;
  encodeFunctionData(
    functionFragment: "blobBaseFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "breakpoint(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "breakpoint(string,bool)",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "broadcast(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "chainId",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "clearMockedCalls",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "closeFile", values: [string]): string;
  encodeFunctionData(functionFragment: "coinbase", values: [string]): string;
  encodeFunctionData(
    functionFragment: "computeCreate2Address(bytes32,bytes32)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "computeCreate2Address(bytes32,bytes32,address)",
    values: [BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "computeCreateAddress",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "copyFile",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "createDir",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "createFork(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createFork(string,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFork(string,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createSelectFork(string,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createSelectFork(string,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createSelectFork(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createWallet(uint256,string)",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deal",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteSnapshot",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteSnapshots",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,string,uint32,string)",
    values: [string, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,uint32,string)",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,uint32)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deriveKey(string,string,uint32)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "difficulty",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "dumpState", values: [string]): string;
  encodeFunctionData(
    functionFragment: "envAddress(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envAddress(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBool(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBool(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes32(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envBytes32(string)",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "envExists", values: [string]): string;
  encodeFunctionData(
    functionFragment: "envInt(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envInt(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bytes32[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,int256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bool)",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bytes[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,uint256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,string[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bytes)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,int256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,address[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envOr(string,string,bool[])",
    values: [string, string, boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "envString(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "envString(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envUint(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "envUint(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "etch",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "eth_getLogs",
    values: [BigNumberish, BigNumberish, string, BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "exists", values: [string]): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,uint256,uint64,bytes)",
    values: [string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,uint256,uint64,bytes,uint64)",
    values: [string, BigNumberish, BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,uint256,bytes,uint64)",
    values: [string, BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,bytes)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,bytes,uint64)",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCall(address,uint256,bytes)",
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCallMinGas(address,uint256,uint64,bytes)",
    values: [string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectCallMinGas(address,uint256,uint64,bytes,uint64)",
    values: [string, BigNumberish, BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "expectEmit()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "expectEmit(bool,bool,bool,bool)",
    values: [boolean, boolean, boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "expectEmit(bool,bool,bool,bool,address)",
    values: [boolean, boolean, boolean, boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "expectEmit(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "expectRevert(bytes4)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectRevert(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "expectRevert()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "expectSafeMemory",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "expectSafeMemoryCall",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "fee", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "ffi", values: [string[]]): string;
  encodeFunctionData(functionFragment: "fsMetadata", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getBlobBaseFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getCode", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getDeployedCode",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getLabel", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getMappingKeyAndParentOf",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMappingLength",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMappingSlotAt",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonce(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonce((address,uint256,uint256,uint256))",
    values: [VmSafe.WalletStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getRecordedLogs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "indexOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isContext",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "isDir", values: [string]): string;
  encodeFunctionData(functionFragment: "isFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "isPersistent",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyExists",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyExistsJson",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyExistsToml",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "label",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "lastCallGas",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "load",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "loadAllocs", values: [string]): string;
  encodeFunctionData(
    functionFragment: "makePersistent(address[])",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "makePersistent(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "makePersistent(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "makePersistent(address,address,address)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "mockCall(address,uint256,bytes,bytes)",
    values: [string, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mockCall(address,bytes,bytes)",
    values: [string, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mockCallRevert(address,uint256,bytes,bytes)",
    values: [string, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mockCallRevert(address,bytes,bytes)",
    values: [string, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "parseAddress",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "parseBool", values: [string]): string;
  encodeFunctionData(functionFragment: "parseBytes", values: [string]): string;
  encodeFunctionData(
    functionFragment: "parseBytes32",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "parseInt", values: [string]): string;
  encodeFunctionData(
    functionFragment: "parseJson(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJson(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonAddressArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBool",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBoolArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes32",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytes32Array",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonBytesArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonInt",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonIntArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonKeys",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonString",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonStringArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonUint",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseJsonUintArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseToml(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseToml(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlAddressArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBool",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBoolArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes32",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytes32Array",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlBytesArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlInt",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlIntArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlKeys",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlString",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlStringArray",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlUint",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "parseTomlUintArray",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "parseUint", values: [string]): string;
  encodeFunctionData(
    functionFragment: "pauseGasMetering",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "prank(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "prank(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "prevrandao(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "prevrandao(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "projectRoot",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "prompt", values: [string]): string;
  encodeFunctionData(
    functionFragment: "promptAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "promptSecret",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "promptUint", values: [string]): string;
  encodeFunctionData(
    functionFragment: "readCallers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "readDir(string,uint64)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readDir(string,uint64,bool)",
    values: [string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "readDir(string)",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "readFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "readFileBinary",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "readLine", values: [string]): string;
  encodeFunctionData(functionFragment: "readLink", values: [string]): string;
  encodeFunctionData(functionFragment: "record", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recordLogs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rememberKey",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeDir",
    values: [string, boolean]
  ): string;
  encodeFunctionData(functionFragment: "removeFile", values: [string]): string;
  encodeFunctionData(
    functionFragment: "replace",
    values: [string, string, string]
  ): string;
  encodeFunctionData(functionFragment: "resetNonce", values: [string]): string;
  encodeFunctionData(
    functionFragment: "resumeGasMetering",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revertTo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "revertToAndDelete",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "revokePersistent(address[])",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "revokePersistent(address)",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "roll", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "rollFork(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "rollFork(uint256,uint256)",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rollFork(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rollFork(uint256,bytes32)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "rpc", values: [string, string]): string;
  encodeFunctionData(functionFragment: "rpcUrl", values: [string]): string;
  encodeFunctionData(
    functionFragment: "rpcUrlStructs",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rpcUrls", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "selectFork",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeAddress(string,string,address[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeAddress(string,string,address)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBool(string,string,bool[])",
    values: [string, string, boolean[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBool(string,string,bool)",
    values: [string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes(string,string,bytes[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes(string,string,bytes)",
    values: [string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes32(string,string,bytes32[])",
    values: [string, string, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeBytes32(string,string,bytes32)",
    values: [string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeInt(string,string,int256)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeInt(string,string,int256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeJson",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeString(string,string,string[])",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeString(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUint(string,string,uint256)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUint(string,string,uint256[])",
    values: [string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "serializeUintToHex",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setEnv",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setNonce",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setNonceUnsafe",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(address,bytes32)",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign((address,uint256,uint256,uint256),bytes32)",
    values: [VmSafe.WalletStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sign(uint256,bytes32)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "signP256",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "skip", values: [boolean]): string;
  encodeFunctionData(functionFragment: "sleep", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "snapshot", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "split",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "startBroadcast(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "startMappingRecording",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startPrank(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "startPrank(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "startStateDiffRecording",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopAndReturnStateDiff",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopBroadcast",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopExpectSafeMemory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stopMappingRecording",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "stopPrank", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "store",
    values: [string, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64URL(string)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toBase64URL(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "toLowercase", values: [string]): string;
  encodeFunctionData(
    functionFragment: "toString(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bool)",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(int256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "toString(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "toUppercase", values: [string]): string;
  encodeFunctionData(
    functionFragment: "transact(uint256,bytes32)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transact(bytes32)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "trim", values: [string]): string;
  encodeFunctionData(functionFragment: "tryFfi", values: [string[]]): string;
  encodeFunctionData(
    functionFragment: "txGasPrice",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "unixTime", values?: undefined): string;
  encodeFunctionData(functionFragment: "warp", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "writeFile",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeFileBinary",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "writeJson(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeJson(string,string)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeLine",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeToml(string,string,string)",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeToml(string,string)",
    values: [string, string]
  ): string;

  decodeFunctionResult(functionFragment: "accesses", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "activeFork", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addr", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "allowCheatcodes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbs(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRel(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32[],bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256[],int256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address,address,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address[],address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address[],address[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool,bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256[],uint256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool[],bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256[],int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256[],uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32,bytes32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string[],string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes32[],bytes32[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes,bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool[],bool[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes[],bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string[],string[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bytes[],bytes[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(bool,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEq(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertEqDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertFalse(bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertFalse(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGe(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGeDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGt(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertGtDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLe(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLeDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLt(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertLtDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32[],bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256[],int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool,bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes[],bytes[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool[],bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address[],address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256,int256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256[],uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bool[],bool[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address[],address[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address,address,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes,bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256[],uint256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32,bytes32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string[],string[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes32[],bytes32[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(string[],string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256[],int256[],string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(bytes[],bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEq(int256,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(int256,int256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertNotEqDecimal(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertTrue(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertTrue(bool,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assume", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "blobBaseFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "breakpoint(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "breakpoint(string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "broadcast(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "chainId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "clearMockedCalls",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "closeFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "coinbase", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "computeCreate2Address(bytes32,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "computeCreate2Address(bytes32,bytes32,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "computeCreateAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "copyFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createDir", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createFork(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFork(string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFork(string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createSelectFork(string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createSelectFork(string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createSelectFork(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createWallet(uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deal", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deleteSnapshot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteSnapshots",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,string,uint32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,uint32,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deriveKey(string,string,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "difficulty", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dumpState", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "envAddress(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envAddress(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBool(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBool(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes32(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envBytes32(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "envExists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "envInt(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envInt(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envOr(string,string,bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envString(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envString(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envUint(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "envUint(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "etch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "eth_getLogs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "exists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,uint256,uint64,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,uint256,uint64,bytes,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,uint256,bytes,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,bytes,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCall(address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCallMinGas(address,uint256,uint64,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectCallMinGas(address,uint256,uint64,bytes,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectEmit()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectEmit(bool,bool,bool,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectEmit(bool,bool,bool,bool,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectEmit(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectRevert(bytes4)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectRevert(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectRevert()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectSafeMemory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expectSafeMemoryCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ffi", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fsMetadata", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBlobBaseFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCode", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeployedCode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getLabel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMappingKeyAndParentOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMappingLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMappingSlotAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonce(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonce((address,uint256,uint256,uint256))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRecordedLogs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "indexOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isContext", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isDir", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isPersistent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "keyExists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "keyExistsJson",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "keyExistsToml",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "label", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastCallGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "load", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "loadAllocs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "makePersistent(address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makePersistent(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makePersistent(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makePersistent(address,address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mockCall(address,uint256,bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mockCall(address,bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mockCallRevert(address,uint256,bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mockCallRevert(address,bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseBool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "parseBytes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parseBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseInt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parseJson(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJson(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonAddressArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBoolArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytes32Array",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonBytesArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonInt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonIntArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonStringArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonUint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseJsonUintArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseToml(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseToml(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlAddressArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBoolArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytes32Array",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlBytesArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlInt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlIntArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlStringArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlUint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "parseTomlUintArray",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parseUint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pauseGasMetering",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prank(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prank(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prevrandao(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prevrandao(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "projectRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "prompt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "promptAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "promptSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "promptUint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "readCallers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string,uint64)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string,uint64,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDir(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "readFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "readFileBinary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "readLine", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "readLink", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "record", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "recordLogs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rememberKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "removeDir", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeFile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "replace", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resetNonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resumeGasMetering",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revertTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "revertToAndDelete",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokePersistent(address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokePersistent(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "roll", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rollFork(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollFork(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollFork(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollFork(uint256,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rpc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rpcUrl", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rpcUrlStructs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rpcUrls", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "selectFork", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "serializeAddress(string,string,address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeAddress(string,string,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBool(string,string,bool[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBool(string,string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes(string,string,bytes[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes(string,string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes32(string,string,bytes32[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeBytes32(string,string,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeInt(string,string,int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeInt(string,string,int256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeJson",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeString(string,string,string[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeString(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUint(string,string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUint(string,string,uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "serializeUintToHex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setEnv", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setNonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setNonceUnsafe",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign(address,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign((address,uint256,uint256,uint256),bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sign(uint256,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "signP256", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "skip", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sleep", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "snapshot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "split", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startBroadcast(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startMappingRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startPrank(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startPrank(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startStateDiffRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopAndReturnStateDiff",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopBroadcast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopExpectSafeMemory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stopMappingRecording",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stopPrank", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "store", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "toBase64(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64URL(string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toBase64URL(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toLowercase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(int256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toString(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toUppercase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transact(uint256,bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transact(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "trim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tryFfi", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "txGasPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unixTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "warp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "writeFile", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "writeFileBinary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeJson(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeJson(string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "writeLine", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "writeToml(string,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeToml(string,string)",
    data: BytesLike
  ): Result;

  events: {};
}

export interface Vm extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VmInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the identifier of the currently active fork. Reverts if no fork is currently active.
     */
    activeFork(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { forkId: BigNumber }>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { keyAddr: string }>;

    /**
     * In forking mode, explicitly grant the given address cheatcode access.
     */
    allowCheatcodes(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<[void]>;

    /**
     * Sets `block.blobbasefee`
     */
    blobBaseFee(
      newBlobBaseFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.chainid`.
     */
    chainId(
      newChainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Clears all mocked calls.
     */
    clearMockedCalls(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.coinbase`.
     */
    coinbase(
      newCoinbase: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
     */
    "createFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
     */
    "createFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createSelectFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, returns the identifier of the fork.
     */
    "createSelectFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
     */
    "createSelectFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets an address' balance.
     */
    deal(
      account: string,
      newBalance: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes the snapshot with the given ID created by `snapshot`. Takes the snapshot ID to delete. Returns `true` if the snapshot was successfully deleted. Returns `false` if the snapshot does not exist.
     */
    deleteSnapshot(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes _all_ snapshots previously created by `snapshot`.
     */
    deleteSnapshots(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { privateKey: BigNumber }>;

    /**
     * Sets `block.difficulty`. Not available on EVM versions from Paris onwards. Use `prevrandao` instead. Reverts if used on unsupported EVM versions.
     */
    difficulty(
      newDifficulty: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Dump a genesis JSON file's `allocs` to disk.
     */
    dumpState(
      pathToStateJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { value: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]] & { value: boolean[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(
      name: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<[boolean] & { value: boolean }>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<[boolean[]] & { value: boolean[] }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { value: string[] }>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { value: BigNumber }>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { value: BigNumber[] }>;

    /**
     * Sets an address' code.
     */
    etch(
      target: string,
      newRuntimeBytecode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expect a call to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects given number of calls to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects a call to an address with the specified calldata. Calldata can either be a strict or a partial match.
     */
    "expectCall(address,bytes)"(
      callee: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects given number of calls to an address with the specified calldata.
     */
    "expectCall(address,bytes,uint64)"(
      callee: string,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects a call to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prepare an expected log with all topic and data checks enabled. Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data.
     */
    "expectEmit()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.). Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
     */
    "expectEmit(bool,bool,bool,bool)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(bool,bool,bool,bool,address)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(address)"(
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects an error on next call that starts with the revert data.
     */
    "expectRevert(bytes4)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects an error on next call that exactly matches the revert data.
     */
    "expectRevert(bytes)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expects an error on next call with any revert data.
     */
    "expectRevert()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemory(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemoryCall(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.basefee`.
     */
    fee(
      newBasefee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.FsMetadataStructOutput] & {
        metadata: VmSafe.FsMetadataStructOutput;
      }
    >;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blobBaseFee: BigNumber }>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { height: BigNumber }>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { timestamp: BigNumber }>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { creationBytecode: string }>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { runtimeBytecode: string }>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(
      account: string,
      overrides?: CallOverrides
    ): Promise<[string] & { currentLabel: string }>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the account is marked as persistent.
     */
    isPersistent(
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { persistent: boolean }>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(
      overrides?: CallOverrides
    ): Promise<[VmSafe.GasStructOutput] & { gas: VmSafe.GasStructOutput }>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Load a genesis JSON file's `allocs` into the in-memory revm state.
     */
    loadAllocs(
      pathToAllocsJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address)"(
      account0: string,
      account1: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Marks that the account(s) should use persistent storage across fork swaps in a multifork setup Meaning, changes made to the state of this account will be kept when switching forks.
     */
    "makePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address,address)"(
      account0: string,
      account1: string,
      account2: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Mocks a call to an address with a specific `msg.value`, returning specified data. Calldata match takes precedence over `msg.value` in case of ambiguity.
     */
    "mockCall(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Mocks a call to an address, returning specified data. Calldata can either be strict or a partial match, e.g. if you only pass a Solidity selector to the expected calldata, then the entire Solidity function will be mocked.
     */
    "mockCall(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Reverts a call to an address with a specific `msg.value`, with specified revert data.
     */
    "mockCallRevert(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Reverts a call to an address with specified revert data.
     */
    "mockCallRevert(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { parsedValue: boolean }>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[string] & { parsedValue: string }>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { parsedValue: BigNumber }>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { keys: string[] }>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<[string] & { abiEncodedData: string }>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[boolean[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { keys: string[] }>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { parsedValue: BigNumber }>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
     */
    "prank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address.
     */
    "prank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(bytes32)"(
      newPrevrandao: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(uint256)"(
      newPrevrandao: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(
      overrides?: CallOverrides
    ): Promise<[string] & { path: string }>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
     */
    readCallers(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<
      [VmSafe.DirEntryStructOutput[]] & {
        entries: VmSafe.DirEntryStructOutput[];
      }
    >;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    /**
     * Reads next line of file to string.
     */
    readLine(
      path: string,
      overrides?: CallOverrides
    ): Promise<[string] & { line: string }>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(
      linkPath: string,
      overrides?: CallOverrides
    ): Promise<[string] & { targetPath: string }>;

    /**
     * Records all storage reads and writes.
     */
    record(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
     */
    resetNonce(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Revert the state of the EVM to a previous snapshot Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted. Returns `false` if the snapshot does not exist. **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
     */
    revertTo(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted and deleted. Returns `false` if the snapshot does not exist.
     */
    revertToAndDelete(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `revokePersistent(address)`.
     */
    "revokePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Revokes persistent status from the address, previously added via `makePersistent`.
     */
    "revokePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.height`.
     */
    roll(
      newHeight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Updates the currently active fork to given transaction. This will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block.
     */
    "rollFork(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Updates the given fork to given block number.
     */
    "rollFork(uint256,uint256)"(
      forkId: BigNumberish,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Updates the currently active fork to given block number This is similar to `roll` but for the currently active fork.
     */
    "rollFork(uint256)"(
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
     */
    "rollFork(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(
      rpcAlias: string,
      overrides?: CallOverrides
    ): Promise<[string] & { json: string }>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(
      overrides?: CallOverrides
    ): Promise<[VmSafe.RpcStructOutput[]] & { urls: VmSafe.RpcStructOutput[] }>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(
      overrides?: CallOverrides
    ): Promise<[[string, string][]] & { urls: [string, string][] }>;

    /**
     * Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
     */
    selectFork(
      forkId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the nonce of an account. Must be higher than the current nonce of the account.
     */
    setNonce(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the nonce of an account to an arbitrary value.
     */
    setNonceUnsafe(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { r: string; s: string }>;

    /**
     * Marks a test as skipped. Must be called at the top of the test.
     */
    skip(
      skipTest: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Snapshot the current state of the evm. Returns the ID of the snapshot that was created. To revert a snapshot use `revertTo`.
     */
    snapshot(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<[string[]] & { outputs: string[] }>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
     */
    "startPrank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
     */
    "startPrank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stops all safe memory expectation in the current subcontext.
     */
    stopExpectSafeMemory(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Resets subsequent calls' `msg.sender` to be `address(this)`.
     */
    stopPrank(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stores a value to an address' storage slot.
     */
    store(
      target: string,
      slot: BytesLike,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { stringifiedValue: string }>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Fetches the given transaction from the given fork and executes it on the current state.
     */
    "transact(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Fetches the given transaction from the active fork and executes it on the current state.
     */
    "transact(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(
      input: string,
      overrides?: CallOverrides
    ): Promise<[string] & { output: string }>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `tx.gasprice`.
     */
    txGasPrice(
      newGasPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets `block.timestamp`.
     */
    warp(
      newTimestamp: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
   */
  accesses(
    target: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the identifier of the currently active fork. Reverts if no fork is currently active.
   */
  activeFork(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the address for a given private key.
   */
  addr(privateKey: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * In forking mode, explicitly grant the given address cheatcode access.
   */
  allowCheatcodes(
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
   */
  "assertApproxEqAbs(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
   */
  "assertApproxEqAbs(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
   */
  "assertApproxEqAbs(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
   */
  "assertApproxEqAbs(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
   */
  "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
   */
  "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
   */
  "assertApproxEqRel(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
   */
  "assertApproxEqRel(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
   */
  "assertApproxEqRel(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
   */
  "assertApproxEqRel(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
   */
  "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
   */
  "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    maxPercentDelta: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are equal.
   */
  "assertEq(bytes32[],bytes32[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(int256[],int256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are equal and includes error message into revert string on failure.
   */
  "assertEq(address,address,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are equal and includes error message into revert string on failure.
   */
  "assertEq(string,string,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are equal.
   */
  "assertEq(address[],address[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
   */
  "assertEq(address[],address[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bool,bool,string)"(
    left: boolean,
    right: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are equal.
   */
  "assertEq(address,address)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(uint256[],uint256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are equal.
   */
  "assertEq(bool[],bool[])"(
    left: boolean[],
    right: boolean[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are equal.
   */
  "assertEq(int256[],int256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are equal.
   */
  "assertEq(bytes32,bytes32)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
   */
  "assertEq(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256 values are equal.
   */
  "assertEq(uint256[],uint256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are equal.
   */
  "assertEq(bytes,bytes)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal.
   */
  "assertEq(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes32,bytes32,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are equal.
   */
  "assertEq(string[],string[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes32[],bytes32[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes,bytes,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bool[],bool[],string)"(
    left: boolean[],
    right: boolean[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are equal.
   */
  "assertEq(bytes[],bytes[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
   */
  "assertEq(string[],string[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are equal.
   */
  "assertEq(string,string)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
   */
  "assertEq(bytes[],bytes[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are equal.
   */
  "assertEq(bool,bool)"(
    left: boolean,
    right: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal.
   */
  "assertEq(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
   */
  "assertEqDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
   */
  "assertEqDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertEqDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertEqDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is false and includes error message into revert string on failure.
   */
  "assertFalse(bool,string)"(
    condition: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is false.
   */
  "assertFalse(bool)"(
    condition: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second.
   */
  "assertGe(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
   */
  "assertGe(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second.
   */
  "assertGe(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
   */
  "assertGe(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
   */
  "assertGeDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGeDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGeDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
   */
  "assertGeDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second.
   */
  "assertGt(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
   */
  "assertGt(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second.
   */
  "assertGt(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
   */
  "assertGt(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGtDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertGtDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
   */
  "assertGtDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
   */
  "assertGtDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
   */
  "assertLe(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second.
   */
  "assertLe(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second.
   */
  "assertLe(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
   */
  "assertLe(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
   */
  "assertLeDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLeDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLeDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
   */
  "assertLeDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second.
   */
  "assertLt(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
   */
  "assertLt(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
   */
  "assertLt(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second.
   */
  "assertLt(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
   */
  "assertLtDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLtDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertLtDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
   */
  "assertLtDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are not equal.
   */
  "assertNotEq(bytes32[],bytes32[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are not equal.
   */
  "assertNotEq(int256[],int256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bool,bool,string)"(
    left: boolean,
    right: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes[],bytes[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bool` values are not equal.
   */
  "assertNotEq(bool,bool)"(
    left: boolean,
    right: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are not equal.
   */
  "assertNotEq(bool[],bool[])"(
    left: boolean[],
    right: boolean[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are not equal.
   */
  "assertNotEq(bytes,bytes)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are not equal.
   */
  "assertNotEq(address[],address[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(int256,int256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are not equal.
   */
  "assertNotEq(uint256[],uint256[])"(
    left: BigNumberish[],
    right: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bool[],bool[],string)"(
    left: boolean[],
    right: boolean[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are not equal.
   */
  "assertNotEq(string,string)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(address[],address[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `string` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(string,string,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(address,address,string)"(
    left: string,
    right: string,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are not equal.
   */
  "assertNotEq(bytes32,bytes32)"(
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes,bytes,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(uint256[],uint256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `address` values are not equal.
   */
  "assertNotEq(address,address)"(
    left: string,
    right: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes32,bytes32,string)"(
    left: BytesLike,
    right: BytesLike,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(string[],string[],string)"(
    left: string[],
    right: string[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal.
   */
  "assertNotEq(uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(bytes32[],bytes32[],string)"(
    left: BytesLike[],
    right: BytesLike[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `string` values are not equal.
   */
  "assertNotEq(string[],string[])"(
    left: string[],
    right: string[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
   */
  "assertNotEq(int256[],int256[],string)"(
    left: BigNumberish[],
    right: BigNumberish[],
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two arrays of `bytes` values are not equal.
   */
  "assertNotEq(bytes[],bytes[])"(
    left: BytesLike[],
    right: BytesLike[],
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal.
   */
  "assertNotEq(int256,int256)"(
    left: BigNumberish,
    right: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
   */
  "assertNotEqDecimal(int256,int256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertNotEqDecimal(int256,int256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
   */
  "assertNotEqDecimal(uint256,uint256,uint256)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
   */
  "assertNotEqDecimal(uint256,uint256,uint256,string)"(
    left: BigNumberish,
    right: BigNumberish,
    decimals: BigNumberish,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is true.
   */
  "assertTrue(bool)"(
    condition: boolean,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Asserts that the given condition is true and includes error message into revert string on failure.
   */
  "assertTrue(bool,string)"(
    condition: boolean,
    error: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * If the condition is false, discard this run's fuzz inputs and generate new ones.
   */
  assume(condition: boolean, overrides?: CallOverrides): Promise<void>;

  /**
   * Sets `block.blobbasefee`
   */
  blobBaseFee(
    newBlobBaseFee: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes a breakpoint to jump to in the debugger.
   */
  "breakpoint(string)"(
    char: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes a conditional breakpoint to jump to in the debugger.
   */
  "breakpoint(string,bool)"(
    char: string,
    value: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
   */
  "broadcast()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
   */
  "broadcast(address)"(
    signer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
   */
  "broadcast(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.chainid`.
   */
  chainId(
    newChainId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Clears all mocked calls.
   */
  clearMockedCalls(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
   */
  closeFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.coinbase`.
   */
  coinbase(
    newCoinbase: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
   */
  "computeCreate2Address(bytes32,bytes32)"(
    salt: BytesLike,
    initCodeHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
   */
  "computeCreate2Address(bytes32,bytes32,address)"(
    salt: BytesLike,
    initCodeHash: BytesLike,
    deployer: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Compute the address a contract will be deployed at for a given deployer address and nonce.
   */
  computeCreateAddress(
    deployer: string,
    nonce: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
   */
  copyFile(
    from: string,
    to: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
   */
  createDir(
    path: string,
    recursive: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
   */
  "createFork(string)"(
    urlOrAlias: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a new fork with the given endpoint and block and returns the identifier of the fork.
   */
  "createFork(string,uint256)"(
    urlOrAlias: string,
    blockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
   */
  "createFork(string,bytes32)"(
    urlOrAlias: string,
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
   */
  "createSelectFork(string,uint256)"(
    urlOrAlias: string,
    blockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, returns the identifier of the fork.
   */
  "createSelectFork(string,bytes32)"(
    urlOrAlias: string,
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
   */
  "createSelectFork(string)"(
    urlOrAlias: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Derives a private key from the name, labels the account with that name, and returns the wallet.
   */
  "createWallet(string)"(
    walletLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Generates a wallet from the private key and returns the wallet.
   */
  "createWallet(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
   */
  "createWallet(uint256,string)"(
    privateKey: BigNumberish,
    walletLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets an address' balance.
   */
  deal(
    account: string,
    newBalance: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes the snapshot with the given ID created by `snapshot`. Takes the snapshot ID to delete. Returns `true` if the snapshot was successfully deleted. Returns `false` if the snapshot does not exist.
   */
  deleteSnapshot(
    snapshotId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes _all_ snapshots previously created by `snapshot`.
   */
  deleteSnapshots(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
   */
  "deriveKey(string,string,uint32,string)"(
    mnemonic: string,
    derivationPath: string,
    index: BigNumberish,
    language: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
   */
  "deriveKey(string,uint32,string)"(
    mnemonic: string,
    index: BigNumberish,
    language: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
   */
  "deriveKey(string,uint32)"(
    mnemonic: string,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
   */
  "deriveKey(string,string,uint32)"(
    mnemonic: string,
    derivationPath: string,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Sets `block.difficulty`. Not available on EVM versions from Paris onwards. Use `prevrandao` instead. Reverts if used on unsupported EVM versions.
   */
  difficulty(
    newDifficulty: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Dump a genesis JSON file's `allocs` to disk.
   */
  dumpState(
    pathToStateJson: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
   */
  "envAddress(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envAddress(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
   */
  "envBool(string)"(name: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBool(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes(string)"(name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes32(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
   */
  "envBytes32(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and returns true if it exists, else returns false.
   */
  envExists(name: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envInt(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
   */
  "envInt(string)"(name: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bytes32[])"(
    name: string,
    delim: string,
    defaultValue: BytesLike[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,int256[])"(
    name: string,
    delim: string,
    defaultValue: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bool)"(
    name: string,
    defaultValue: boolean,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,address)"(
    name: string,
    defaultValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,uint256)"(
    name: string,
    defaultValue: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bytes[])"(
    name: string,
    delim: string,
    defaultValue: BytesLike[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,uint256[])"(
    name: string,
    delim: string,
    defaultValue: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,string[])"(
    name: string,
    delim: string,
    defaultValue: string[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bytes)"(
    name: string,
    defaultValue: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,bytes32)"(
    name: string,
    defaultValue: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,int256)"(
    name: string,
    defaultValue: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,address[])"(
    name: string,
    delim: string,
    defaultValue: string[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string)"(
    name: string,
    defaultValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
   */
  "envOr(string,string,bool[])"(
    name: string,
    delim: string,
    defaultValue: boolean[],
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envString(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
   */
  "envString(string)"(name: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
   */
  "envUint(string)"(
    name: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
   */
  "envUint(string,string)"(
    name: string,
    delim: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Sets an address' code.
   */
  etch(
    target: string,
    newRuntimeBytecode: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets all the logs according to specified filter.
   */
  eth_getLogs(
    fromBlock: BigNumberish,
    toBlock: BigNumberish,
    target: string,
    topics: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the given path points to an existing entity, else returns false.
   */
  exists(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expect a call to an address with the specified `msg.value`, gas, and calldata.
   */
  "expectCall(address,uint256,uint64,bytes)"(
    callee: string,
    msgValue: BigNumberish,
    gas: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
   */
  "expectCall(address,uint256,uint64,bytes,uint64)"(
    callee: string,
    msgValue: BigNumberish,
    gas: BigNumberish,
    data: BytesLike,
    count: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects given number of calls to an address with the specified `msg.value` and calldata.
   */
  "expectCall(address,uint256,bytes,uint64)"(
    callee: string,
    msgValue: BigNumberish,
    data: BytesLike,
    count: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects a call to an address with the specified calldata. Calldata can either be a strict or a partial match.
   */
  "expectCall(address,bytes)"(
    callee: string,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects given number of calls to an address with the specified calldata.
   */
  "expectCall(address,bytes,uint64)"(
    callee: string,
    data: BytesLike,
    count: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects a call to an address with the specified `msg.value` and calldata.
   */
  "expectCall(address,uint256,bytes)"(
    callee: string,
    msgValue: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
   */
  "expectCallMinGas(address,uint256,uint64,bytes)"(
    callee: string,
    msgValue: BigNumberish,
    minGas: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
   */
  "expectCallMinGas(address,uint256,uint64,bytes,uint64)"(
    callee: string,
    msgValue: BigNumberish,
    minGas: BigNumberish,
    data: BytesLike,
    count: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prepare an expected log with all topic and data checks enabled. Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data.
   */
  "expectEmit()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.). Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
   */
  "expectEmit(bool,bool,bool,bool)"(
    checkTopic1: boolean,
    checkTopic2: boolean,
    checkTopic3: boolean,
    checkData: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Same as the previous method, but also checks supplied address against emitting contract.
   */
  "expectEmit(bool,bool,bool,bool,address)"(
    checkTopic1: boolean,
    checkTopic2: boolean,
    checkTopic3: boolean,
    checkData: boolean,
    emitter: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Same as the previous method, but also checks supplied address against emitting contract.
   */
  "expectEmit(address)"(
    emitter: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects an error on next call that starts with the revert data.
   */
  "expectRevert(bytes4)"(
    revertData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects an error on next call that exactly matches the revert data.
   */
  "expectRevert(bytes)"(
    revertData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expects an error on next call with any revert data.
   */
  "expectRevert()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
   */
  expectSafeMemory(
    min: BigNumberish,
    max: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
   */
  expectSafeMemoryCall(
    min: BigNumberish,
    max: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.basefee`.
   */
  fee(
    newBasefee: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Performs a foreign function call via the terminal.
   */
  ffi(
    commandInput: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Given a path, query the file system to get information about a file, directory, etc.
   */
  fsMetadata(
    path: string,
    overrides?: CallOverrides
  ): Promise<VmSafe.FsMetadataStructOutput>;

  /**
   * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
   */
  getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
   */
  getCode(artifactPath: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
   */
  getDeployedCode(
    artifactPath: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the label for the specified address.
   */
  getLabel(account: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the map key and parent of a mapping at a given slot, for a given address.
   */
  getMappingKeyAndParentOf(
    target: string,
    elementSlot: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the number of elements in the mapping at the given slot, for a given address.
   */
  getMappingLength(
    target: string,
    mappingSlot: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
   */
  getMappingSlotAt(
    target: string,
    mappingSlot: BytesLike,
    idx: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the nonce of an account.
   */
  "getNonce(address)"(
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getNonce((address,uint256,uint256,uint256))"(
    wallet: VmSafe.WalletStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets all the recorded logs.
   */
  getRecordedLogs(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
   */
  indexOf(
    input: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns true if `forge` command was executed in given context.
   */
  isContext(context: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns true if the path exists on disk and is pointing at a directory, else returns false.
   */
  isDir(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
   */
  isFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the account is marked as persistent.
   */
  isPersistent(account: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
   */
  keyExists(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Checks if `key` exists in a JSON object.
   */
  keyExistsJson(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Checks if `key` exists in a TOML table.
   */
  keyExistsToml(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Labels an address in call traces.
   */
  label(
    account: string,
    newLabel: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the gas used in the last call.
   */
  lastCallGas(overrides?: CallOverrides): Promise<VmSafe.GasStructOutput>;

  /**
   * Loads a storage slot from an address.
   */
  load(
    target: string,
    slot: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Load a genesis JSON file's `allocs` into the in-memory revm state.
   */
  loadAllocs(
    pathToAllocsJson: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `makePersistent(address)`.
   */
  "makePersistent(address[])"(
    accounts: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `makePersistent(address)`.
   */
  "makePersistent(address,address)"(
    account0: string,
    account1: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Marks that the account(s) should use persistent storage across fork swaps in a multifork setup Meaning, changes made to the state of this account will be kept when switching forks.
   */
  "makePersistent(address)"(
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `makePersistent(address)`.
   */
  "makePersistent(address,address,address)"(
    account0: string,
    account1: string,
    account2: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Mocks a call to an address with a specific `msg.value`, returning specified data. Calldata match takes precedence over `msg.value` in case of ambiguity.
   */
  "mockCall(address,uint256,bytes,bytes)"(
    callee: string,
    msgValue: BigNumberish,
    data: BytesLike,
    returnData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Mocks a call to an address, returning specified data. Calldata can either be strict or a partial match, e.g. if you only pass a Solidity selector to the expected calldata, then the entire Solidity function will be mocked.
   */
  "mockCall(address,bytes,bytes)"(
    callee: string,
    data: BytesLike,
    returnData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Reverts a call to an address with a specific `msg.value`, with specified revert data.
   */
  "mockCallRevert(address,uint256,bytes,bytes)"(
    callee: string,
    msgValue: BigNumberish,
    data: BytesLike,
    revertData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Reverts a call to an address with specified revert data.
   */
  "mockCallRevert(address,bytes,bytes)"(
    callee: string,
    data: BytesLike,
    revertData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Parses the given `string` into an `address`.
   */
  parseAddress(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `bool`.
   */
  parseBool(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses the given `string` into `bytes`.
   */
  parseBytes(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `bytes32`.
   */
  parseBytes32(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses the given `string` into a `int256`.
   */
  parseInt(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * ABI-encodes a JSON object.
   */
  "parseJson(string)"(json: string, overrides?: CallOverrides): Promise<string>;

  /**
   * ABI-encodes a JSON object at `key`.
   */
  "parseJson(string,string)"(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `address`.
   */
  parseJsonAddress(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `address[]`.
   */
  parseJsonAddressArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bool`.
   */
  parseJsonBool(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bool[]`.
   */
  parseJsonBoolArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes`.
   */
  parseJsonBytes(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes32`.
   */
  parseJsonBytes32(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
   */
  parseJsonBytes32Array(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
   */
  parseJsonBytesArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `int256`.
   */
  parseJsonInt(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `int256[]`.
   */
  parseJsonIntArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Returns an array of all the keys in a JSON object.
   */
  parseJsonKeys(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `string`.
   */
  parseJsonString(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `string[]`.
   */
  parseJsonStringArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `uint256`.
   */
  parseJsonUint(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
   */
  parseJsonUintArray(
    json: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * ABI-encodes a TOML table at `key`.
   */
  "parseToml(string,string)"(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * ABI-encodes a TOML table.
   */
  "parseToml(string)"(toml: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `address`.
   */
  parseTomlAddress(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `address[]`.
   */
  parseTomlAddressArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bool`.
   */
  parseTomlBool(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bool[]`.
   */
  parseTomlBoolArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes`.
   */
  parseTomlBytes(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes32`.
   */
  parseTomlBytes32(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
   */
  parseTomlBytes32Array(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
   */
  parseTomlBytesArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `int256`.
   */
  parseTomlInt(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `int256[]`.
   */
  parseTomlIntArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Returns an array of all the keys in a TOML table.
   */
  parseTomlKeys(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `string`.
   */
  parseTomlString(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `string[]`.
   */
  parseTomlStringArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `uint256`.
   */
  parseTomlUint(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
   */
  parseTomlUintArray(
    toml: string,
    key: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Parses the given `string` into a `uint256`.
   */
  parseUint(
    stringifiedValue: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
   */
  pauseGasMetering(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
   */
  "prank(address,address)"(
    msgSender: string,
    txOrigin: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the *next* call's `msg.sender` to be the input address.
   */
  "prank(address)"(
    msgSender: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
   */
  "prevrandao(bytes32)"(
    newPrevrandao: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
   */
  "prevrandao(uint256)"(
    newPrevrandao: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the path of the current project root.
   */
  projectRoot(overrides?: CallOverrides): Promise<string>;

  /**
   * Prompts the user for a string value in the terminal.
   */
  prompt(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for an address in the terminal.
   */
  promptAddress(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for a hidden string value in the terminal.
   */
  promptSecret(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Prompts the user for uint256 in the terminal.
   */
  promptUint(
    promptText: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
   */
  readCallers(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `readDir(string)`.
   */
  "readDir(string,uint64)"(
    path: string,
    maxDepth: BigNumberish,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * See `readDir(string)`.
   */
  "readDir(string,uint64,bool)"(
    path: string,
    maxDepth: BigNumberish,
    followLinks: boolean,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
   */
  "readDir(string)"(
    path: string,
    overrides?: CallOverrides
  ): Promise<VmSafe.DirEntryStructOutput[]>;

  /**
   * Reads the entire content of file to string. `path` is relative to the project root.
   */
  readFile(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads the entire content of file as binary. `path` is relative to the project root.
   */
  readFileBinary(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads next line of file to string.
   */
  readLine(path: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
   */
  readLink(linkPath: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Records all storage reads and writes.
   */
  record(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Record all the transaction logs.
   */
  recordLogs(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Adds a private key to the local forge wallet and returns the address.
   */
  rememberKey(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
   */
  removeDir(
    path: string,
    recursive: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
   */
  removeFile(
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Replaces occurrences of `from` in the given `string` with `to`.
   */
  replace(
    input: string,
    from: string,
    to: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
   */
  resetNonce(
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
   */
  resumeGasMetering(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Revert the state of the EVM to a previous snapshot Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted. Returns `false` if the snapshot does not exist. **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
   */
  revertTo(
    snapshotId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted and deleted. Returns `false` if the snapshot does not exist.
   */
  revertToAndDelete(
    snapshotId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `revokePersistent(address)`.
   */
  "revokePersistent(address[])"(
    accounts: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Revokes persistent status from the address, previously added via `makePersistent`.
   */
  "revokePersistent(address)"(
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.height`.
   */
  roll(
    newHeight: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Updates the currently active fork to given transaction. This will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block.
   */
  "rollFork(bytes32)"(
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Updates the given fork to given block number.
   */
  "rollFork(uint256,uint256)"(
    forkId: BigNumberish,
    blockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Updates the currently active fork to given block number This is similar to `roll` but for the currently active fork.
   */
  "rollFork(uint256)"(
    blockNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
   */
  "rollFork(uint256,bytes32)"(
    forkId: BigNumberish,
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Performs an Ethereum JSON-RPC request to the current fork URL.
   */
  rpc(
    method: string,
    params: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the RPC url for the given alias.
   */
  rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns all rpc urls and their aliases as structs.
   */
  rpcUrlStructs(overrides?: CallOverrides): Promise<VmSafe.RpcStructOutput[]>;

  /**
   * Returns all rpc urls and their aliases `[alias, url][]`.
   */
  rpcUrls(overrides?: CallOverrides): Promise<[string, string][]>;

  /**
   * Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
   */
  selectFork(
    forkId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeAddress(string,string,address[])"(
    objectKey: string,
    valueKey: string,
    values: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeAddress(string,string,address)"(
    objectKey: string,
    valueKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBool(string,string,bool[])"(
    objectKey: string,
    valueKey: string,
    values: boolean[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBool(string,string,bool)"(
    objectKey: string,
    valueKey: string,
    value: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes(string,string,bytes[])"(
    objectKey: string,
    valueKey: string,
    values: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes(string,string,bytes)"(
    objectKey: string,
    valueKey: string,
    value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes32(string,string,bytes32[])"(
    objectKey: string,
    valueKey: string,
    values: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeBytes32(string,string,bytes32)"(
    objectKey: string,
    valueKey: string,
    value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeInt(string,string,int256)"(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeInt(string,string,int256[])"(
    objectKey: string,
    valueKey: string,
    values: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
   */
  serializeJson(
    objectKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeString(string,string,string[])"(
    objectKey: string,
    valueKey: string,
    values: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeString(string,string,string)"(
    objectKey: string,
    valueKey: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeUint(string,string,uint256)"(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  "serializeUint(string,string,uint256[])"(
    objectKey: string,
    valueKey: string,
    values: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * See `serializeJson`.
   */
  serializeUintToHex(
    objectKey: string,
    valueKey: string,
    value: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets environment variables.
   */
  setEnv(
    name: string,
    value: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the nonce of an account. Must be higher than the current nonce of the account.
   */
  setNonce(
    account: string,
    newNonce: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the nonce of an account to an arbitrary value.
   */
  setNonceUnsafe(
    account: string,
    newNonce: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
   */
  "sign(bytes32)"(
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  /**
   * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
   */
  "sign(address,bytes32)"(
    signer: string,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  "sign((address,uint256,uint256,uint256),bytes32)"(
    wallet: VmSafe.WalletStruct,
    digest: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Signs `digest` with `privateKey` using the secp256k1 curve.
   */
  "sign(uint256,bytes32)"(
    privateKey: BigNumberish,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

  /**
   * Signs `digest` with `privateKey` using the secp256r1 curve.
   */
  signP256(
    privateKey: BigNumberish,
    digest: BytesLike,
    overrides?: CallOverrides
  ): Promise<[string, string] & { r: string; s: string }>;

  /**
   * Marks a test as skipped. Must be called at the top of the test.
   */
  skip(
    skipTest: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Suspends execution of the main thread for `duration` milliseconds.
   */
  sleep(
    duration: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Snapshot the current state of the evm. Returns the ID of the snapshot that was created. To revert a snapshot use `revertTo`.
   */
  snapshot(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Splits the given `string` into an array of strings divided by the `delimiter`.
   */
  split(
    input: string,
    delimiter: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
   */
  "startBroadcast()"(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
   */
  "startBroadcast(address)"(
    signer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
   */
  "startBroadcast(uint256)"(
    privateKey: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Starts recording all map SSTOREs for later retrieval.
   */
  startMappingRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
   */
  "startPrank(address)"(
    msgSender: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
   */
  "startPrank(address,address)"(
    msgSender: string,
    txOrigin: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
   */
  startStateDiffRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
   */
  stopAndReturnStateDiff(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stops collecting onchain transactions.
   */
  stopBroadcast(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stops all safe memory expectation in the current subcontext.
   */
  stopExpectSafeMemory(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
   */
  stopMappingRecording(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Resets subsequent calls' `msg.sender` to be `address(this)`.
   */
  stopPrank(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stores a value to an address' storage slot.
   */
  store(
    target: string,
    slot: BytesLike,
    value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Encodes a `string` value to a base64 string.
   */
  "toBase64(string)"(data: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Encodes a `bytes` value to a base64 string.
   */
  "toBase64(bytes)"(
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Encodes a `string` value to a base64url string.
   */
  "toBase64URL(string)"(
    data: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Encodes a `bytes` value to a base64url string.
   */
  "toBase64URL(bytes)"(
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given `string` value to Lowercase.
   */
  toLowercase(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(address)"(
    value: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(uint256)"(
    value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bytes)"(
    value: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bool)"(value: boolean, overrides?: CallOverrides): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(int256)"(
    value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given value to a `string`.
   */
  "toString(bytes32)"(
    value: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Converts the given `string` value to Uppercase.
   */
  toUppercase(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Fetches the given transaction from the given fork and executes it on the current state.
   */
  "transact(uint256,bytes32)"(
    forkId: BigNumberish,
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Fetches the given transaction from the active fork and executes it on the current state.
   */
  "transact(bytes32)"(
    txHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Trims leading and trailing whitespace from the given `string` value.
   */
  trim(input: string, overrides?: CallOverrides): Promise<string>;

  /**
   * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
   */
  tryFfi(
    commandInput: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `tx.gasprice`.
   */
  txGasPrice(
    newGasPrice: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the time since unix epoch in milliseconds.
   */
  unixTime(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets `block.timestamp`.
   */
  warp(
    newTimestamp: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
   */
  writeFile(
    path: string,
    data: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
   */
  writeFileBinary(
    path: string,
    data: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
   */
  "writeJson(string,string,string)"(
    json: string,
    path: string,
    valueKey: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
   */
  "writeJson(string,string)"(
    json: string,
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
   */
  writeLine(
    path: string,
    data: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
   */
  "writeToml(string,string,string)"(
    json: string,
    path: string,
    valueKey: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
   */
  "writeToml(string,string)"(
    json: string,
    path: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: CallOverrides
    ): Promise<
      [string[], string[]] & { readSlots: string[]; writeSlots: string[] }
    >;

    /**
     * Returns the identifier of the currently active fork. Reverts if no fork is currently active.
     */
    activeFork(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the address for a given private key.
     */
    addr(privateKey: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * In forking mode, explicitly grant the given address cheatcode access.
     */
    allowCheatcodes(account: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Sets `block.blobbasefee`
     */
    blobBaseFee(
      newBlobBaseFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets `block.chainid`.
     */
    chainId(newChainId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Clears all mocked calls.
     */
    clearMockedCalls(overrides?: CallOverrides): Promise<void>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(path: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Sets `block.coinbase`.
     */
    coinbase(newCoinbase: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
     */
    "createFork(string)"(
      urlOrAlias: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
     */
    "createFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createSelectFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, returns the identifier of the fork.
     */
    "createSelectFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
     */
    "createSelectFork(string)"(
      urlOrAlias: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.WalletStructOutput>;

    /**
     * Sets an address' balance.
     */
    deal(
      account: string,
      newBalance: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removes the snapshot with the given ID created by `snapshot`. Takes the snapshot ID to delete. Returns `true` if the snapshot was successfully deleted. Returns `false` if the snapshot does not exist.
     */
    deleteSnapshot(
      snapshotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Removes _all_ snapshots previously created by `snapshot`.
     */
    deleteSnapshots(overrides?: CallOverrides): Promise<void>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Sets `block.difficulty`. Not available on EVM versions from Paris onwards. Use `prevrandao` instead. Reverts if used on unsupported EVM versions.
     */
    difficulty(
      newDifficulty: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Dump a genesis JSON file's `allocs` to disk.
     */
    dumpState(
      pathToStateJson: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(name: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Sets an address' code.
     */
    etch(
      target: string,
      newRuntimeBytecode: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: CallOverrides
    ): Promise<VmSafe.EthGetLogsStructOutput[]>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Expect a call to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects given number of calls to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects a call to an address with the specified calldata. Calldata can either be a strict or a partial match.
     */
    "expectCall(address,bytes)"(
      callee: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects given number of calls to an address with the specified calldata.
     */
    "expectCall(address,bytes,uint64)"(
      callee: string,
      data: BytesLike,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects a call to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Prepare an expected log with all topic and data checks enabled. Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data.
     */
    "expectEmit()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.). Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
     */
    "expectEmit(bool,bool,bool,bool)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(bool,bool,bool,bool,address)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      emitter: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(address)"(
      emitter: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects an error on next call that starts with the revert data.
     */
    "expectRevert(bytes4)"(
      revertData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects an error on next call that exactly matches the revert data.
     */
    "expectRevert(bytes)"(
      revertData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expects an error on next call with any revert data.
     */
    "expectRevert()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemory(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemoryCall(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets `block.basefee`.
     */
    fee(newBasefee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(commandInput: string[], overrides?: CallOverrides): Promise<string>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.FsMetadataStructOutput>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(artifactPath: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(account: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, string, string] & {
        found: boolean;
        key: string;
        parent: string;
      }
    >;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: CallOverrides
    ): Promise<VmSafe.LogStructOutput[]>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(path: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if the account is marked as persistent.
     */
    isPersistent(account: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<VmSafe.GasStructOutput>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Load a genesis JSON file's `allocs` into the in-memory revm state.
     */
    loadAllocs(
      pathToAllocsJson: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address[])"(
      accounts: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address)"(
      account0: string,
      account1: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Marks that the account(s) should use persistent storage across fork swaps in a multifork setup Meaning, changes made to the state of this account will be kept when switching forks.
     */
    "makePersistent(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address,address)"(
      account0: string,
      account1: string,
      account2: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mocks a call to an address with a specific `msg.value`, returning specified data. Calldata match takes precedence over `msg.value` in case of ambiguity.
     */
    "mockCall(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mocks a call to an address, returning specified data. Calldata can either be strict or a partial match, e.g. if you only pass a Solidity selector to the expected calldata, then the entire Solidity function will be mocked.
     */
    "mockCall(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reverts a call to an address with a specific `msg.value`, with specified revert data.
     */
    "mockCallRevert(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reverts a call to an address with specified revert data.
     */
    "mockCallRevert(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(overrides?: CallOverrides): Promise<void>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
     */
    "prank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address.
     */
    "prank(address)"(
      msgSender: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(bytes32)"(
      newPrevrandao: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(uint256)"(
      newPrevrandao: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<string>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(promptText: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
     */
    readCallers(
      overrides?: CallOverrides
    ): Promise<
      [number, string, string] & {
        callerMode: number;
        msgSender: string;
        txOrigin: string;
      }
    >;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<VmSafe.DirEntryStructOutput[]>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads next line of file to string.
     */
    readLine(path: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(linkPath: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Records all storage reads and writes.
     */
    record(overrides?: CallOverrides): Promise<void>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(overrides?: CallOverrides): Promise<void>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(path: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
     */
    resetNonce(account: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(overrides?: CallOverrides): Promise<void>;

    /**
     * Revert the state of the EVM to a previous snapshot Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted. Returns `false` if the snapshot does not exist. **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
     */
    revertTo(
      snapshotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted and deleted. Returns `false` if the snapshot does not exist.
     */
    revertToAndDelete(
      snapshotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See `revokePersistent(address)`.
     */
    "revokePersistent(address[])"(
      accounts: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes persistent status from the address, previously added via `makePersistent`.
     */
    "revokePersistent(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets `block.height`.
     */
    roll(newHeight: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Updates the currently active fork to given transaction. This will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block.
     */
    "rollFork(bytes32)"(
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the given fork to given block number.
     */
    "rollFork(uint256,uint256)"(
      forkId: BigNumberish,
      blockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the currently active fork to given block number This is similar to `roll` but for the currently active fork.
     */
    "rollFork(uint256)"(
      blockNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
     */
    "rollFork(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<VmSafe.RpcStructOutput[]>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<[string, string][]>;

    /**
     * Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
     */
    selectFork(forkId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the nonce of an account. Must be higher than the current nonce of the account.
     */
    setNonce(
      account: string,
      newNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the nonce of an account to an arbitrary value.
     */
    setNonceUnsafe(
      account: string,
      newNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, string, string] & { v: number; r: string; s: string }>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { r: string; s: string }>;

    /**
     * Marks a test as skipped. Must be called at the top of the test.
     */
    skip(skipTest: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(duration: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Snapshot the current state of the evm. Returns the ID of the snapshot that was created. To revert a snapshot use `revertTo`.
     */
    snapshot(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(overrides?: CallOverrides): Promise<void>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
     */
    "startPrank(address)"(
      msgSender: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
     */
    "startPrank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: CallOverrides
    ): Promise<VmSafe.AccountAccessStructOutput[]>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(overrides?: CallOverrides): Promise<void>;

    /**
     * Stops all safe memory expectation in the current subcontext.
     */
    stopExpectSafeMemory(overrides?: CallOverrides): Promise<void>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(overrides?: CallOverrides): Promise<void>;

    /**
     * Resets subsequent calls' `msg.sender` to be `address(this)`.
     */
    stopPrank(overrides?: CallOverrides): Promise<void>;

    /**
     * Stores a value to an address' storage slot.
     */
    store(
      target: string,
      slot: BytesLike,
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Fetches the given transaction from the given fork and executes it on the current state.
     */
    "transact(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Fetches the given transaction from the active fork and executes it on the current state.
     */
    "transact(bytes32)"(
      txHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(input: string, overrides?: CallOverrides): Promise<string>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: CallOverrides
    ): Promise<VmSafe.FfiResultStructOutput>;

    /**
     * Sets `tx.gasprice`.
     */
    txGasPrice(
      newGasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets `block.timestamp`.
     */
    warp(newTimestamp: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the currently active fork. Reverts if no fork is currently active.
     */
    activeFork(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * In forking mode, explicitly grant the given address cheatcode access.
     */
    allowCheatcodes(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(condition: boolean, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets `block.blobbasefee`
     */
    blobBaseFee(
      newBlobBaseFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.chainid`.
     */
    chainId(
      newChainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Clears all mocked calls.
     */
    clearMockedCalls(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.coinbase`.
     */
    coinbase(
      newCoinbase: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
     */
    "createFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
     */
    "createFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createSelectFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, returns the identifier of the fork.
     */
    "createSelectFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
     */
    "createSelectFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets an address' balance.
     */
    deal(
      account: string,
      newBalance: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes the snapshot with the given ID created by `snapshot`. Takes the snapshot ID to delete. Returns `true` if the snapshot was successfully deleted. Returns `false` if the snapshot does not exist.
     */
    deleteSnapshot(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes _all_ snapshots previously created by `snapshot`.
     */
    deleteSnapshots(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Sets `block.difficulty`. Not available on EVM versions from Paris onwards. Use `prevrandao` instead. Reverts if used on unsupported EVM versions.
     */
    difficulty(
      newDifficulty: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Dump a genesis JSON file's `allocs` to disk.
     */
    dumpState(
      pathToStateJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Sets an address' code.
     */
    etch(
      target: string,
      newRuntimeBytecode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expect a call to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects given number of calls to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects a call to an address with the specified calldata. Calldata can either be a strict or a partial match.
     */
    "expectCall(address,bytes)"(
      callee: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects given number of calls to an address with the specified calldata.
     */
    "expectCall(address,bytes,uint64)"(
      callee: string,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects a call to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prepare an expected log with all topic and data checks enabled. Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data.
     */
    "expectEmit()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.). Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
     */
    "expectEmit(bool,bool,bool,bool)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(bool,bool,bool,bool,address)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(address)"(
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects an error on next call that starts with the revert data.
     */
    "expectRevert(bytes4)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects an error on next call that exactly matches the revert data.
     */
    "expectRevert(bytes)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expects an error on next call with any revert data.
     */
    "expectRevert()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemory(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemoryCall(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.basefee`.
     */
    fee(
      newBasefee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if the account is marked as persistent.
     */
    isPersistent(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Load a genesis JSON file's `allocs` into the in-memory revm state.
     */
    loadAllocs(
      pathToAllocsJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address)"(
      account0: string,
      account1: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Marks that the account(s) should use persistent storage across fork swaps in a multifork setup Meaning, changes made to the state of this account will be kept when switching forks.
     */
    "makePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address,address)"(
      account0: string,
      account1: string,
      account2: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Mocks a call to an address with a specific `msg.value`, returning specified data. Calldata match takes precedence over `msg.value` in case of ambiguity.
     */
    "mockCall(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Mocks a call to an address, returning specified data. Calldata can either be strict or a partial match, e.g. if you only pass a Solidity selector to the expected calldata, then the entire Solidity function will be mocked.
     */
    "mockCall(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Reverts a call to an address with a specific `msg.value`, with specified revert data.
     */
    "mockCallRevert(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Reverts a call to an address with specified revert data.
     */
    "mockCallRevert(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
     */
    "prank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address.
     */
    "prank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(bytes32)"(
      newPrevrandao: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(uint256)"(
      newPrevrandao: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
     */
    readCallers(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads next line of file to string.
     */
    readLine(path: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(linkPath: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Records all storage reads and writes.
     */
    record(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
     */
    resetNonce(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Revert the state of the EVM to a previous snapshot Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted. Returns `false` if the snapshot does not exist. **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
     */
    revertTo(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted and deleted. Returns `false` if the snapshot does not exist.
     */
    revertToAndDelete(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `revokePersistent(address)`.
     */
    "revokePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Revokes persistent status from the address, previously added via `makePersistent`.
     */
    "revokePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `block.height`.
     */
    roll(
      newHeight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Updates the currently active fork to given transaction. This will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block.
     */
    "rollFork(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Updates the given fork to given block number.
     */
    "rollFork(uint256,uint256)"(
      forkId: BigNumberish,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Updates the currently active fork to given block number This is similar to `roll` but for the currently active fork.
     */
    "rollFork(uint256)"(
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
     */
    "rollFork(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(rpcAlias: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
     */
    selectFork(
      forkId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the nonce of an account. Must be higher than the current nonce of the account.
     */
    setNonce(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the nonce of an account to an arbitrary value.
     */
    setNonceUnsafe(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Marks a test as skipped. Must be called at the top of the test.
     */
    skip(
      skipTest: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Snapshot the current state of the evm. Returns the ID of the snapshot that was created. To revert a snapshot use `revertTo`.
     */
    snapshot(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
     */
    "startPrank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
     */
    "startPrank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stops all safe memory expectation in the current subcontext.
     */
    stopExpectSafeMemory(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Resets subsequent calls' `msg.sender` to be `address(this)`.
     */
    stopPrank(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Stores a value to an address' storage slot.
     */
    store(
      target: string,
      slot: BytesLike,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Fetches the given transaction from the given fork and executes it on the current state.
     */
    "transact(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Fetches the given transaction from the active fork and executes it on the current state.
     */
    "transact(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(input: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets `tx.gasprice`.
     */
    txGasPrice(
      newGasPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Sets `block.timestamp`.
     */
    warp(
      newTimestamp: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Gets all accessed reads and write slot from a `vm.record` session, for a given address.
     */
    accesses(
      target: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the currently active fork. Reverts if no fork is currently active.
     */
    activeFork(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the address for a given private key.
     */
    addr(
      privateKey: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * In forking mode, explicitly grant the given address cheatcode access.
     */
    allowCheatcodes(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
     */
    "assertApproxEqAbs(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Includes error message into revert string on failure.
     */
    "assertApproxEqAbs(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Includes error message into revert string on failure.
     */
    "assertApproxEqRel(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
     */
    "assertApproxEqRel(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`. `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100% Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      maxPercentDelta: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are equal.
     */
    "assertEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are equal.
     */
    "assertEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
     */
    "assertEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are equal.
     */
    "assertEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are equal.
     */
    "assertEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are equal.
     */
    "assertEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are equal.
     */
    "assertEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal and includes error message into revert string on failure.
     */
    "assertEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256 values are equal.
     */
    "assertEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are equal.
     */
    "assertEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal.
     */
    "assertEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are equal.
     */
    "assertEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are equal.
     */
    "assertEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
     */
    "assertEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are equal.
     */
    "assertEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
     */
    "assertEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are equal.
     */
    "assertEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal.
     */
    "assertEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message.
     */
    "assertEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is false and includes error message into revert string on failure.
     */
    "assertFalse(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is false.
     */
    "assertFalse(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second.
     */
    "assertGe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Includes error message into revert string on failure.
     */
    "assertGe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than or equal to second. Formats values with decimals in failure message.
     */
    "assertGeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second.
     */
    "assertGt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second.
     */
    "assertGt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Includes error message into revert string on failure.
     */
    "assertGt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertGtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be greater than second. Formats values with decimals in failure message.
     */
    "assertGtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second.
     */
    "assertLe(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Includes error message into revert string on failure.
     */
    "assertLe(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLeDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than or equal to second. Formats values with decimals in failure message.
     */
    "assertLeDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second.
     */
    "assertLt(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Includes error message into revert string on failure.
     */
    "assertLt(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second.
     */
    "assertLt(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `uint256` values. Expects first value to be less than second. Formats values with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertLtDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compares two `int256` values. Expects first value to be less than second. Formats values with decimals in failure message.
     */
    "assertLtDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal.
     */
    "assertNotEq(bytes32[],bytes32[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are not equal.
     */
    "assertNotEq(int256[],int256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool,bool,string)"(
      left: boolean,
      right: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes[],bytes[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bool` values are not equal.
     */
    "assertNotEq(bool,bool)"(
      left: boolean,
      right: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are not equal.
     */
    "assertNotEq(bool[],bool[])"(
      left: boolean[],
      right: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are not equal.
     */
    "assertNotEq(bytes,bytes)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are not equal.
     */
    "assertNotEq(address[],address[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256,int256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are not equal.
     */
    "assertNotEq(uint256[],uint256[])"(
      left: BigNumberish[],
      right: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bool[],bool[],string)"(
      left: boolean[],
      right: boolean[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are not equal.
     */
    "assertNotEq(string,string)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address[],address[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string,string,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(address,address,string)"(
      left: string,
      right: string,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are not equal.
     */
    "assertNotEq(bytes32,bytes32)"(
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes,bytes,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(uint256[],uint256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `address` values are not equal.
     */
    "assertNotEq(address,address)"(
      left: string,
      right: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32,bytes32,string)"(
      left: BytesLike,
      right: BytesLike,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(string[],string[],string)"(
      left: string[],
      right: string[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal.
     */
    "assertNotEq(uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(bytes32[],bytes32[],string)"(
      left: BytesLike[],
      right: BytesLike[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `string` values are not equal.
     */
    "assertNotEq(string[],string[])"(
      left: string[],
      right: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
     */
    "assertNotEq(int256[],int256[],string)"(
      left: BigNumberish[],
      right: BigNumberish[],
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two arrays of `bytes` values are not equal.
     */
    "assertNotEq(bytes[],bytes[])"(
      left: BytesLike[],
      right: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal.
     */
    "assertNotEq(int256,int256)"(
      left: BigNumberish,
      right: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(int256,int256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `int256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(int256,int256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
     */
    "assertNotEqDecimal(uint256,uint256,uint256)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that two `uint256` values are not equal, formatting them with decimals in failure message. Includes error message into revert string on failure.
     */
    "assertNotEqDecimal(uint256,uint256,uint256,string)"(
      left: BigNumberish,
      right: BigNumberish,
      decimals: BigNumberish,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is true.
     */
    "assertTrue(bool)"(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Asserts that the given condition is true and includes error message into revert string on failure.
     */
    "assertTrue(bool,string)"(
      condition: boolean,
      error: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * If the condition is false, discard this run's fuzz inputs and generate new ones.
     */
    assume(
      condition: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.blobbasefee`
     */
    blobBaseFee(
      newBlobBaseFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes a breakpoint to jump to in the debugger.
     */
    "breakpoint(string)"(
      char: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes a conditional breakpoint to jump to in the debugger.
     */
    "breakpoint(string,bool)"(
      char: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "broadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain.
     */
    "broadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.chainid`.
     */
    chainId(
      newChainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Clears all mocked calls.
     */
    clearMockedCalls(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Closes file for reading, resetting the offset and allowing to read it from beginning with readLine. `path` is relative to the project root.
     */
    closeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.coinbase`.
     */
    coinbase(
      newCoinbase: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
     */
    "computeCreate2Address(bytes32,bytes32,address)"(
      salt: BytesLike,
      initCodeHash: BytesLike,
      deployer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Compute the address a contract will be deployed at for a given deployer address and nonce.
     */
    computeCreateAddress(
      deployer: string,
      nonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Copies the contents of one file to another. This function will **overwrite** the contents of `to`. On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`. Both `from` and `to` are relative to the project root.
     */
    copyFile(
      from: string,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new, empty directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - User lacks permissions to modify `path`. - A parent of the given path doesn't exist and `recursive` is false. - `path` already exists and `recursive` is false. `path` is relative to the project root.
     */
    createDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
     */
    "createFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
     */
    "createFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
     */
    "createSelectFork(string,uint256)"(
      urlOrAlias: string,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction, returns the identifier of the fork.
     */
    "createSelectFork(string,bytes32)"(
      urlOrAlias: string,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
     */
    "createSelectFork(string)"(
      urlOrAlias: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Derives a private key from the name, labels the account with that name, and returns the wallet.
     */
    "createWallet(string)"(
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Generates a wallet from the private key and returns the wallet.
     */
    "createWallet(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Generates a wallet from the private key, labels the account with that name, and returns the wallet.
     */
    "createWallet(uint256,string)"(
      privateKey: BigNumberish,
      walletLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets an address' balance.
     */
    deal(
      account: string,
      newBalance: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes the snapshot with the given ID created by `snapshot`. Takes the snapshot ID to delete. Returns `true` if the snapshot was successfully deleted. Returns `false` if the snapshot does not exist.
     */
    deleteSnapshot(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes _all_ snapshots previously created by `snapshot`.
     */
    deleteSnapshots(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32,string)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32,string)"(
      mnemonic: string,
      index: BigNumberish,
      language: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path `m/44'/60'/0'/0/{index}`.
     */
    "deriveKey(string,uint32)"(
      mnemonic: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Derive a private key from a provided mnenomic string (or mnenomic file path) at `{derivationPath}{index}`.
     */
    "deriveKey(string,string,uint32)"(
      mnemonic: string,
      derivationPath: string,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.difficulty`. Not available on EVM versions from Paris onwards. Use `prevrandao` instead. Reverts if used on unsupported EVM versions.
     */
    difficulty(
      newDifficulty: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Dump a genesis JSON file's `allocs` to disk.
     */
    dumpState(
      pathToStateJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envAddress(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBool(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable was not found or could not be parsed.
     */
    "envBytes32(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and returns true if it exists, else returns false.
     */
    envExists(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable was not found or could not be parsed.
     */
    "envInt(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes32[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,int256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bool`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bool)"(
      name: string,
      defaultValue: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `address`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,address)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,uint256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bytes[])"(
      name: string,
      delim: string,
      defaultValue: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,uint256[])"(
      name: string,
      delim: string,
      defaultValue: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,string[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `bytes32`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,bytes32)"(
      name: string,
      defaultValue: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `int256`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,int256)"(
      name: string,
      defaultValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,address[])"(
      name: string,
      delim: string,
      defaultValue: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string)"(
      name: string,
      defaultValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`. Reverts if the variable could not be parsed. Returns `defaultValue` if the variable was not found.
     */
    "envOr(string,string,bool[])"(
      name: string,
      delim: string,
      defaultValue: boolean[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `string`. Reverts if the variable was not found or could not be parsed.
     */
    "envString(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as `uint256`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string)"(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`. Reverts if the variable was not found or could not be parsed.
     */
    "envUint(string,string)"(
      name: string,
      delim: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Sets an address' code.
     */
    etch(
      target: string,
      newRuntimeBytecode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets all the logs according to specified filter.
     */
    eth_getLogs(
      fromBlock: BigNumberish,
      toBlock: BigNumberish,
      target: string,
      topics: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the given path points to an existing entity, else returns false.
     */
    exists(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expect a call to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
     */
    "expectCall(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      gas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects given number of calls to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects a call to an address with the specified calldata. Calldata can either be a strict or a partial match.
     */
    "expectCall(address,bytes)"(
      callee: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects given number of calls to an address with the specified calldata.
     */
    "expectCall(address,bytes,uint64)"(
      callee: string,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects a call to an address with the specified `msg.value` and calldata.
     */
    "expectCall(address,uint256,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
     */
    "expectCallMinGas(address,uint256,uint64,bytes,uint64)"(
      callee: string,
      msgValue: BigNumberish,
      minGas: BigNumberish,
      data: BytesLike,
      count: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prepare an expected log with all topic and data checks enabled. Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data.
     */
    "expectEmit()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.). Call this function, then emit an event, then call a function. Internally after the call, we check if logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
     */
    "expectEmit(bool,bool,bool,bool)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(bool,bool,bool,bool,address)"(
      checkTopic1: boolean,
      checkTopic2: boolean,
      checkTopic3: boolean,
      checkData: boolean,
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Same as the previous method, but also checks supplied address against emitting contract.
     */
    "expectEmit(address)"(
      emitter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects an error on next call that starts with the revert data.
     */
    "expectRevert(bytes4)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects an error on next call that exactly matches the revert data.
     */
    "expectRevert(bytes)"(
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expects an error on next call with any revert data.
     */
    "expectRevert()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemory(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext. If any other memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
     */
    expectSafeMemoryCall(
      min: BigNumberish,
      max: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.basefee`.
     */
    fee(
      newBasefee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Performs a foreign function call via the terminal.
     */
    ffi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Given a path, query the file system to get information about a file, directory, etc.
     */
    fsMetadata(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.blobbasefee`. You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlobBaseFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.number`. You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the current `block.timestamp`. You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction, and as a result will get optimized out by the compiler. See https://github.com/foundry-rs/foundry/issues/6180
     */
    getBlockTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
     */
    getDeployedCode(
      artifactPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the label for the specified address.
     */
    getLabel(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the map key and parent of a mapping at a given slot, for a given address.
     */
    getMappingKeyAndParentOf(
      target: string,
      elementSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the number of elements in the mapping at the given slot, for a given address.
     */
    getMappingLength(
      target: string,
      mappingSlot: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the elements at index idx of the mapping at the given slot, for a given address. The index must be less than the length of the mapping (i.e. the number of keys in the mapping).
     */
    getMappingSlotAt(
      target: string,
      mappingSlot: BytesLike,
      idx: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the nonce of an account.
     */
    "getNonce(address)"(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getNonce((address,uint256,uint256,uint256))"(
      wallet: VmSafe.WalletStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets all the recorded logs.
     */
    getRecordedLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the index of the first occurrence of a `key` in an `input` string. Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found. Returns 0 in case of an empty `key`.
     */
    indexOf(
      input: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `forge` command was executed in given context.
     */
    isContext(
      context: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a directory, else returns false.
     */
    isDir(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the path exists on disk and is pointing at a regular file, else returns false.
     */
    isFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the account is marked as persistent.
     */
    isPersistent(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a JSON object `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
     */
    keyExists(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a JSON object.
     */
    keyExistsJson(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if `key` exists in a TOML table.
     */
    keyExistsToml(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Labels an address in call traces.
     */
    label(
      account: string,
      newLabel: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the gas used in the last call.
     */
    lastCallGas(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Loads a storage slot from an address.
     */
    load(
      target: string,
      slot: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Load a genesis JSON file's `allocs` into the in-memory revm state.
     */
    loadAllocs(
      pathToAllocsJson: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address)"(
      account0: string,
      account1: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Marks that the account(s) should use persistent storage across fork swaps in a multifork setup Meaning, changes made to the state of this account will be kept when switching forks.
     */
    "makePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `makePersistent(address)`.
     */
    "makePersistent(address,address,address)"(
      account0: string,
      account1: string,
      account2: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Mocks a call to an address with a specific `msg.value`, returning specified data. Calldata match takes precedence over `msg.value` in case of ambiguity.
     */
    "mockCall(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Mocks a call to an address, returning specified data. Calldata can either be strict or a partial match, e.g. if you only pass a Solidity selector to the expected calldata, then the entire Solidity function will be mocked.
     */
    "mockCall(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      returnData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Reverts a call to an address with a specific `msg.value`, with specified revert data.
     */
    "mockCallRevert(address,uint256,bytes,bytes)"(
      callee: string,
      msgValue: BigNumberish,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Reverts a call to an address with specified revert data.
     */
    "mockCallRevert(address,bytes,bytes)"(
      callee: string,
      data: BytesLike,
      revertData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into an `address`.
     */
    parseAddress(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `bool`.
     */
    parseBool(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into `bytes`.
     */
    parseBytes(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `bytes32`.
     */
    parseBytes32(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `int256`.
     */
    parseInt(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a JSON object.
     */
    "parseJson(string)"(
      json: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a JSON object at `key`.
     */
    "parseJson(string,string)"(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address`.
     */
    parseJsonAddress(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `address[]`.
     */
    parseJsonAddressArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool`.
     */
    parseJsonBool(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bool[]`.
     */
    parseJsonBoolArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes`.
     */
    parseJsonBytes(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32`.
     */
    parseJsonBytes32(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
     */
    parseJsonBytes32Array(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `bytes[]`.
     */
    parseJsonBytesArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256`.
     */
    parseJsonInt(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `int256[]`.
     */
    parseJsonIntArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an array of all the keys in a JSON object.
     */
    parseJsonKeys(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string`.
     */
    parseJsonString(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `string[]`.
     */
    parseJsonStringArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256`.
     */
    parseJsonUint(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of JSON data at `key` and coerces it to `uint256[]`.
     */
    parseJsonUintArray(
      json: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a TOML table at `key`.
     */
    "parseToml(string,string)"(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * ABI-encodes a TOML table.
     */
    "parseToml(string)"(
      toml: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address`.
     */
    parseTomlAddress(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `address[]`.
     */
    parseTomlAddressArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool`.
     */
    parseTomlBool(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bool[]`.
     */
    parseTomlBoolArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes`.
     */
    parseTomlBytes(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32`.
     */
    parseTomlBytes32(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
     */
    parseTomlBytes32Array(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `bytes[]`.
     */
    parseTomlBytesArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256`.
     */
    parseTomlInt(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `int256[]`.
     */
    parseTomlIntArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an array of all the keys in a TOML table.
     */
    parseTomlKeys(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string`.
     */
    parseTomlString(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `string[]`.
     */
    parseTomlStringArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256`.
     */
    parseTomlUint(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses a string of TOML data at `key` and coerces it to `uint256[]`.
     */
    parseTomlUintArray(
      toml: string,
      key: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the given `string` into a `uint256`.
     */
    parseUint(
      stringifiedValue: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
     */
    pauseGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
     */
    "prank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the *next* call's `msg.sender` to be the input address.
     */
    "prank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(bytes32)"(
      newPrevrandao: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.prevrandao`. Not available on EVM versions before Paris. Use `difficulty` instead. If used on unsupported EVM versions it will revert.
     */
    "prevrandao(uint256)"(
      newPrevrandao: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the path of the current project root.
     */
    projectRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for a string value in the terminal.
     */
    prompt(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for an address in the terminal.
     */
    promptAddress(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for a hidden string value in the terminal.
     */
    promptSecret(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Prompts the user for uint256 in the terminal.
     */
    promptUint(
      promptText: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
     */
    readCallers(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64)"(
      path: string,
      maxDepth: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See `readDir(string)`.
     */
    "readDir(string,uint64,bool)"(
      path: string,
      maxDepth: BigNumberish,
      followLinks: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the directory at the given path recursively, up to `maxDepth`. `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned. Follows symbolic links if `followLinks` is true.
     */
    "readDir(string)"(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the entire content of file to string. `path` is relative to the project root.
     */
    readFile(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads the entire content of file as binary. `path` is relative to the project root.
     */
    readFileBinary(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads next line of file to string.
     */
    readLine(
      path: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reads a symbolic link, returning the path that the link points to. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` is not a symbolic link. - `path` does not exist.
     */
    readLink(
      linkPath: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Records all storage reads and writes.
     */
    record(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Record all the transaction logs.
     */
    recordLogs(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Adds a private key to the local forge wallet and returns the address.
     */
    rememberKey(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes a directory at the provided path. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` doesn't exist. - `path` isn't a directory. - User lacks permissions to modify `path`. - The directory is not empty and `recursive` is false. `path` is relative to the project root.
     */
    removeDir(
      path: string,
      recursive: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Removes a file from the filesystem. This cheatcode will revert in the following situations, but is not limited to just these cases: - `path` points to a directory. - The file doesn't exist. - The user lacks permissions to remove the file. `path` is relative to the project root.
     */
    removeFile(
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Replaces occurrences of `from` in the given `string` with `to`.
     */
    replace(
      input: string,
      from: string,
      to: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
     */
    resetNonce(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
     */
    resumeGasMetering(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Revert the state of the EVM to a previous snapshot Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted. Returns `false` if the snapshot does not exist. **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
     */
    revertTo(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots Takes the snapshot ID to revert to. Returns `true` if the snapshot was successfully reverted and deleted. Returns `false` if the snapshot does not exist.
     */
    revertToAndDelete(
      snapshotId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `revokePersistent(address)`.
     */
    "revokePersistent(address[])"(
      accounts: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes persistent status from the address, previously added via `makePersistent`.
     */
    "revokePersistent(address)"(
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.height`.
     */
    roll(
      newHeight: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the currently active fork to given transaction. This will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block.
     */
    "rollFork(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the given fork to given block number.
     */
    "rollFork(uint256,uint256)"(
      forkId: BigNumberish,
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the currently active fork to given block number This is similar to `roll` but for the currently active fork.
     */
    "rollFork(uint256)"(
      blockNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
     */
    "rollFork(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Performs an Ethereum JSON-RPC request to the current fork URL.
     */
    rpc(
      method: string,
      params: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the RPC url for the given alias.
     */
    rpcUrl(
      rpcAlias: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns all rpc urls and their aliases as structs.
     */
    rpcUrlStructs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns all rpc urls and their aliases `[alias, url][]`.
     */
    rpcUrls(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
     */
    selectFork(
      forkId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeAddress(string,string,address)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool[])"(
      objectKey: string,
      valueKey: string,
      values: boolean[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBool(string,string,bool)"(
      objectKey: string,
      valueKey: string,
      value: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes(string,string,bytes)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32[])"(
      objectKey: string,
      valueKey: string,
      values: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeBytes32(string,string,bytes32)"(
      objectKey: string,
      valueKey: string,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeInt(string,string,int256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Serializes a key and value to a JSON object stored in-memory that can be later written to a file. Returns the stringified version of the specific JSON file up to that moment.
     */
    serializeJson(
      objectKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string[])"(
      objectKey: string,
      valueKey: string,
      values: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeString(string,string,string)"(
      objectKey: string,
      valueKey: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256)"(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    "serializeUint(string,string,uint256[])"(
      objectKey: string,
      valueKey: string,
      values: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * See `serializeJson`.
     */
    serializeUintToHex(
      objectKey: string,
      valueKey: string,
      value: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets environment variables.
     */
    setEnv(
      name: string,
      value: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the nonce of an account. Must be higher than the current nonce of the account.
     */
    setNonce(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the nonce of an account to an arbitrary value.
     */
    setNonceUnsafe(
      account: string,
      newNonce: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. If `--sender` is provided, the signer with provided address is used, otherwise, if exactly one signer is provided to the script, that signer is used. Raises error if signer passed through `--sender` does not match any unlocked signers or if `--sender` is not provided and not exactly one signer is passed to the script.
     */
    "sign(bytes32)"(
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with signer provided to script using the secp256k1 curve. Raises error if none of the signers passed into the script have provided address.
     */
    "sign(address,bytes32)"(
      signer: string,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "sign((address,uint256,uint256,uint256),bytes32)"(
      wallet: VmSafe.WalletStruct,
      digest: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256k1 curve.
     */
    "sign(uint256,bytes32)"(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Signs `digest` with `privateKey` using the secp256r1 curve.
     */
    signP256(
      privateKey: BigNumberish,
      digest: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Marks a test as skipped. Must be called at the top of the test.
     */
    skip(
      skipTest: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Suspends execution of the main thread for `duration` milliseconds.
     */
    sleep(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Snapshot the current state of the evm. Returns the ID of the snapshot that was created. To revert a snapshot use `revertTo`.
     */
    snapshot(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Splits the given `string` into an array of strings divided by the `delimiter`.
     */
    split(
      input: string,
      delimiter: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain. Broadcasting address is determined by checking the following in order: 1. If `--sender` argument was provided, that address is used. 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used. 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
     */
    "startBroadcast()"(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain.
     */
    "startBroadcast(address)"(
      signer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain.
     */
    "startBroadcast(uint256)"(
      privateKey: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Starts recording all map SSTOREs for later retrieval.
     */
    startMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
     */
    "startPrank(address)"(
      msgSender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
     */
    "startPrank(address,address)"(
      msgSender: string,
      txOrigin: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order, along with the context of the calls
     */
    startStateDiffRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
     */
    stopAndReturnStateDiff(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stops collecting onchain transactions.
     */
    stopBroadcast(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stops all safe memory expectation in the current subcontext.
     */
    stopExpectSafeMemory(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stops recording all map SSTOREs for later retrieval and clears the recorded data.
     */
    stopMappingRecording(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Resets subsequent calls' `msg.sender` to be `address(this)`.
     */
    stopPrank(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stores a value to an address' storage slot.
     */
    store(
      target: string,
      slot: BytesLike,
      value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `string` value to a base64 string.
     */
    "toBase64(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `bytes` value to a base64 string.
     */
    "toBase64(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `string` value to a base64url string.
     */
    "toBase64URL(string)"(
      data: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encodes a `bytes` value to a base64url string.
     */
    "toBase64URL(bytes)"(
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given `string` value to Lowercase.
     */
    toLowercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(address)"(
      value: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(uint256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bool)"(
      value: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(int256)"(
      value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given value to a `string`.
     */
    "toString(bytes32)"(
      value: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Converts the given `string` value to Uppercase.
     */
    toUppercase(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Fetches the given transaction from the given fork and executes it on the current state.
     */
    "transact(uint256,bytes32)"(
      forkId: BigNumberish,
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Fetches the given transaction from the active fork and executes it on the current state.
     */
    "transact(bytes32)"(
      txHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Trims leading and trailing whitespace from the given `string` value.
     */
    trim(
      input: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
     */
    tryFfi(
      commandInput: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `tx.gasprice`.
     */
    txGasPrice(
      newGasPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the time since unix epoch in milliseconds.
     */
    unixTime(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets `block.timestamp`.
     */
    warp(
      newTimestamp: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFile(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does. `path` is relative to the project root.
     */
    writeFileBinary(
      path: string,
      data: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.> This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
     */
    "writeJson(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Write a serialized JSON object to a file. If the file exists, it will be overwritten.
     */
    "writeJson(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Writes line to file, creating a file if it does not exist. `path` is relative to the project root.
     */
    writeLine(
      path: string,
      data: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.> This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
     */
    "writeToml(string,string,string)"(
      json: string,
      path: string,
      valueKey: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
     */
    "writeToml(string,string)"(
      json: string,
      path: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
