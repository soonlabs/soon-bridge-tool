/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface L1StandardBridgeInterface extends utils.Interface {
  functions: {
    "ERC20SharedDecimals()": FunctionFragment;
    "MESSENGER()": FunctionFragment;
    "OTHER_BRIDGE()": FunctionFragment;
    "bridgeERC20(address,address,uint256,uint32,bytes)": FunctionFragment;
    "bridgeERC20To(address,bytes32,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "bridgeETH(uint32,bytes)": FunctionFragment;
    "bridgeETHTo(bytes32,uint32,bytes)": FunctionFragment;
    "depositERC20(address,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "depositERC20To(address,bytes32,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "depositETH(uint32,bytes)": FunctionFragment;
    "depositETHTo(bytes32,uint32,bytes)": FunctionFragment;
    "deposits(address,bytes32)": FunctionFragment;
    "encodeBridgeERC20L2Message(address,bytes32,address,bytes32,uint256,bytes)": FunctionFragment;
    "encodeBridgeETHL2Message(address,bytes32,uint256,bytes)": FunctionFragment;
    "finalizeBridgeERC20(address,bytes32,bytes32,address,uint256,bytes)": FunctionFragment;
    "finalizeBridgeETH(bytes32,address,uint256,bytes)": FunctionFragment;
    "finalizeERC20Withdrawal(address,bytes32,bytes32,address,uint256,bytes)": FunctionFragment;
    "finalizeETHWithdrawal(bytes32,address,uint256,bytes)": FunctionFragment;
    "initialize(address,address,address)": FunctionFragment;
    "l2TokenBridge()": FunctionFragment;
    "messenger()": FunctionFragment;
    "otherBridge()": FunctionFragment;
    "paused()": FunctionFragment;
    "superchainConfig()": FunctionFragment;
    "systemConfig()": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ERC20SharedDecimals"
      | "MESSENGER"
      | "OTHER_BRIDGE"
      | "bridgeERC20"
      | "bridgeERC20To"
      | "bridgeETH"
      | "bridgeETHTo"
      | "depositERC20"
      | "depositERC20To"
      | "depositETH"
      | "depositETHTo"
      | "deposits"
      | "encodeBridgeERC20L2Message"
      | "encodeBridgeETHL2Message"
      | "finalizeBridgeERC20"
      | "finalizeBridgeETH"
      | "finalizeERC20Withdrawal"
      | "finalizeETHWithdrawal"
      | "initialize"
      | "l2TokenBridge"
      | "messenger"
      | "otherBridge"
      | "paused"
      | "superchainConfig"
      | "systemConfig"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "ERC20SharedDecimals",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "MESSENGER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "OTHER_BRIDGE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC20",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC20To",
    values: [
      string,
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeETH",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeETHTo",
    values: [BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20",
    values: [string, BytesLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20To",
    values: [
      string,
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETH",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETHTo",
    values: [BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "deposits",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeBridgeERC20L2Message",
    values: [string, BytesLike, string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeBridgeETHL2Message",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeBridgeERC20",
    values: [string, BytesLike, BytesLike, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeBridgeETH",
    values: [BytesLike, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeERC20Withdrawal",
    values: [string, BytesLike, BytesLike, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeETHWithdrawal",
    values: [BytesLike, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "l2TokenBridge",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "messenger", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "otherBridge",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "superchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "systemConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "ERC20SharedDecimals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MESSENGER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "OTHER_BRIDGE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC20To",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bridgeETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "bridgeETHTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20To",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositETHTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposits", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "encodeBridgeERC20L2Message",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "encodeBridgeETHL2Message",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeBridgeERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeBridgeETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeERC20Withdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeETHWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "l2TokenBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "messenger", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "otherBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "superchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "systemConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "ERC20BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ERC20BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "ERC20DepositInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "ERC20WithdrawalFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ETHBridgeFinalized(bytes32,address,uint256,bytes)": EventFragment;
    "ETHBridgeInitiated(address,bytes32,uint256,bytes)": EventFragment;
    "ETHDepositInitiated(address,bytes32,uint256,bytes)": EventFragment;
    "ETHWithdrawalFinalized(bytes32,address,uint256,bytes)": EventFragment;
    "Initialized(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ERC20BridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20BridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20DepositInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC20WithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHBridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHBridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHDepositInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ETHWithdrawalFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}

export interface ERC20BridgeFinalizedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ERC20BridgeFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20BridgeFinalizedEventObject
>;

export type ERC20BridgeFinalizedEventFilter =
  TypedEventFilter<ERC20BridgeFinalizedEvent>;

export interface ERC20BridgeInitiatedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ERC20BridgeInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20BridgeInitiatedEventObject
>;

export type ERC20BridgeInitiatedEventFilter =
  TypedEventFilter<ERC20BridgeInitiatedEvent>;

export interface ERC20DepositInitiatedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ERC20DepositInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20DepositInitiatedEventObject
>;

export type ERC20DepositInitiatedEventFilter =
  TypedEventFilter<ERC20DepositInitiatedEvent>;

export interface ERC20WithdrawalFinalizedEventObject {
  l1Token: string;
  l2Token: string;
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ERC20WithdrawalFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC20WithdrawalFinalizedEventObject
>;

export type ERC20WithdrawalFinalizedEventFilter =
  TypedEventFilter<ERC20WithdrawalFinalizedEvent>;

export interface ETHBridgeFinalizedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ETHBridgeFinalizedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHBridgeFinalizedEventObject
>;

export type ETHBridgeFinalizedEventFilter =
  TypedEventFilter<ETHBridgeFinalizedEvent>;

export interface ETHBridgeInitiatedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ETHBridgeInitiatedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHBridgeInitiatedEventObject
>;

export type ETHBridgeInitiatedEventFilter =
  TypedEventFilter<ETHBridgeInitiatedEvent>;

export interface ETHDepositInitiatedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ETHDepositInitiatedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHDepositInitiatedEventObject
>;

export type ETHDepositInitiatedEventFilter =
  TypedEventFilter<ETHDepositInitiatedEvent>;

export interface ETHWithdrawalFinalizedEventObject {
  from: string;
  to: string;
  amount: BigNumber;
  extraData: string;
}
export type ETHWithdrawalFinalizedEvent = TypedEvent<
  [string, string, BigNumber, string],
  ETHWithdrawalFinalizedEventObject
>;

export type ETHWithdrawalFinalizedEventFilter =
  TypedEventFilter<ETHWithdrawalFinalizedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface L1StandardBridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L1StandardBridgeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Getter for the shared decimals when bridge ERC20
     */
    ERC20SharedDecimals(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Getter for the other bridge contract.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Sends ERC20 tokens to the sender's address on the other chain.
     */
    bridgeERC20(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sends ERC20 tokens to a receiver's address on the other chain.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    bridgeERC20To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sends ETH to the sender's address on the other chain.
     */
    bridgeETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a         smart contract and the call fails, the ETH will be temporarily locked in the         StandardBridge on the other chain until the call is replayed. If the call cannot be         replayed with any amount of gas (call always reverts), then the ETH will be         permanently locked in the StandardBridge on the other chain. ETH will also         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert         in that case.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _to Address of the receiver.
     */
    bridgeETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    depositERC20(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _amount Amount of the ERC20 to deposit.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _l1Token Address of the L1 token being deposited.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositERC20To(
      _l1Token: string,
      _l2Token: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    depositETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Mapping that stores deposits for a given pair of local and remote tokens.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Encode L2 message for bridge ERC20 from L1 to L2.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    encodeBridgeERC20L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Encode L2 message for bridge ETH from L1 to L2.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    encodeBridgeETHL2Message(
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Finalizes an ERC20 bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of the ERC20 being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    finalizeBridgeERC20(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Finalizes an ETH bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                   not be triggered with this data, but it will be emitted and can be used                   to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    finalizeBridgeETH(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _amount Amount of the ERC20 to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _l1Token Address of the token on L1.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeERC20Withdrawal(
      _l1Token: string,
      _l2Token: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param _amount Amount of ETH to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeETHWithdrawal(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initializer.
     * @param _messenger Contract for the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract for the SuperchainConfig on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    l2TokenBridge(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Corresponding bridge on the other domain.
     */
    otherBridge(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Getter for the shared decimals when bridge ERC20
   */
  ERC20SharedDecimals(overrides?: CallOverrides): Promise<number>;

  /**
   * Getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
   */
  MESSENGER(overrides?: CallOverrides): Promise<string>;

  /**
   * Getter for the other bridge contract.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
   */
  OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

  /**
   * Sends ERC20 tokens to the sender's address on the other chain.
   */
  bridgeERC20(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sends ERC20 tokens to a receiver's address on the other chain.
   * @param _amount Amount of local tokens to deposit.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
   * @param _localToken Address of the ERC20 on this chain.
   * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
   * @param _remoteToken Address of the corresponding token on the remote chain.
   * @param _to Address of the receiver.
   */
  bridgeERC20To(
    _localToken: string,
    _remoteToken: BytesLike,
    _to: BytesLike,
    _amount: BigNumberish,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sends ETH to the sender's address on the other chain.
   */
  bridgeETH(
    arg0: BigNumberish,
    arg1: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a         smart contract and the call fails, the ETH will be temporarily locked in the         StandardBridge on the other chain until the call is replayed. If the call cannot be         replayed with any amount of gas (call always reverts), then the ETH will be         permanently locked in the StandardBridge on the other chain. ETH will also         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert         in that case.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
   * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
   * @param _to Address of the receiver.
   */
  bridgeETHTo(
    _to: BytesLike,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  depositERC20(
    arg0: string,
    arg1: BytesLike,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _amount Amount of the ERC20 to deposit.
   * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
   * @param _l1Token Address of the L1 token being deposited.
   * @param _l2Token Address of the corresponding token on L2.
   * @param _minGasLimit Minimum gas limit for the deposit message on L2.
   * @param _to Address of the recipient on L2.
   */
  depositERC20To(
    _l1Token: string,
    _l2Token: BytesLike,
    _to: BytesLike,
    _amount: BigNumberish,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  depositETH(
    arg0: BigNumberish,
    arg1: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
   * @param _minGasLimit Minimum gas limit for the deposit message on L2.
   * @param _to Address of the recipient on L2.
   */
  depositETHTo(
    _to: BytesLike,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Mapping that stores deposits for a given pair of local and remote tokens.
   */
  deposits(
    arg0: string,
    arg1: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Encode L2 message for bridge ERC20 from L1 to L2.
   * @param _amount Amount of local tokens to deposit.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
   * @param _localToken Address of the ERC20 on this chain.
   * @param _remoteToken Address of the corresponding token on the remote chain.
   * @param _to Address of the receiver.
   */
  encodeBridgeERC20L2Message(
    _localToken: string,
    _remoteToken: BytesLike,
    _from: string,
    _to: BytesLike,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Encode L2 message for bridge ETH from L1 to L2.
   * @param _amount Amount of ETH being bridged.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
   * @param _from Address of the sender.
   * @param _to Address of the receiver.
   */
  encodeBridgeETHL2Message(
    _from: string,
    _to: BytesLike,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Finalizes an ERC20 bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
   * @param _amount Amount of the ERC20 being bridged.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
   * @param _from Address of the sender.
   * @param _localToken Address of the ERC20 on this chain.
   * @param _remoteToken Address of the corresponding token on the remote chain.
   * @param _to Address of the receiver.
   */
  finalizeBridgeERC20(
    _localToken: string,
    _remoteToken: BytesLike,
    _from: BytesLike,
    _to: string,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Finalizes an ETH bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
   * @param _amount Amount of ETH being bridged.
   * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                   not be triggered with this data, but it will be emitted and can be used                   to identify the transaction.
   * @param _from Address of the sender.
   * @param _to Address of the receiver.
   */
  finalizeBridgeETH(
    _from: BytesLike,
    _to: string,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _amount Amount of the ERC20 to withdraw.
   * @param _extraData Optional data forwarded from L2.
   * @param _from Address of the withdrawer on L2.
   * @param _l1Token Address of the token on L1.
   * @param _l2Token Address of the corresponding token on L2.
   * @param _to Address of the recipient on L1.
   */
  finalizeERC20Withdrawal(
    _l1Token: string,
    _l2Token: BytesLike,
    _from: BytesLike,
    _to: string,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param _amount Amount of ETH to withdraw.
   * @param _extraData Optional data forwarded from L2.
   * @param _from Address of the withdrawer on L2.
   * @param _to Address of the recipient on L1.
   */
  finalizeETHWithdrawal(
    _from: BytesLike,
    _to: string,
    _amount: BigNumberish,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initializer.
   * @param _messenger Contract for the CrossDomainMessenger on this network.
   * @param _superchainConfig Contract for the SuperchainConfig on this network.
   */
  initialize(
    _messenger: string,
    _superchainConfig: string,
    _systemConfig: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  l2TokenBridge(overrides?: CallOverrides): Promise<string>;

  /**
   * Messenger contract on this domain.
   */
  messenger(overrides?: CallOverrides): Promise<string>;

  /**
   * Corresponding bridge on the other domain.
   */
  otherBridge(overrides?: CallOverrides): Promise<string>;

  /**
   * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Address of the SuperchainConfig contract.
   */
  superchainConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Address of the SystemConfig contract.
   */
  systemConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Getter for the shared decimals when bridge ERC20
     */
    ERC20SharedDecimals(overrides?: CallOverrides): Promise<number>;

    /**
     * Getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<string>;

    /**
     * Getter for the other bridge contract.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

    /**
     * Sends ERC20 tokens to the sender's address on the other chain.
     */
    bridgeERC20(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sends ERC20 tokens to a receiver's address on the other chain.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    bridgeERC20To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sends ETH to the sender's address on the other chain.
     */
    bridgeETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a         smart contract and the call fails, the ETH will be temporarily locked in the         StandardBridge on the other chain until the call is replayed. If the call cannot be         replayed with any amount of gas (call always reverts), then the ETH will be         permanently locked in the StandardBridge on the other chain. ETH will also         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert         in that case.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _to Address of the receiver.
     */
    bridgeETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     */
    depositERC20(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _amount Amount of the ERC20 to deposit.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _l1Token Address of the L1 token being deposited.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositERC20To(
      _l1Token: string,
      _l2Token: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     */
    depositETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mapping that stores deposits for a given pair of local and remote tokens.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message for bridge ERC20 from L1 to L2.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    encodeBridgeERC20L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Encode L2 message for bridge ETH from L1 to L2.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    encodeBridgeETHL2Message(
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Finalizes an ERC20 bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of the ERC20 being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    finalizeBridgeERC20(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Finalizes an ETH bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                   not be triggered with this data, but it will be emitted and can be used                   to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    finalizeBridgeETH(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _amount Amount of the ERC20 to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _l1Token Address of the token on L1.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeERC20Withdrawal(
      _l1Token: string,
      _l2Token: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param _amount Amount of ETH to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeETHWithdrawal(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Initializer.
     * @param _messenger Contract for the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract for the SuperchainConfig on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      _systemConfig: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     */
    l2TokenBridge(overrides?: CallOverrides): Promise<string>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<string>;

    /**
     * Corresponding bridge on the other domain.
     */
    otherBridge(overrides?: CallOverrides): Promise<string>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "ERC20BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20BridgeFinalizedEventFilter;
    ERC20BridgeFinalized(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20BridgeFinalizedEventFilter;

    "ERC20BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20BridgeInitiatedEventFilter;
    ERC20BridgeInitiated(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20BridgeInitiatedEventFilter;

    "ERC20DepositInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20DepositInitiatedEventFilter;
    ERC20DepositInitiated(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: string | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20DepositInitiatedEventFilter;

    "ERC20WithdrawalFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20WithdrawalFinalizedEventFilter;
    ERC20WithdrawalFinalized(
      l1Token?: string | null,
      l2Token?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      amount?: null,
      extraData?: null
    ): ERC20WithdrawalFinalizedEventFilter;

    "ETHBridgeFinalized(bytes32,address,uint256,bytes)"(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      extraData?: null
    ): ETHBridgeFinalizedEventFilter;
    ETHBridgeFinalized(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      extraData?: null
    ): ETHBridgeFinalizedEventFilter;

    "ETHBridgeInitiated(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      extraData?: null
    ): ETHBridgeInitiatedEventFilter;
    ETHBridgeInitiated(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      extraData?: null
    ): ETHBridgeInitiatedEventFilter;

    "ETHDepositInitiated(address,bytes32,uint256,bytes)"(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      extraData?: null
    ): ETHDepositInitiatedEventFilter;
    ETHDepositInitiated(
      from?: string | null,
      to?: BytesLike | null,
      amount?: null,
      extraData?: null
    ): ETHDepositInitiatedEventFilter;

    "ETHWithdrawalFinalized(bytes32,address,uint256,bytes)"(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      extraData?: null
    ): ETHWithdrawalFinalizedEventFilter;
    ETHWithdrawalFinalized(
      from?: BytesLike | null,
      to?: string | null,
      amount?: null,
      extraData?: null
    ): ETHWithdrawalFinalizedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;
  };

  estimateGas: {
    /**
     * Getter for the shared decimals when bridge ERC20
     */
    ERC20SharedDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the other bridge contract.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sends ERC20 tokens to the sender's address on the other chain.
     */
    bridgeERC20(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sends ERC20 tokens to a receiver's address on the other chain.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    bridgeERC20To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sends ETH to the sender's address on the other chain.
     */
    bridgeETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a         smart contract and the call fails, the ETH will be temporarily locked in the         StandardBridge on the other chain until the call is replayed. If the call cannot be         replayed with any amount of gas (call always reverts), then the ETH will be         permanently locked in the StandardBridge on the other chain. ETH will also         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert         in that case.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _to Address of the receiver.
     */
    bridgeETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    depositERC20(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _amount Amount of the ERC20 to deposit.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _l1Token Address of the L1 token being deposited.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositERC20To(
      _l1Token: string,
      _l2Token: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    depositETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Mapping that stores deposits for a given pair of local and remote tokens.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message for bridge ERC20 from L1 to L2.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    encodeBridgeERC20L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message for bridge ETH from L1 to L2.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    encodeBridgeETHL2Message(
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Finalizes an ERC20 bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of the ERC20 being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    finalizeBridgeERC20(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Finalizes an ETH bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                   not be triggered with this data, but it will be emitted and can be used                   to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    finalizeBridgeETH(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _amount Amount of the ERC20 to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _l1Token Address of the token on L1.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeERC20Withdrawal(
      _l1Token: string,
      _l2Token: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param _amount Amount of ETH to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeETHWithdrawal(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initializer.
     * @param _messenger Contract for the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract for the SuperchainConfig on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    l2TokenBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Corresponding bridge on the other domain.
     */
    otherBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Getter for the shared decimals when bridge ERC20
     */
    ERC20SharedDecimals(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Getter for the other bridge contract.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Sends ERC20 tokens to the sender's address on the other chain.
     */
    bridgeERC20(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sends ERC20 tokens to a receiver's address on the other chain.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    bridgeERC20To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sends ETH to the sender's address on the other chain.
     */
    bridgeETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a         smart contract and the call fails, the ETH will be temporarily locked in the         StandardBridge on the other chain until the call is replayed. If the call cannot be         replayed with any amount of gas (call always reverts), then the ETH will be         permanently locked in the StandardBridge on the other chain. ETH will also         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert         in that case.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.
     * @param _to Address of the receiver.
     */
    bridgeETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    depositERC20(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _amount Amount of the ERC20 to deposit.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _l1Token Address of the L1 token being deposited.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositERC20To(
      _l1Token: string,
      _l2Token: BytesLike,
      _to: BytesLike,
      _amount: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    depositETH(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _minGasLimit Minimum gas limit for the deposit message on L2.
     * @param _to Address of the recipient on L2.
     */
    depositETHTo(
      _to: BytesLike,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping that stores deposits for a given pair of local and remote tokens.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encode L2 message for bridge ERC20 from L1 to L2.
     * @param _amount Amount of local tokens to deposit.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    encodeBridgeERC20L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encode L2 message for bridge ETH from L1 to L2.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    encodeBridgeETHL2Message(
      _from: string,
      _to: BytesLike,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Finalizes an ERC20 bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of the ERC20 being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                     not be triggered with this data, but it will be emitted and can be used                     to identify the transaction.
     * @param _from Address of the sender.
     * @param _localToken Address of the ERC20 on this chain.
     * @param _remoteToken Address of the corresponding token on the remote chain.
     * @param _to Address of the receiver.
     */
    finalizeBridgeERC20(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Finalizes an ETH bridge on this chain. Can only be triggered by the other         StandardBridge contract on the remote chain.
     * @param _amount Amount of ETH being bridged.
     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will                   not be triggered with this data, but it will be emitted and can be used                   to identify the transaction.
     * @param _from Address of the sender.
     * @param _to Address of the receiver.
     */
    finalizeBridgeETH(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _amount Amount of the ERC20 to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _l1Token Address of the token on L1.
     * @param _l2Token Address of the corresponding token on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeERC20Withdrawal(
      _l1Token: string,
      _l2Token: BytesLike,
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param _amount Amount of ETH to withdraw.
     * @param _extraData Optional data forwarded from L2.
     * @param _from Address of the withdrawer on L2.
     * @param _to Address of the recipient on L1.
     */
    finalizeETHWithdrawal(
      _from: BytesLike,
      _to: string,
      _amount: BigNumberish,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initializer.
     * @param _messenger Contract for the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract for the SuperchainConfig on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      _systemConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    l2TokenBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Corresponding bridge on the other domain.
     */
    otherBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the SystemConfig contract.
     */
    systemConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
