/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace Drippie {
  export type DripActionStruct = {
    target: string;
    data: BytesLike;
    value: BigNumberish;
  };

  export type DripActionStructOutput = [string, string, BigNumber] & {
    target: string;
    data: string;
    value: BigNumber;
  };

  export type DripConfigStruct = {
    reentrant: boolean;
    interval: BigNumberish;
    dripcheck: string;
    checkparams: BytesLike;
    actions: Drippie.DripActionStruct[];
  };

  export type DripConfigStructOutput = [
    boolean,
    BigNumber,
    string,
    string,
    Drippie.DripActionStructOutput[]
  ] & {
    reentrant: boolean;
    interval: BigNumber;
    dripcheck: string;
    checkparams: string;
    actions: Drippie.DripActionStructOutput[];
  };
}

export interface TestDrippieInterface extends utils.Interface {
  functions: {
    "CALL(address,bytes,uint256)": FunctionFragment;
    "DELEGATECALL(address,bytes)": FunctionFragment;
    "create(string,(bool,uint256,address,bytes,(address,bytes,uint256)[]))": FunctionFragment;
    "created(uint256)": FunctionFragment;
    "drip(string)": FunctionFragment;
    "dripConfig(string)": FunctionFragment;
    "dripConfigActions(string)": FunctionFragment;
    "dripConfigCheckAddress(string)": FunctionFragment;
    "dripConfigCheckParams(string)": FunctionFragment;
    "dripStateLast(string)": FunctionFragment;
    "dripStatus(string)": FunctionFragment;
    "drips(string)": FunctionFragment;
    "executable(string)": FunctionFragment;
    "getDripCount()": FunctionFragment;
    "getDripInterval(string)": FunctionFragment;
    "getDripStatus(string)": FunctionFragment;
    "owner()": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "status(string,uint8)": FunctionFragment;
    "withdrawERC20(address,address,uint256)": FunctionFragment;
    "withdrawERC20(address,address)": FunctionFragment;
    "withdrawERC721(address,address,uint256)": FunctionFragment;
    "withdrawETH(address,uint256)": FunctionFragment;
    "withdrawETH(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "CALL"
      | "DELEGATECALL"
      | "create"
      | "created"
      | "drip"
      | "dripConfig"
      | "dripConfigActions"
      | "dripConfigCheckAddress"
      | "dripConfigCheckParams"
      | "dripStateLast"
      | "dripStatus"
      | "drips"
      | "executable"
      | "getDripCount"
      | "getDripInterval"
      | "getDripStatus"
      | "owner"
      | "setOwner"
      | "status"
      | "withdrawERC20(address,address,uint256)"
      | "withdrawERC20(address,address)"
      | "withdrawERC721"
      | "withdrawETH(address,uint256)"
      | "withdrawETH(address)"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CALL",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "DELEGATECALL",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [string, Drippie.DripConfigStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "created",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "drip", values: [string]): string;
  encodeFunctionData(functionFragment: "dripConfig", values: [string]): string;
  encodeFunctionData(
    functionFragment: "dripConfigActions",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "dripConfigCheckAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "dripConfigCheckParams",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "dripStateLast",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "dripStatus", values: [string]): string;
  encodeFunctionData(functionFragment: "drips", values: [string]): string;
  encodeFunctionData(functionFragment: "executable", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getDripCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDripInterval",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getDripStatus",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
  encodeFunctionData(
    functionFragment: "status",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20(address,address,uint256)",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20(address,address)",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC721",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETH(address,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETH(address)",
    values: [string]
  ): string;

  decodeFunctionResult(functionFragment: "CALL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "DELEGATECALL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "created", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "drip", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dripConfig", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "dripConfigActions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dripConfigCheckAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dripConfigCheckParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dripStateLast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "dripStatus", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "drips", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "executable", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDripCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDripInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDripStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETH(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETH(address)",
    data: BytesLike
  ): Result;

  events: {
    "DripCreated(string,string,(bool,uint256,address,bytes,(address,bytes,uint256)[]))": EventFragment;
    "DripExecuted(string,string,address,uint256)": EventFragment;
    "DripStatusUpdated(string,string,uint8)": EventFragment;
    "OwnerUpdated(address,address)": EventFragment;
    "ReceivedETH(address,uint256)": EventFragment;
    "WithdrewERC20(address,address,address,uint256)": EventFragment;
    "WithdrewERC721(address,address,address,uint256)": EventFragment;
    "WithdrewETH(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DripCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DripExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DripStatusUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReceivedETH"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrewERC20"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrewERC721"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrewETH"): EventFragment;
}

export interface DripCreatedEventObject {
  nameref: string;
  name: string;
  config: Drippie.DripConfigStructOutput;
}
export type DripCreatedEvent = TypedEvent<
  [string, string, Drippie.DripConfigStructOutput],
  DripCreatedEventObject
>;

export type DripCreatedEventFilter = TypedEventFilter<DripCreatedEvent>;

export interface DripExecutedEventObject {
  nameref: string;
  name: string;
  executor: string;
  timestamp: BigNumber;
}
export type DripExecutedEvent = TypedEvent<
  [string, string, string, BigNumber],
  DripExecutedEventObject
>;

export type DripExecutedEventFilter = TypedEventFilter<DripExecutedEvent>;

export interface DripStatusUpdatedEventObject {
  nameref: string;
  name: string;
  status: number;
}
export type DripStatusUpdatedEvent = TypedEvent<
  [string, string, number],
  DripStatusUpdatedEventObject
>;

export type DripStatusUpdatedEventFilter =
  TypedEventFilter<DripStatusUpdatedEvent>;

export interface OwnerUpdatedEventObject {
  user: string;
  newOwner: string;
}
export type OwnerUpdatedEvent = TypedEvent<
  [string, string],
  OwnerUpdatedEventObject
>;

export type OwnerUpdatedEventFilter = TypedEventFilter<OwnerUpdatedEvent>;

export interface ReceivedETHEventObject {
  from: string;
  amount: BigNumber;
}
export type ReceivedETHEvent = TypedEvent<
  [string, BigNumber],
  ReceivedETHEventObject
>;

export type ReceivedETHEventFilter = TypedEventFilter<ReceivedETHEvent>;

export interface WithdrewERC20EventObject {
  withdrawer: string;
  recipient: string;
  asset: string;
  amount: BigNumber;
}
export type WithdrewERC20Event = TypedEvent<
  [string, string, string, BigNumber],
  WithdrewERC20EventObject
>;

export type WithdrewERC20EventFilter = TypedEventFilter<WithdrewERC20Event>;

export interface WithdrewERC721EventObject {
  withdrawer: string;
  recipient: string;
  asset: string;
  id: BigNumber;
}
export type WithdrewERC721Event = TypedEvent<
  [string, string, string, BigNumber],
  WithdrewERC721EventObject
>;

export type WithdrewERC721EventFilter = TypedEventFilter<WithdrewERC721Event>;

export interface WithdrewETHEventObject {
  withdrawer: string;
  recipient: string;
  amount: BigNumber;
}
export type WithdrewETHEvent = TypedEvent<
  [string, string, BigNumber],
  WithdrewETHEventObject
>;

export type WithdrewETHEventFilter = TypedEventFilter<WithdrewETHEvent>;

export interface TestDrippie extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TestDrippieInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Sends a CALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     * @param _value ETH value to send with the call.
     */
    CALL(
      _target: string,
      _data: BytesLike,
      _value: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sends a DELEGATECALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     */
    DELEGATECALL(
      _target: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    create(
      _name: string,
      _config: Drippie.DripConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Array of created drips. Used so offchain services can easily iterate over all drips         without resorting to event queries. Convenience feature and shouldn't really be         used onchain because the array will grow indefinitely.
     */
    created(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Triggers a drip. This function is deliberately left as a public function because the         assumption being made here is that setting the drip to ACTIVE is an affirmative         signal that the drip should be executable according to the drip parameters, drip         check, and drip interval. Note that drip parameters are read entirely from the state         and are not supplied as user input, so there should not be any way for a         non-authorized user to influence the behavior of the drip. Note that the drip check         is executed only **once** at the beginning of the call to the drip function and will         not be executed again between the drip actions within this call.
     * @param _name Name of the drip to trigger.
     */
    drip(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    dripConfig(
      name: string,
      overrides?: CallOverrides
    ): Promise<[Drippie.DripConfigStructOutput]>;

    dripConfigActions(
      name: string,
      overrides?: CallOverrides
    ): Promise<[Drippie.DripActionStructOutput[]]>;

    dripConfigCheckAddress(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    dripConfigCheckParams(
      name: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    dripStateLast(
      name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    dripStatus(name: string, overrides?: CallOverrides): Promise<[number]>;

    /**
     * Maps from drip names to drip states.
     */
    drips(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [number, Drippie.DripConfigStructOutput, BigNumber, BigNumber] & {
        status: number;
        config: Drippie.DripConfigStructOutput;
        last: BigNumber;
        count: BigNumber;
      }
    >;

    /**
     * Checks if a given drip is executable.
     * @param _name Drip to check.
     */
    executable(_name: string, overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns the number of created drips.
     */
    getDripCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns the interval of a given drip.
     * @param _name Drip to check.
     */
    getDripInterval(
      _name: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the status of a given drip.
     * @param _name Drip to check.
     */
    getDripStatus(_name: string, overrides?: CallOverrides): Promise<[number]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the status for a given drip. The behavior of this function depends on the         status that the user is trying to set. A drip can always move between ACTIVE and         PAUSED, but it can never move back to NONE and once ARCHIVED, it can never move back         to ACTIVE or PAUSED.
     * @param _name Name of the drip to update.
     * @param _status New drip status.
     */
    status(
      _name: string,
      _status: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws partial ERC20 balance to the recipient.
     * @param _amount Amount of ERC20 to withdraw.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address,uint256)"(
      _asset: string,
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws full ERC20 balance to the recipient.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address)"(
      _asset: string,
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws ERC721 token to the recipient.
     * @param _asset ERC721 token to withdraw.
     * @param _id Token ID of the ERC721 token to withdraw.
     * @param _to Address to receive the ERC721 token.
     */
    withdrawERC721(
      _asset: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws partial ETH balance to the recipient.
     * @param _amount Amount of ETH to withdraw.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address,uint256)"(
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws full ETH balance to the recipient.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address)"(
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * Sends a CALL to a target address.
   * @param _data Data to send with the call.
   * @param _target Address to call.
   * @param _value ETH value to send with the call.
   */
  CALL(
    _target: string,
    _data: BytesLike,
    _value: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sends a DELEGATECALL to a target address.
   * @param _data Data to send with the call.
   * @param _target Address to call.
   */
  DELEGATECALL(
    _target: string,
    _data: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  create(
    _name: string,
    _config: Drippie.DripConfigStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Array of created drips. Used so offchain services can easily iterate over all drips         without resorting to event queries. Convenience feature and shouldn't really be         used onchain because the array will grow indefinitely.
   */
  created(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * Triggers a drip. This function is deliberately left as a public function because the         assumption being made here is that setting the drip to ACTIVE is an affirmative         signal that the drip should be executable according to the drip parameters, drip         check, and drip interval. Note that drip parameters are read entirely from the state         and are not supplied as user input, so there should not be any way for a         non-authorized user to influence the behavior of the drip. Note that the drip check         is executed only **once** at the beginning of the call to the drip function and will         not be executed again between the drip actions within this call.
   * @param _name Name of the drip to trigger.
   */
  drip(
    _name: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  dripConfig(
    name: string,
    overrides?: CallOverrides
  ): Promise<Drippie.DripConfigStructOutput>;

  dripConfigActions(
    name: string,
    overrides?: CallOverrides
  ): Promise<Drippie.DripActionStructOutput[]>;

  dripConfigCheckAddress(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  dripConfigCheckParams(
    name: string,
    overrides?: CallOverrides
  ): Promise<string>;

  dripStateLast(name: string, overrides?: CallOverrides): Promise<BigNumber>;

  dripStatus(name: string, overrides?: CallOverrides): Promise<number>;

  /**
   * Maps from drip names to drip states.
   */
  drips(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [number, Drippie.DripConfigStructOutput, BigNumber, BigNumber] & {
      status: number;
      config: Drippie.DripConfigStructOutput;
      last: BigNumber;
      count: BigNumber;
    }
  >;

  /**
   * Checks if a given drip is executable.
   * @param _name Drip to check.
   */
  executable(_name: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the number of created drips.
   */
  getDripCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the interval of a given drip.
   * @param _name Drip to check.
   */
  getDripInterval(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the status of a given drip.
   * @param _name Drip to check.
   */
  getDripStatus(_name: string, overrides?: CallOverrides): Promise<number>;

  owner(overrides?: CallOverrides): Promise<string>;

  setOwner(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the status for a given drip. The behavior of this function depends on the         status that the user is trying to set. A drip can always move between ACTIVE and         PAUSED, but it can never move back to NONE and once ARCHIVED, it can never move back         to ACTIVE or PAUSED.
   * @param _name Name of the drip to update.
   * @param _status New drip status.
   */
  status(
    _name: string,
    _status: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws partial ERC20 balance to the recipient.
   * @param _amount Amount of ERC20 to withdraw.
   * @param _asset ERC20 token to withdraw.
   * @param _to Address to receive the ERC20 balance.
   */
  "withdrawERC20(address,address,uint256)"(
    _asset: string,
    _to: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws full ERC20 balance to the recipient.
   * @param _asset ERC20 token to withdraw.
   * @param _to Address to receive the ERC20 balance.
   */
  "withdrawERC20(address,address)"(
    _asset: string,
    _to: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws ERC721 token to the recipient.
   * @param _asset ERC721 token to withdraw.
   * @param _id Token ID of the ERC721 token to withdraw.
   * @param _to Address to receive the ERC721 token.
   */
  withdrawERC721(
    _asset: string,
    _to: string,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws partial ETH balance to the recipient.
   * @param _amount Amount of ETH to withdraw.
   * @param _to Address to receive the ETH balance.
   */
  "withdrawETH(address,uint256)"(
    _to: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws full ETH balance to the recipient.
   * @param _to Address to receive the ETH balance.
   */
  "withdrawETH(address)"(
    _to: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Sends a CALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     * @param _value ETH value to send with the call.
     */
    CALL(
      _target: string,
      _data: BytesLike,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, string] & { success_: boolean; data_: string }>;

    /**
     * Sends a DELEGATECALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     */
    DELEGATECALL(
      _target: string,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean, string] & { success_: boolean; data_: string }>;

    create(
      _name: string,
      _config: Drippie.DripConfigStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Array of created drips. Used so offchain services can easily iterate over all drips         without resorting to event queries. Convenience feature and shouldn't really be         used onchain because the array will grow indefinitely.
     */
    created(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * Triggers a drip. This function is deliberately left as a public function because the         assumption being made here is that setting the drip to ACTIVE is an affirmative         signal that the drip should be executable according to the drip parameters, drip         check, and drip interval. Note that drip parameters are read entirely from the state         and are not supplied as user input, so there should not be any way for a         non-authorized user to influence the behavior of the drip. Note that the drip check         is executed only **once** at the beginning of the call to the drip function and will         not be executed again between the drip actions within this call.
     * @param _name Name of the drip to trigger.
     */
    drip(_name: string, overrides?: CallOverrides): Promise<void>;

    dripConfig(
      name: string,
      overrides?: CallOverrides
    ): Promise<Drippie.DripConfigStructOutput>;

    dripConfigActions(
      name: string,
      overrides?: CallOverrides
    ): Promise<Drippie.DripActionStructOutput[]>;

    dripConfigCheckAddress(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    dripConfigCheckParams(
      name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    dripStateLast(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    dripStatus(name: string, overrides?: CallOverrides): Promise<number>;

    /**
     * Maps from drip names to drip states.
     */
    drips(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [number, Drippie.DripConfigStructOutput, BigNumber, BigNumber] & {
        status: number;
        config: Drippie.DripConfigStructOutput;
        last: BigNumber;
        count: BigNumber;
      }
    >;

    /**
     * Checks if a given drip is executable.
     * @param _name Drip to check.
     */
    executable(_name: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the number of created drips.
     */
    getDripCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the interval of a given drip.
     * @param _name Drip to check.
     */
    getDripInterval(
      _name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the status of a given drip.
     * @param _name Drip to check.
     */
    getDripStatus(_name: string, overrides?: CallOverrides): Promise<number>;

    owner(overrides?: CallOverrides): Promise<string>;

    setOwner(newOwner: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Sets the status for a given drip. The behavior of this function depends on the         status that the user is trying to set. A drip can always move between ACTIVE and         PAUSED, but it can never move back to NONE and once ARCHIVED, it can never move back         to ACTIVE or PAUSED.
     * @param _name Name of the drip to update.
     * @param _status New drip status.
     */
    status(
      _name: string,
      _status: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws partial ERC20 balance to the recipient.
     * @param _amount Amount of ERC20 to withdraw.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address,uint256)"(
      _asset: string,
      _to: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws full ERC20 balance to the recipient.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address)"(
      _asset: string,
      _to: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws ERC721 token to the recipient.
     * @param _asset ERC721 token to withdraw.
     * @param _id Token ID of the ERC721 token to withdraw.
     * @param _to Address to receive the ERC721 token.
     */
    withdrawERC721(
      _asset: string,
      _to: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws partial ETH balance to the recipient.
     * @param _amount Amount of ETH to withdraw.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address,uint256)"(
      _to: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws full ETH balance to the recipient.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address)"(
      _to: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "DripCreated(string,string,(bool,uint256,address,bytes,(address,bytes,uint256)[]))"(
      nameref?: string | null,
      name?: null,
      config?: null
    ): DripCreatedEventFilter;
    DripCreated(
      nameref?: string | null,
      name?: null,
      config?: null
    ): DripCreatedEventFilter;

    "DripExecuted(string,string,address,uint256)"(
      nameref?: string | null,
      name?: null,
      executor?: null,
      timestamp?: null
    ): DripExecutedEventFilter;
    DripExecuted(
      nameref?: string | null,
      name?: null,
      executor?: null,
      timestamp?: null
    ): DripExecutedEventFilter;

    "DripStatusUpdated(string,string,uint8)"(
      nameref?: string | null,
      name?: null,
      status?: null
    ): DripStatusUpdatedEventFilter;
    DripStatusUpdated(
      nameref?: string | null,
      name?: null,
      status?: null
    ): DripStatusUpdatedEventFilter;

    "OwnerUpdated(address,address)"(
      user?: string | null,
      newOwner?: string | null
    ): OwnerUpdatedEventFilter;
    OwnerUpdated(
      user?: string | null,
      newOwner?: string | null
    ): OwnerUpdatedEventFilter;

    "ReceivedETH(address,uint256)"(
      from?: string | null,
      amount?: null
    ): ReceivedETHEventFilter;
    ReceivedETH(from?: string | null, amount?: null): ReceivedETHEventFilter;

    "WithdrewERC20(address,address,address,uint256)"(
      withdrawer?: string | null,
      recipient?: string | null,
      asset?: string | null,
      amount?: null
    ): WithdrewERC20EventFilter;
    WithdrewERC20(
      withdrawer?: string | null,
      recipient?: string | null,
      asset?: string | null,
      amount?: null
    ): WithdrewERC20EventFilter;

    "WithdrewERC721(address,address,address,uint256)"(
      withdrawer?: string | null,
      recipient?: string | null,
      asset?: string | null,
      id?: null
    ): WithdrewERC721EventFilter;
    WithdrewERC721(
      withdrawer?: string | null,
      recipient?: string | null,
      asset?: string | null,
      id?: null
    ): WithdrewERC721EventFilter;

    "WithdrewETH(address,address,uint256)"(
      withdrawer?: string | null,
      recipient?: string | null,
      amount?: null
    ): WithdrewETHEventFilter;
    WithdrewETH(
      withdrawer?: string | null,
      recipient?: string | null,
      amount?: null
    ): WithdrewETHEventFilter;
  };

  estimateGas: {
    /**
     * Sends a CALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     * @param _value ETH value to send with the call.
     */
    CALL(
      _target: string,
      _data: BytesLike,
      _value: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sends a DELEGATECALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     */
    DELEGATECALL(
      _target: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    create(
      _name: string,
      _config: Drippie.DripConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Array of created drips. Used so offchain services can easily iterate over all drips         without resorting to event queries. Convenience feature and shouldn't really be         used onchain because the array will grow indefinitely.
     */
    created(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Triggers a drip. This function is deliberately left as a public function because the         assumption being made here is that setting the drip to ACTIVE is an affirmative         signal that the drip should be executable according to the drip parameters, drip         check, and drip interval. Note that drip parameters are read entirely from the state         and are not supplied as user input, so there should not be any way for a         non-authorized user to influence the behavior of the drip. Note that the drip check         is executed only **once** at the beginning of the call to the drip function and will         not be executed again between the drip actions within this call.
     * @param _name Name of the drip to trigger.
     */
    drip(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    dripConfig(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    dripConfigActions(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dripConfigCheckAddress(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dripConfigCheckParams(
      name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dripStateLast(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    dripStatus(name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Maps from drip names to drip states.
     */
    drips(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Checks if a given drip is executable.
     * @param _name Drip to check.
     */
    executable(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the number of created drips.
     */
    getDripCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the interval of a given drip.
     * @param _name Drip to check.
     */
    getDripInterval(
      _name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the status of a given drip.
     * @param _name Drip to check.
     */
    getDripStatus(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the status for a given drip. The behavior of this function depends on the         status that the user is trying to set. A drip can always move between ACTIVE and         PAUSED, but it can never move back to NONE and once ARCHIVED, it can never move back         to ACTIVE or PAUSED.
     * @param _name Name of the drip to update.
     * @param _status New drip status.
     */
    status(
      _name: string,
      _status: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws partial ERC20 balance to the recipient.
     * @param _amount Amount of ERC20 to withdraw.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address,uint256)"(
      _asset: string,
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws full ERC20 balance to the recipient.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address)"(
      _asset: string,
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws ERC721 token to the recipient.
     * @param _asset ERC721 token to withdraw.
     * @param _id Token ID of the ERC721 token to withdraw.
     * @param _to Address to receive the ERC721 token.
     */
    withdrawERC721(
      _asset: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws partial ETH balance to the recipient.
     * @param _amount Amount of ETH to withdraw.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address,uint256)"(
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws full ETH balance to the recipient.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address)"(
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Sends a CALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     * @param _value ETH value to send with the call.
     */
    CALL(
      _target: string,
      _data: BytesLike,
      _value: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sends a DELEGATECALL to a target address.
     * @param _data Data to send with the call.
     * @param _target Address to call.
     */
    DELEGATECALL(
      _target: string,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    create(
      _name: string,
      _config: Drippie.DripConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Array of created drips. Used so offchain services can easily iterate over all drips         without resorting to event queries. Convenience feature and shouldn't really be         used onchain because the array will grow indefinitely.
     */
    created(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Triggers a drip. This function is deliberately left as a public function because the         assumption being made here is that setting the drip to ACTIVE is an affirmative         signal that the drip should be executable according to the drip parameters, drip         check, and drip interval. Note that drip parameters are read entirely from the state         and are not supplied as user input, so there should not be any way for a         non-authorized user to influence the behavior of the drip. Note that the drip check         is executed only **once** at the beginning of the call to the drip function and will         not be executed again between the drip actions within this call.
     * @param _name Name of the drip to trigger.
     */
    drip(
      _name: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    dripConfig(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dripConfigActions(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dripConfigCheckAddress(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dripConfigCheckParams(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dripStateLast(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dripStatus(
      name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Maps from drip names to drip states.
     */
    drips(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if a given drip is executable.
     * @param _name Drip to check.
     */
    executable(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the number of created drips.
     */
    getDripCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the interval of a given drip.
     * @param _name Drip to check.
     */
    getDripInterval(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the status of a given drip.
     * @param _name Drip to check.
     */
    getDripStatus(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setOwner(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the status for a given drip. The behavior of this function depends on the         status that the user is trying to set. A drip can always move between ACTIVE and         PAUSED, but it can never move back to NONE and once ARCHIVED, it can never move back         to ACTIVE or PAUSED.
     * @param _name Name of the drip to update.
     * @param _status New drip status.
     */
    status(
      _name: string,
      _status: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws partial ERC20 balance to the recipient.
     * @param _amount Amount of ERC20 to withdraw.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address,uint256)"(
      _asset: string,
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws full ERC20 balance to the recipient.
     * @param _asset ERC20 token to withdraw.
     * @param _to Address to receive the ERC20 balance.
     */
    "withdrawERC20(address,address)"(
      _asset: string,
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws ERC721 token to the recipient.
     * @param _asset ERC721 token to withdraw.
     * @param _id Token ID of the ERC721 token to withdraw.
     * @param _to Address to receive the ERC721 token.
     */
    withdrawERC721(
      _asset: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws partial ETH balance to the recipient.
     * @param _amount Amount of ETH to withdraw.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address,uint256)"(
      _to: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws full ETH balance to the recipient.
     * @param _to Address to receive the ETH balance.
     */
    "withdrawETH(address)"(
      _to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
