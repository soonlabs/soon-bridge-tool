/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace StdInvariant {
  export type FuzzSelectorStruct = { addr: string; selectors: BytesLike[] };

  export type FuzzSelectorStructOutput = [string, string[]] & {
    addr: string;
    selectors: string[];
  };

  export type FuzzInterfaceStruct = { addr: string; artifacts: string[] };

  export type FuzzInterfaceStructOutput = [string, string[]] & {
    addr: string;
    artifacts: string[];
  };
}

export declare namespace Drippie {
  export type DripActionStruct = {
    target: string;
    data: BytesLike;
    value: BigNumberish;
  };

  export type DripActionStructOutput = [string, string, BigNumber] & {
    target: string;
    data: string;
    value: BigNumber;
  };

  export type DripConfigStruct = {
    reentrant: boolean;
    interval: BigNumberish;
    dripcheck: string;
    checkparams: BytesLike;
    actions: Drippie.DripActionStruct[];
  };

  export type DripConfigStructOutput = [
    boolean,
    BigNumber,
    string,
    string,
    Drippie.DripActionStructOutput[]
  ] & {
    reentrant: boolean;
    interval: BigNumber;
    dripcheck: string;
    checkparams: string;
    actions: Drippie.DripActionStructOutput[];
  };
}

export interface Drippie_TestInterface extends utils.Interface {
  functions: {
    "IS_TEST()": FunctionFragment;
    "excludeArtifacts()": FunctionFragment;
    "excludeContracts()": FunctionFragment;
    "excludeSenders()": FunctionFragment;
    "failed()": FunctionFragment;
    "setUp()": FunctionFragment;
    "targetArtifactSelectors()": FunctionFragment;
    "targetArtifacts()": FunctionFragment;
    "targetContracts()": FunctionFragment;
    "targetInterfaces()": FunctionFragment;
    "targetSelectors()": FunctionFragment;
    "targetSenders()": FunctionFragment;
    "testFuzz_owner_unauthorized_reverts(address)": FunctionFragment;
    "test_create_calledTwice_reverts()": FunctionFragment;
    "test_create_succeeds()": FunctionFragment;
    "test_drip_amount_succeeds()": FunctionFragment;
    "test_drip_notExist_reverts()": FunctionFragment;
    "test_drip_reentrant_reverts()": FunctionFragment;
    "test_name_notExist_reverts()": FunctionFragment;
    "test_notReentrant_zeroInterval_reverts()": FunctionFragment;
    "test_not_active_reverts()": FunctionFragment;
    "test_reentrant_succeeds()": FunctionFragment;
    "test_set_statusNone_reverts()": FunctionFragment;
    "test_set_statusSame_reverts()": FunctionFragment;
    "test_set_status_succeeds()": FunctionFragment;
    "test_shouldArchive_ifPaused_succeeds()": FunctionFragment;
    "test_shouldNotAllowActive_ifArchived_reverts()": FunctionFragment;
    "test_shouldNotAllowPaused_ifArchived_reverts()": FunctionFragment;
    "test_shouldNotArchive_ifActive_reverts()": FunctionFragment;
    "test_status_unauthorized_reverts()": FunctionFragment;
    "test_trigger_oneFunction_succeeds()": FunctionFragment;
    "test_trigger_twoFunctions_succeeds()": FunctionFragment;
    "test_twice_inOneInterval_reverts()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "IS_TEST"
      | "excludeArtifacts"
      | "excludeContracts"
      | "excludeSenders"
      | "failed"
      | "setUp"
      | "targetArtifactSelectors"
      | "targetArtifacts"
      | "targetContracts"
      | "targetInterfaces"
      | "targetSelectors"
      | "targetSenders"
      | "testFuzz_owner_unauthorized_reverts"
      | "test_create_calledTwice_reverts"
      | "test_create_succeeds"
      | "test_drip_amount_succeeds"
      | "test_drip_notExist_reverts"
      | "test_drip_reentrant_reverts"
      | "test_name_notExist_reverts"
      | "test_notReentrant_zeroInterval_reverts"
      | "test_not_active_reverts"
      | "test_reentrant_succeeds"
      | "test_set_statusNone_reverts"
      | "test_set_statusSame_reverts"
      | "test_set_status_succeeds"
      | "test_shouldArchive_ifPaused_succeeds"
      | "test_shouldNotAllowActive_ifArchived_reverts"
      | "test_shouldNotAllowPaused_ifArchived_reverts"
      | "test_shouldNotArchive_ifActive_reverts"
      | "test_status_unauthorized_reverts"
      | "test_trigger_oneFunction_succeeds"
      | "test_trigger_twoFunctions_succeeds"
      | "test_twice_inOneInterval_reverts"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "IS_TEST", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "excludeArtifacts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeContracts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeSenders",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "failed", values?: undefined): string;
  encodeFunctionData(functionFragment: "setUp", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "targetArtifactSelectors",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetArtifacts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetContracts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetInterfaces",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetSelectors",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetSenders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "testFuzz_owner_unauthorized_reverts",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "test_create_calledTwice_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_create_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_drip_amount_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_drip_notExist_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_drip_reentrant_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_name_notExist_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_notReentrant_zeroInterval_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_not_active_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_reentrant_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_set_statusNone_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_set_statusSame_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_set_status_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_shouldArchive_ifPaused_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_shouldNotAllowActive_ifArchived_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_shouldNotAllowPaused_ifArchived_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_shouldNotArchive_ifActive_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_status_unauthorized_reverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_trigger_oneFunction_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_trigger_twoFunctions_succeeds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "test_twice_inOneInterval_reverts",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "IS_TEST", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "excludeArtifacts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeSenders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "failed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "targetArtifactSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetArtifacts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetInterfaces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetSenders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testFuzz_owner_unauthorized_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_create_calledTwice_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_create_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_drip_amount_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_drip_notExist_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_drip_reentrant_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_name_notExist_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_notReentrant_zeroInterval_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_not_active_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_reentrant_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_set_statusNone_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_set_statusSame_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_set_status_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_shouldArchive_ifPaused_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_shouldNotAllowActive_ifArchived_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_shouldNotAllowPaused_ifArchived_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_shouldNotArchive_ifActive_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_status_unauthorized_reverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_trigger_oneFunction_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_trigger_twoFunctions_succeeds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_twice_inOneInterval_reverts",
    data: BytesLike
  ): Result;

  events: {
    "DripCreated(string,string,(bool,uint256,address,bytes,(address,bytes,uint256)[]))": EventFragment;
    "DripExecuted(string,string,address,uint256)": EventFragment;
    "DripStatusUpdated(string,string,uint8)": EventFragment;
    "log(string)": EventFragment;
    "log_address(address)": EventFragment;
    "log_array(uint256[])": EventFragment;
    "log_array(int256[])": EventFragment;
    "log_array(address[])": EventFragment;
    "log_bytes(bytes)": EventFragment;
    "log_bytes32(bytes32)": EventFragment;
    "log_int(int256)": EventFragment;
    "log_named_address(string,address)": EventFragment;
    "log_named_array(string,uint256[])": EventFragment;
    "log_named_array(string,int256[])": EventFragment;
    "log_named_array(string,address[])": EventFragment;
    "log_named_bytes(string,bytes)": EventFragment;
    "log_named_bytes32(string,bytes32)": EventFragment;
    "log_named_decimal_int(string,int256,uint256)": EventFragment;
    "log_named_decimal_uint(string,uint256,uint256)": EventFragment;
    "log_named_int(string,int256)": EventFragment;
    "log_named_string(string,string)": EventFragment;
    "log_named_uint(string,uint256)": EventFragment;
    "log_string(string)": EventFragment;
    "log_uint(uint256)": EventFragment;
    "logs(bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DripCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DripExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DripStatusUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_address"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(uint256[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(int256[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_array(address[])"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_bytes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_bytes32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_address"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,uint256[])"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,int256[])"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "log_named_array(string,address[])"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_bytes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_bytes32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_decimal_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_decimal_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_int"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_string"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_named_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_string"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "log_uint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "logs"): EventFragment;
}

export interface DripCreatedEventObject {
  nameref: string;
  name: string;
  config: Drippie.DripConfigStructOutput;
}
export type DripCreatedEvent = TypedEvent<
  [string, string, Drippie.DripConfigStructOutput],
  DripCreatedEventObject
>;

export type DripCreatedEventFilter = TypedEventFilter<DripCreatedEvent>;

export interface DripExecutedEventObject {
  nameref: string;
  name: string;
  executor: string;
  timestamp: BigNumber;
}
export type DripExecutedEvent = TypedEvent<
  [string, string, string, BigNumber],
  DripExecutedEventObject
>;

export type DripExecutedEventFilter = TypedEventFilter<DripExecutedEvent>;

export interface DripStatusUpdatedEventObject {
  nameref: string;
  name: string;
  status: number;
}
export type DripStatusUpdatedEvent = TypedEvent<
  [string, string, number],
  DripStatusUpdatedEventObject
>;

export type DripStatusUpdatedEventFilter =
  TypedEventFilter<DripStatusUpdatedEvent>;

export interface logEventObject {
  arg0: string;
}
export type logEvent = TypedEvent<[string], logEventObject>;

export type logEventFilter = TypedEventFilter<logEvent>;

export interface log_addressEventObject {
  arg0: string;
}
export type log_addressEvent = TypedEvent<[string], log_addressEventObject>;

export type log_addressEventFilter = TypedEventFilter<log_addressEvent>;

export interface log_array_uint256_array_EventObject {
  val: BigNumber[];
}
export type log_array_uint256_array_Event = TypedEvent<
  [BigNumber[]],
  log_array_uint256_array_EventObject
>;

export type log_array_uint256_array_EventFilter =
  TypedEventFilter<log_array_uint256_array_Event>;

export interface log_array_int256_array_EventObject {
  val: BigNumber[];
}
export type log_array_int256_array_Event = TypedEvent<
  [BigNumber[]],
  log_array_int256_array_EventObject
>;

export type log_array_int256_array_EventFilter =
  TypedEventFilter<log_array_int256_array_Event>;

export interface log_array_address_array_EventObject {
  val: string[];
}
export type log_array_address_array_Event = TypedEvent<
  [string[]],
  log_array_address_array_EventObject
>;

export type log_array_address_array_EventFilter =
  TypedEventFilter<log_array_address_array_Event>;

export interface log_bytesEventObject {
  arg0: string;
}
export type log_bytesEvent = TypedEvent<[string], log_bytesEventObject>;

export type log_bytesEventFilter = TypedEventFilter<log_bytesEvent>;

export interface log_bytes32EventObject {
  arg0: string;
}
export type log_bytes32Event = TypedEvent<[string], log_bytes32EventObject>;

export type log_bytes32EventFilter = TypedEventFilter<log_bytes32Event>;

export interface log_intEventObject {
  arg0: BigNumber;
}
export type log_intEvent = TypedEvent<[BigNumber], log_intEventObject>;

export type log_intEventFilter = TypedEventFilter<log_intEvent>;

export interface log_named_addressEventObject {
  key: string;
  val: string;
}
export type log_named_addressEvent = TypedEvent<
  [string, string],
  log_named_addressEventObject
>;

export type log_named_addressEventFilter =
  TypedEventFilter<log_named_addressEvent>;

export interface log_named_array_string_uint256_array_EventObject {
  key: string;
  val: BigNumber[];
}
export type log_named_array_string_uint256_array_Event = TypedEvent<
  [string, BigNumber[]],
  log_named_array_string_uint256_array_EventObject
>;

export type log_named_array_string_uint256_array_EventFilter =
  TypedEventFilter<log_named_array_string_uint256_array_Event>;

export interface log_named_array_string_int256_array_EventObject {
  key: string;
  val: BigNumber[];
}
export type log_named_array_string_int256_array_Event = TypedEvent<
  [string, BigNumber[]],
  log_named_array_string_int256_array_EventObject
>;

export type log_named_array_string_int256_array_EventFilter =
  TypedEventFilter<log_named_array_string_int256_array_Event>;

export interface log_named_array_string_address_array_EventObject {
  key: string;
  val: string[];
}
export type log_named_array_string_address_array_Event = TypedEvent<
  [string, string[]],
  log_named_array_string_address_array_EventObject
>;

export type log_named_array_string_address_array_EventFilter =
  TypedEventFilter<log_named_array_string_address_array_Event>;

export interface log_named_bytesEventObject {
  key: string;
  val: string;
}
export type log_named_bytesEvent = TypedEvent<
  [string, string],
  log_named_bytesEventObject
>;

export type log_named_bytesEventFilter = TypedEventFilter<log_named_bytesEvent>;

export interface log_named_bytes32EventObject {
  key: string;
  val: string;
}
export type log_named_bytes32Event = TypedEvent<
  [string, string],
  log_named_bytes32EventObject
>;

export type log_named_bytes32EventFilter =
  TypedEventFilter<log_named_bytes32Event>;

export interface log_named_decimal_intEventObject {
  key: string;
  val: BigNumber;
  decimals: BigNumber;
}
export type log_named_decimal_intEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  log_named_decimal_intEventObject
>;

export type log_named_decimal_intEventFilter =
  TypedEventFilter<log_named_decimal_intEvent>;

export interface log_named_decimal_uintEventObject {
  key: string;
  val: BigNumber;
  decimals: BigNumber;
}
export type log_named_decimal_uintEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  log_named_decimal_uintEventObject
>;

export type log_named_decimal_uintEventFilter =
  TypedEventFilter<log_named_decimal_uintEvent>;

export interface log_named_intEventObject {
  key: string;
  val: BigNumber;
}
export type log_named_intEvent = TypedEvent<
  [string, BigNumber],
  log_named_intEventObject
>;

export type log_named_intEventFilter = TypedEventFilter<log_named_intEvent>;

export interface log_named_stringEventObject {
  key: string;
  val: string;
}
export type log_named_stringEvent = TypedEvent<
  [string, string],
  log_named_stringEventObject
>;

export type log_named_stringEventFilter =
  TypedEventFilter<log_named_stringEvent>;

export interface log_named_uintEventObject {
  key: string;
  val: BigNumber;
}
export type log_named_uintEvent = TypedEvent<
  [string, BigNumber],
  log_named_uintEventObject
>;

export type log_named_uintEventFilter = TypedEventFilter<log_named_uintEvent>;

export interface log_stringEventObject {
  arg0: string;
}
export type log_stringEvent = TypedEvent<[string], log_stringEventObject>;

export type log_stringEventFilter = TypedEventFilter<log_stringEvent>;

export interface log_uintEventObject {
  arg0: BigNumber;
}
export type log_uintEvent = TypedEvent<[BigNumber], log_uintEventObject>;

export type log_uintEventFilter = TypedEventFilter<log_uintEvent>;

export interface logsEventObject {
  arg0: string;
}
export type logsEvent = TypedEvent<[string], logsEventObject>;

export type logsEventFilter = TypedEventFilter<logsEvent>;

export interface Drippie_Test extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: Drippie_TestInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    IS_TEST(overrides?: CallOverrides): Promise<[boolean]>;

    excludeArtifacts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedArtifacts_: string[] }>;

    excludeContracts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedContracts_: string[] }>;

    excludeSenders(
      overrides?: CallOverrides
    ): Promise<[string[]] & { excludedSenders_: string[] }>;

    failed(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Set up the test suite by deploying a CheckTrue DripCheck.         This is a mock that always returns true. Alice is the owner         and also give drippie 1 ether so that it can balance transfer.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzSelectorStructOutput[]] & {
        targetedArtifactSelectors_: StdInvariant.FuzzSelectorStructOutput[];
      }
    >;

    targetArtifacts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedArtifacts_: string[] }>;

    targetContracts(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedContracts_: string[] }>;

    targetInterfaces(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzInterfaceStructOutput[]] & {
        targetedInterfaces_: StdInvariant.FuzzInterfaceStructOutput[];
      }
    >;

    targetSelectors(
      overrides?: CallOverrides
    ): Promise<
      [StdInvariant.FuzzSelectorStructOutput[]] & {
        targetedSelectors_: StdInvariant.FuzzSelectorStructOutput[];
      }
    >;

    targetSenders(
      overrides?: CallOverrides
    ): Promise<[string[]] & { targetedSenders_: string[] }>;

    /**
     * Ensures that only the owner of Drippie can create a drip.
     */
    testFuzz_owner_unauthorized_reverts(
      caller: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Ensures that the same drip cannot be created two times.
     */
    test_create_calledTwice_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates a drip and asserts that it was configured as expected.
     */
    test_create_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The drip should execute and be able to transfer value.
     */
    test_drip_amount_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * It should revert if attempting to trigger a drip that does not exist.         Note that the drip was never created at the beginning of the test.
     */
    test_drip_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * A non zero interval when reentrant is true will cause a revert         when creating a drip.
     */
    test_drip_reentrant_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Attempt to update a drip that does not exist.
     */
    test_name_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * If reentrant is false and the interval is 0 then it should         revert when the drip is created.
     */
    test_notReentrant_zeroInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner cannot trigger the drip when it is paused.
     */
    test_not_active_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The interval must be 0 if reentrant is set on the config.
     */
    test_reentrant_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The drip status cannot be set back to NONE after it is created.
     */
    test_set_statusNone_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner cannot set the status of the drip to the status that         it is already set as.
     */
    test_set_statusSame_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner should be able to set the status of the drip.
     */
    test_set_status_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner should be able to archive the drip if it is in the         paused state.
     */
    test_shouldArchive_ifPaused_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner should not be allowed to make the drip active again if         it has already been archived.
     */
    test_shouldNotAllowActive_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner should not be allowed to pause the drip if it         has already been archived.
     */
    test_shouldNotAllowPaused_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The owner should not be able to archive the drip if it is in the         active state.
     */
    test_shouldNotArchive_ifActive_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Expect a revert when attempting to set the status when not the owner.
     */
    test_status_unauthorized_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * A single DripAction should be able to make a state modifying call.
     */
    test_trigger_oneFunction_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Multiple drip actions should be able to be triggered with the same check.
     */
    test_trigger_twoFunctions_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The drips can only be triggered once per interval. Attempt to         trigger the same drip multiple times in the same interval. Then         move forward to the next interval and it should trigger.
     */
    test_twice_inOneInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  IS_TEST(overrides?: CallOverrides): Promise<boolean>;

  excludeArtifacts(overrides?: CallOverrides): Promise<string[]>;

  excludeContracts(overrides?: CallOverrides): Promise<string[]>;

  excludeSenders(overrides?: CallOverrides): Promise<string[]>;

  failed(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Set up the test suite by deploying a CheckTrue DripCheck.         This is a mock that always returns true. Alice is the owner         and also give drippie 1 ether so that it can balance transfer.
   */
  setUp(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  targetArtifactSelectors(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

  targetArtifacts(overrides?: CallOverrides): Promise<string[]>;

  targetContracts(overrides?: CallOverrides): Promise<string[]>;

  targetInterfaces(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzInterfaceStructOutput[]>;

  targetSelectors(
    overrides?: CallOverrides
  ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

  targetSenders(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Ensures that only the owner of Drippie can create a drip.
   */
  testFuzz_owner_unauthorized_reverts(
    caller: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Ensures that the same drip cannot be created two times.
   */
  test_create_calledTwice_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates a drip and asserts that it was configured as expected.
   */
  test_create_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The drip should execute and be able to transfer value.
   */
  test_drip_amount_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * It should revert if attempting to trigger a drip that does not exist.         Note that the drip was never created at the beginning of the test.
   */
  test_drip_notExist_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * A non zero interval when reentrant is true will cause a revert         when creating a drip.
   */
  test_drip_reentrant_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Attempt to update a drip that does not exist.
   */
  test_name_notExist_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * If reentrant is false and the interval is 0 then it should         revert when the drip is created.
   */
  test_notReentrant_zeroInterval_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner cannot trigger the drip when it is paused.
   */
  test_not_active_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The interval must be 0 if reentrant is set on the config.
   */
  test_reentrant_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The drip status cannot be set back to NONE after it is created.
   */
  test_set_statusNone_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner cannot set the status of the drip to the status that         it is already set as.
   */
  test_set_statusSame_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner should be able to set the status of the drip.
   */
  test_set_status_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner should be able to archive the drip if it is in the         paused state.
   */
  test_shouldArchive_ifPaused_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner should not be allowed to make the drip active again if         it has already been archived.
   */
  test_shouldNotAllowActive_ifArchived_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner should not be allowed to pause the drip if it         has already been archived.
   */
  test_shouldNotAllowPaused_ifArchived_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The owner should not be able to archive the drip if it is in the         active state.
   */
  test_shouldNotArchive_ifActive_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Expect a revert when attempting to set the status when not the owner.
   */
  test_status_unauthorized_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * A single DripAction should be able to make a state modifying call.
   */
  test_trigger_oneFunction_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Multiple drip actions should be able to be triggered with the same check.
   */
  test_trigger_twoFunctions_succeeds(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The drips can only be triggered once per interval. Attempt to         trigger the same drip multiple times in the same interval. Then         move forward to the next interval and it should trigger.
   */
  test_twice_inOneInterval_reverts(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    IS_TEST(overrides?: CallOverrides): Promise<boolean>;

    excludeArtifacts(overrides?: CallOverrides): Promise<string[]>;

    excludeContracts(overrides?: CallOverrides): Promise<string[]>;

    excludeSenders(overrides?: CallOverrides): Promise<string[]>;

    failed(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Set up the test suite by deploying a CheckTrue DripCheck.         This is a mock that always returns true. Alice is the owner         and also give drippie 1 ether so that it can balance transfer.
     */
    setUp(overrides?: CallOverrides): Promise<void>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

    targetArtifacts(overrides?: CallOverrides): Promise<string[]>;

    targetContracts(overrides?: CallOverrides): Promise<string[]>;

    targetInterfaces(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzInterfaceStructOutput[]>;

    targetSelectors(
      overrides?: CallOverrides
    ): Promise<StdInvariant.FuzzSelectorStructOutput[]>;

    targetSenders(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Ensures that only the owner of Drippie can create a drip.
     */
    testFuzz_owner_unauthorized_reverts(
      caller: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Ensures that the same drip cannot be created two times.
     */
    test_create_calledTwice_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * Creates a drip and asserts that it was configured as expected.
     */
    test_create_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * The drip should execute and be able to transfer value.
     */
    test_drip_amount_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * It should revert if attempting to trigger a drip that does not exist.         Note that the drip was never created at the beginning of the test.
     */
    test_drip_notExist_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * A non zero interval when reentrant is true will cause a revert         when creating a drip.
     */
    test_drip_reentrant_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * Attempt to update a drip that does not exist.
     */
    test_name_notExist_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * If reentrant is false and the interval is 0 then it should         revert when the drip is created.
     */
    test_notReentrant_zeroInterval_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The owner cannot trigger the drip when it is paused.
     */
    test_not_active_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * The interval must be 0 if reentrant is set on the config.
     */
    test_reentrant_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * The drip status cannot be set back to NONE after it is created.
     */
    test_set_statusNone_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * The owner cannot set the status of the drip to the status that         it is already set as.
     */
    test_set_statusSame_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * The owner should be able to set the status of the drip.
     */
    test_set_status_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * The owner should be able to archive the drip if it is in the         paused state.
     */
    test_shouldArchive_ifPaused_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The owner should not be allowed to make the drip active again if         it has already been archived.
     */
    test_shouldNotAllowActive_ifArchived_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The owner should not be allowed to pause the drip if it         has already been archived.
     */
    test_shouldNotAllowPaused_ifArchived_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The owner should not be able to archive the drip if it is in the         active state.
     */
    test_shouldNotArchive_ifActive_reverts(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Expect a revert when attempting to set the status when not the owner.
     */
    test_status_unauthorized_reverts(overrides?: CallOverrides): Promise<void>;

    /**
     * A single DripAction should be able to make a state modifying call.
     */
    test_trigger_oneFunction_succeeds(overrides?: CallOverrides): Promise<void>;

    /**
     * Multiple drip actions should be able to be triggered with the same check.
     */
    test_trigger_twoFunctions_succeeds(
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The drips can only be triggered once per interval. Attempt to         trigger the same drip multiple times in the same interval. Then         move forward to the next interval and it should trigger.
     */
    test_twice_inOneInterval_reverts(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "DripCreated(string,string,(bool,uint256,address,bytes,(address,bytes,uint256)[]))"(
      nameref?: string | null,
      name?: null,
      config?: null
    ): DripCreatedEventFilter;
    DripCreated(
      nameref?: string | null,
      name?: null,
      config?: null
    ): DripCreatedEventFilter;

    "DripExecuted(string,string,address,uint256)"(
      nameref?: string | null,
      name?: null,
      executor?: null,
      timestamp?: null
    ): DripExecutedEventFilter;
    DripExecuted(
      nameref?: string | null,
      name?: null,
      executor?: null,
      timestamp?: null
    ): DripExecutedEventFilter;

    "DripStatusUpdated(string,string,uint8)"(
      nameref?: string | null,
      name?: null,
      status?: null
    ): DripStatusUpdatedEventFilter;
    DripStatusUpdated(
      nameref?: string | null,
      name?: null,
      status?: null
    ): DripStatusUpdatedEventFilter;

    "log(string)"(arg0?: null): logEventFilter;
    log(arg0?: null): logEventFilter;

    "log_address(address)"(arg0?: null): log_addressEventFilter;
    log_address(arg0?: null): log_addressEventFilter;

    "log_array(uint256[])"(val?: null): log_array_uint256_array_EventFilter;
    "log_array(int256[])"(val?: null): log_array_int256_array_EventFilter;
    "log_array(address[])"(val?: null): log_array_address_array_EventFilter;

    "log_bytes(bytes)"(arg0?: null): log_bytesEventFilter;
    log_bytes(arg0?: null): log_bytesEventFilter;

    "log_bytes32(bytes32)"(arg0?: null): log_bytes32EventFilter;
    log_bytes32(arg0?: null): log_bytes32EventFilter;

    "log_int(int256)"(arg0?: null): log_intEventFilter;
    log_int(arg0?: null): log_intEventFilter;

    "log_named_address(string,address)"(
      key?: null,
      val?: null
    ): log_named_addressEventFilter;
    log_named_address(key?: null, val?: null): log_named_addressEventFilter;

    "log_named_array(string,uint256[])"(
      key?: null,
      val?: null
    ): log_named_array_string_uint256_array_EventFilter;
    "log_named_array(string,int256[])"(
      key?: null,
      val?: null
    ): log_named_array_string_int256_array_EventFilter;
    "log_named_array(string,address[])"(
      key?: null,
      val?: null
    ): log_named_array_string_address_array_EventFilter;

    "log_named_bytes(string,bytes)"(
      key?: null,
      val?: null
    ): log_named_bytesEventFilter;
    log_named_bytes(key?: null, val?: null): log_named_bytesEventFilter;

    "log_named_bytes32(string,bytes32)"(
      key?: null,
      val?: null
    ): log_named_bytes32EventFilter;
    log_named_bytes32(key?: null, val?: null): log_named_bytes32EventFilter;

    "log_named_decimal_int(string,int256,uint256)"(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_intEventFilter;
    log_named_decimal_int(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_intEventFilter;

    "log_named_decimal_uint(string,uint256,uint256)"(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_uintEventFilter;
    log_named_decimal_uint(
      key?: null,
      val?: null,
      decimals?: null
    ): log_named_decimal_uintEventFilter;

    "log_named_int(string,int256)"(
      key?: null,
      val?: null
    ): log_named_intEventFilter;
    log_named_int(key?: null, val?: null): log_named_intEventFilter;

    "log_named_string(string,string)"(
      key?: null,
      val?: null
    ): log_named_stringEventFilter;
    log_named_string(key?: null, val?: null): log_named_stringEventFilter;

    "log_named_uint(string,uint256)"(
      key?: null,
      val?: null
    ): log_named_uintEventFilter;
    log_named_uint(key?: null, val?: null): log_named_uintEventFilter;

    "log_string(string)"(arg0?: null): log_stringEventFilter;
    log_string(arg0?: null): log_stringEventFilter;

    "log_uint(uint256)"(arg0?: null): log_uintEventFilter;
    log_uint(arg0?: null): log_uintEventFilter;

    "logs(bytes)"(arg0?: null): logsEventFilter;
    logs(arg0?: null): logsEventFilter;
  };

  estimateGas: {
    IS_TEST(overrides?: CallOverrides): Promise<BigNumber>;

    excludeArtifacts(overrides?: CallOverrides): Promise<BigNumber>;

    excludeContracts(overrides?: CallOverrides): Promise<BigNumber>;

    excludeSenders(overrides?: CallOverrides): Promise<BigNumber>;

    failed(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Set up the test suite by deploying a CheckTrue DripCheck.         This is a mock that always returns true. Alice is the owner         and also give drippie 1 ether so that it can balance transfer.
     */
    setUp(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    targetArtifactSelectors(overrides?: CallOverrides): Promise<BigNumber>;

    targetArtifacts(overrides?: CallOverrides): Promise<BigNumber>;

    targetContracts(overrides?: CallOverrides): Promise<BigNumber>;

    targetInterfaces(overrides?: CallOverrides): Promise<BigNumber>;

    targetSelectors(overrides?: CallOverrides): Promise<BigNumber>;

    targetSenders(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Ensures that only the owner of Drippie can create a drip.
     */
    testFuzz_owner_unauthorized_reverts(
      caller: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Ensures that the same drip cannot be created two times.
     */
    test_create_calledTwice_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates a drip and asserts that it was configured as expected.
     */
    test_create_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The drip should execute and be able to transfer value.
     */
    test_drip_amount_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * It should revert if attempting to trigger a drip that does not exist.         Note that the drip was never created at the beginning of the test.
     */
    test_drip_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * A non zero interval when reentrant is true will cause a revert         when creating a drip.
     */
    test_drip_reentrant_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Attempt to update a drip that does not exist.
     */
    test_name_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * If reentrant is false and the interval is 0 then it should         revert when the drip is created.
     */
    test_notReentrant_zeroInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner cannot trigger the drip when it is paused.
     */
    test_not_active_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The interval must be 0 if reentrant is set on the config.
     */
    test_reentrant_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The drip status cannot be set back to NONE after it is created.
     */
    test_set_statusNone_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner cannot set the status of the drip to the status that         it is already set as.
     */
    test_set_statusSame_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner should be able to set the status of the drip.
     */
    test_set_status_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner should be able to archive the drip if it is in the         paused state.
     */
    test_shouldArchive_ifPaused_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner should not be allowed to make the drip active again if         it has already been archived.
     */
    test_shouldNotAllowActive_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner should not be allowed to pause the drip if it         has already been archived.
     */
    test_shouldNotAllowPaused_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The owner should not be able to archive the drip if it is in the         active state.
     */
    test_shouldNotArchive_ifActive_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Expect a revert when attempting to set the status when not the owner.
     */
    test_status_unauthorized_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * A single DripAction should be able to make a state modifying call.
     */
    test_trigger_oneFunction_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Multiple drip actions should be able to be triggered with the same check.
     */
    test_trigger_twoFunctions_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The drips can only be triggered once per interval. Attempt to         trigger the same drip multiple times in the same interval. Then         move forward to the next interval and it should trigger.
     */
    test_twice_inOneInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    IS_TEST(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    excludeArtifacts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    excludeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    excludeSenders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    failed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Set up the test suite by deploying a CheckTrue DripCheck.         This is a mock that always returns true. Alice is the owner         and also give drippie 1 ether so that it can balance transfer.
     */
    setUp(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    targetArtifactSelectors(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targetArtifacts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetInterfaces(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetSelectors(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetSenders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Ensures that only the owner of Drippie can create a drip.
     */
    testFuzz_owner_unauthorized_reverts(
      caller: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Ensures that the same drip cannot be created two times.
     */
    test_create_calledTwice_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a drip and asserts that it was configured as expected.
     */
    test_create_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The drip should execute and be able to transfer value.
     */
    test_drip_amount_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * It should revert if attempting to trigger a drip that does not exist.         Note that the drip was never created at the beginning of the test.
     */
    test_drip_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * A non zero interval when reentrant is true will cause a revert         when creating a drip.
     */
    test_drip_reentrant_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Attempt to update a drip that does not exist.
     */
    test_name_notExist_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * If reentrant is false and the interval is 0 then it should         revert when the drip is created.
     */
    test_notReentrant_zeroInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner cannot trigger the drip when it is paused.
     */
    test_not_active_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The interval must be 0 if reentrant is set on the config.
     */
    test_reentrant_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The drip status cannot be set back to NONE after it is created.
     */
    test_set_statusNone_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner cannot set the status of the drip to the status that         it is already set as.
     */
    test_set_statusSame_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner should be able to set the status of the drip.
     */
    test_set_status_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner should be able to archive the drip if it is in the         paused state.
     */
    test_shouldArchive_ifPaused_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner should not be allowed to make the drip active again if         it has already been archived.
     */
    test_shouldNotAllowActive_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner should not be allowed to pause the drip if it         has already been archived.
     */
    test_shouldNotAllowPaused_ifArchived_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The owner should not be able to archive the drip if it is in the         active state.
     */
    test_shouldNotArchive_ifActive_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Expect a revert when attempting to set the status when not the owner.
     */
    test_status_unauthorized_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * A single DripAction should be able to make a state modifying call.
     */
    test_trigger_oneFunction_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Multiple drip actions should be able to be triggered with the same check.
     */
    test_trigger_twoFunctions_succeeds(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The drips can only be triggered once per interval. Attempt to         trigger the same drip multiple times in the same interval. Then         move forward to the next interval and it should trigger.
     */
    test_twice_inOneInterval_reverts(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
