/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface KailuaTreasuryInterface extends utils.Interface {
  functions: {
    "DISPUTE_GAME_FACTORY()": FunctionFragment;
    "FPVM_IMAGE_ID()": FunctionFragment;
    "GAME_TYPE()": FunctionFragment;
    "KAILUA_TREASURY()": FunctionFragment;
    "L2_BLOCK_NUMBER()": FunctionFragment;
    "OPTIMISM_PORTAL()": FunctionFragment;
    "OUTPUT_BLOCK_SPAN()": FunctionFragment;
    "PROPOSAL_BLOBS()": FunctionFragment;
    "PROPOSAL_OUTPUT_COUNT()": FunctionFragment;
    "RISC_ZERO_VERIFIER()": FunctionFragment;
    "ROLLUP_CONFIG_HASH()": FunctionFragment;
    "ROOT_CLAIM()": FunctionFragment;
    "appendChild()": FunctionFragment;
    "assignVanguard(address)": FunctionFragment;
    "blobsHash()": FunctionFragment;
    "childCount()": FunctionFragment;
    "children(uint256)": FunctionFragment;
    "claimEliminationBonds(uint256)": FunctionFragment;
    "claimProposerBond()": FunctionFragment;
    "contenderDuplicates(uint256)": FunctionFragment;
    "contenderIndex()": FunctionFragment;
    "createdAt()": FunctionFragment;
    "eliminate(address,address)": FunctionFragment;
    "eliminationRound(address)": FunctionFragment;
    "eliminations(address,uint256)": FunctionFragment;
    "eliminationsPaid(address)": FunctionFragment;
    "extraData()": FunctionFragment;
    "gameCreator()": FunctionFragment;
    "gameData()": FunctionFragment;
    "gameIndex()": FunctionFragment;
    "gameType()": FunctionFragment;
    "getChallengerDuration(uint256)": FunctionFragment;
    "initialize()": FunctionFragment;
    "isProposing()": FunctionFragment;
    "isViableSignature(bytes32)": FunctionFragment;
    "l1Head()": FunctionFragment;
    "l2BlockNumber()": FunctionFragment;
    "lastProposal(address)": FunctionFragment;
    "lastResolved()": FunctionFragment;
    "opponentIndex()": FunctionFragment;
    "paidBonds(address)": FunctionFragment;
    "parentGame()": FunctionFragment;
    "participationBond()": FunctionFragment;
    "proofStatus(bytes32)": FunctionFragment;
    "proposalBlobHashes(uint256)": FunctionFragment;
    "propose(bytes32,bytes)": FunctionFragment;
    "proposer()": FunctionFragment;
    "proposerOf(address)": FunctionFragment;
    "proveOutputFault(address[2],uint64[2],bytes,bytes32[2],uint256,bytes[][2])": FunctionFragment;
    "proveTrailFault(address,uint64[2],uint256,bytes,bytes)": FunctionFragment;
    "proveValidity(address,address,uint64,bytes)": FunctionFragment;
    "provenAt(bytes32)": FunctionFragment;
    "prover(bytes32)": FunctionFragment;
    "pruneChildren(uint256)": FunctionFragment;
    "removeVanguard(address)": FunctionFragment;
    "resolve()": FunctionFragment;
    "resolvedAt()": FunctionFragment;
    "rootClaim()": FunctionFragment;
    "setParticipationBond(uint256)": FunctionFragment;
    "signature()": FunctionFragment;
    "status()": FunctionFragment;
    "treasuryAddress()": FunctionFragment;
    "updateLastResolved()": FunctionFragment;
    "validChildSignature()": FunctionFragment;
    "vanguards(address)": FunctionFragment;
    "verifyIntermediateOutput(uint64,uint256,bytes,bytes)": FunctionFragment;
    "version()": FunctionFragment;
    "wasRespectedGameTypeWhenCreated()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DISPUTE_GAME_FACTORY"
      | "FPVM_IMAGE_ID"
      | "GAME_TYPE"
      | "KAILUA_TREASURY"
      | "L2_BLOCK_NUMBER"
      | "OPTIMISM_PORTAL"
      | "OUTPUT_BLOCK_SPAN"
      | "PROPOSAL_BLOBS"
      | "PROPOSAL_OUTPUT_COUNT"
      | "RISC_ZERO_VERIFIER"
      | "ROLLUP_CONFIG_HASH"
      | "ROOT_CLAIM"
      | "appendChild"
      | "assignVanguard"
      | "blobsHash"
      | "childCount"
      | "children"
      | "claimEliminationBonds"
      | "claimProposerBond"
      | "contenderDuplicates"
      | "contenderIndex"
      | "createdAt"
      | "eliminate"
      | "eliminationRound"
      | "eliminations"
      | "eliminationsPaid"
      | "extraData"
      | "gameCreator"
      | "gameData"
      | "gameIndex"
      | "gameType"
      | "getChallengerDuration"
      | "initialize"
      | "isProposing"
      | "isViableSignature"
      | "l1Head"
      | "l2BlockNumber"
      | "lastProposal"
      | "lastResolved"
      | "opponentIndex"
      | "paidBonds"
      | "parentGame"
      | "participationBond"
      | "proofStatus"
      | "proposalBlobHashes"
      | "propose"
      | "proposer"
      | "proposerOf"
      | "proveOutputFault"
      | "proveTrailFault"
      | "proveValidity"
      | "provenAt"
      | "prover"
      | "pruneChildren"
      | "removeVanguard"
      | "resolve"
      | "resolvedAt"
      | "rootClaim"
      | "setParticipationBond"
      | "signature"
      | "status"
      | "treasuryAddress"
      | "updateLastResolved"
      | "validChildSignature"
      | "vanguards"
      | "verifyIntermediateOutput"
      | "version"
      | "wasRespectedGameTypeWhenCreated"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DISPUTE_GAME_FACTORY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FPVM_IMAGE_ID",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "GAME_TYPE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "KAILUA_TREASURY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "L2_BLOCK_NUMBER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OPTIMISM_PORTAL",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OUTPUT_BLOCK_SPAN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_BLOBS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_OUTPUT_COUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RISC_ZERO_VERIFIER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROLLUP_CONFIG_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROOT_CLAIM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appendChild",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "assignVanguard",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "blobsHash", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "childCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "children",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimEliminationBonds",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimProposerBond",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "contenderDuplicates",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contenderIndex",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "createdAt", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "eliminate",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "eliminationRound",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "eliminations",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "eliminationsPaid",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "extraData", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "gameCreator",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "gameData", values?: undefined): string;
  encodeFunctionData(functionFragment: "gameIndex", values?: undefined): string;
  encodeFunctionData(functionFragment: "gameType", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getChallengerDuration",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isProposing",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isViableSignature",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "l1Head", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "l2BlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastProposal",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lastResolved",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "opponentIndex",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paidBonds", values: [string]): string;
  encodeFunctionData(
    functionFragment: "parentGame",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "participationBond",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proofStatus",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBlobHashes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "propose",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "proposer", values?: undefined): string;
  encodeFunctionData(functionFragment: "proposerOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "proveOutputFault",
    values: [
      [string, string],
      [BigNumberish, BigNumberish],
      BytesLike,
      [BytesLike, BytesLike],
      BigNumberish,
      [BytesLike[], BytesLike[]]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "proveTrailFault",
    values: [
      string,
      [BigNumberish, BigNumberish],
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "proveValidity",
    values: [string, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "provenAt", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "prover", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "pruneChildren",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeVanguard",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "resolve", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resolvedAt",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rootClaim", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setParticipationBond",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "signature", values?: undefined): string;
  encodeFunctionData(functionFragment: "status", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "treasuryAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateLastResolved",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "validChildSignature",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "vanguards", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verifyIntermediateOutput",
    values: [BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "wasRespectedGameTypeWhenCreated",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "DISPUTE_GAME_FACTORY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FPVM_IMAGE_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "GAME_TYPE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "KAILUA_TREASURY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "L2_BLOCK_NUMBER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OPTIMISM_PORTAL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OUTPUT_BLOCK_SPAN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_BLOBS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_OUTPUT_COUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RISC_ZERO_VERIFIER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROLLUP_CONFIG_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ROOT_CLAIM", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "appendChild",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assignVanguard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "blobsHash", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "childCount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "children", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimEliminationBonds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimProposerBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contenderDuplicates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contenderIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "createdAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "eliminate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "eliminationRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eliminations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eliminationsPaid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "extraData", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "gameCreator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gameData", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gameIndex", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gameType", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getChallengerDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isProposing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isViableSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "l1Head", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "l2BlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastResolved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "opponentIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paidBonds", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "parentGame", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "participationBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proofStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBlobHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "propose", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposer", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proveOutputFault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveTrailFault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveValidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "provenAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "prover", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pruneChildren",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeVanguard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resolve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resolvedAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rootClaim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setParticipationBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "signature", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "treasuryAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateLastResolved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validChildSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vanguards", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyIntermediateOutput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "wasRespectedGameTypeWhenCreated",
    data: BytesLike
  ): Result;

  events: {
    "BondUpdated(uint256)": EventFragment;
    "Proven(bytes32,uint8)": EventFragment;
    "Resolved(uint8)": EventFragment;
    "VanguardAdded(address)": EventFragment;
    "VanguardRemoved(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BondUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Proven"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Resolved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VanguardAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VanguardRemoved"): EventFragment;
}

export interface BondUpdatedEventObject {
  amount: BigNumber;
}
export type BondUpdatedEvent = TypedEvent<[BigNumber], BondUpdatedEventObject>;

export type BondUpdatedEventFilter = TypedEventFilter<BondUpdatedEvent>;

export interface ProvenEventObject {
  signature: string;
  status: number;
}
export type ProvenEvent = TypedEvent<[string, number], ProvenEventObject>;

export type ProvenEventFilter = TypedEventFilter<ProvenEvent>;

export interface ResolvedEventObject {
  status: number;
}
export type ResolvedEvent = TypedEvent<[number], ResolvedEventObject>;

export type ResolvedEventFilter = TypedEventFilter<ResolvedEvent>;

export interface VanguardAddedEventObject {
  vanguard: string;
}
export type VanguardAddedEvent = TypedEvent<[string], VanguardAddedEventObject>;

export type VanguardAddedEventFilter = TypedEventFilter<VanguardAddedEvent>;

export interface VanguardRemovedEventObject {
  vanguard: string;
}
export type VanguardRemovedEvent = TypedEvent<
  [string],
  VanguardRemovedEventObject
>;

export type VanguardRemovedEventFilter = TypedEventFilter<VanguardRemovedEvent>;

export interface KailuaTreasury extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: KailuaTreasuryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<[string]>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<[string]>;

    GAME_TYPE(overrides?: CallOverrides): Promise<[number]>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<[string]>;

    L2_BLOCK_NUMBER(overrides?: CallOverrides): Promise<[BigNumber]>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<[string]>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<[string]>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<[string]>;

    ROOT_CLAIM(overrides?: CallOverrides): Promise<[string]>;

    appendChild(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    assignVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    blobsHash(
      overrides?: CallOverrides
    ): Promise<[string] & { blobsHash_: string }>;

    childCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count_: BigNumber }>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    claimEliminationBonds(
      claims: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    claimProposerBond(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    contenderIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    createdAt(overrides?: CallOverrides): Promise<[BigNumber]>;

    eliminate(
      _child: string,
      prover: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    eliminationRound(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    eliminations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    eliminationsPaid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    extraData(
      overrides?: CallOverrides
    ): Promise<[string] & { extraData_: string }>;

    gameCreator(
      overrides?: CallOverrides
    ): Promise<[string] & { creator_: string }>;

    gameData(
      overrides?: CallOverrides
    ): Promise<
      [number, string, string] & {
        gameType_: number;
        rootClaim_: string;
        extraData_: string;
      }
    >;

    gameIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    gameType(
      overrides?: CallOverrides
    ): Promise<[number] & { gameType_: number }>;

    getChallengerDuration(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { duration_: BigNumber }>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    isProposing(overrides?: CallOverrides): Promise<[boolean]>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isViableSignature_: boolean }>;

    l1Head(overrides?: CallOverrides): Promise<[string] & { l1Head_: string }>;

    l2BlockNumber(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { l2BlockNumber_: BigNumber }>;

    lastProposal(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    lastResolved(overrides?: CallOverrides): Promise<[string]>;

    opponentIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    paidBonds(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    parentGame(
      overrides?: CallOverrides
    ): Promise<[string] & { parentGame_: string }>;

    participationBond(overrides?: CallOverrides): Promise<[BigNumber]>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<[number]>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    propose(
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    proposer(
      overrides?: CallOverrides
    ): Promise<[string] & { proposer_: string }>;

    proposerOf(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    removeVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    resolve(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    resolvedAt(overrides?: CallOverrides): Promise<[BigNumber]>;

    rootClaim(
      overrides?: CallOverrides
    ): Promise<[string] & { rootClaim_: string }>;

    setParticipationBond(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    signature(
      overrides?: CallOverrides
    ): Promise<[string] & { signature_: string }>;

    status(overrides?: CallOverrides): Promise<[number]>;

    treasuryAddress(
      overrides?: CallOverrides
    ): Promise<[string] & { treasuryAddress_: string }>;

    updateLastResolved(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    validChildSignature(overrides?: CallOverrides): Promise<[string]>;

    vanguards(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    verifyIntermediateOutput(
      arg0: BigNumberish,
      arg1: BigNumberish,
      arg2: BytesLike,
      arg3: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean] & { success: boolean }>;

    version(overrides?: CallOverrides): Promise<[string]>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<string>;

  FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<string>;

  GAME_TYPE(overrides?: CallOverrides): Promise<number>;

  KAILUA_TREASURY(overrides?: CallOverrides): Promise<string>;

  L2_BLOCK_NUMBER(overrides?: CallOverrides): Promise<BigNumber>;

  OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<string>;

  OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

  RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<string>;

  ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<string>;

  ROOT_CLAIM(overrides?: CallOverrides): Promise<string>;

  appendChild(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  assignVanguard(
    _vanguard: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  blobsHash(overrides?: CallOverrides): Promise<string>;

  childCount(overrides?: CallOverrides): Promise<BigNumber>;

  children(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  claimEliminationBonds(
    claims: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  claimProposerBond(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  contenderDuplicates(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

  createdAt(overrides?: CallOverrides): Promise<BigNumber>;

  eliminate(
    _child: string,
    prover: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  eliminationRound(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  eliminations(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  eliminationsPaid(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  extraData(overrides?: CallOverrides): Promise<string>;

  gameCreator(overrides?: CallOverrides): Promise<string>;

  gameData(
    overrides?: CallOverrides
  ): Promise<
    [number, string, string] & {
      gameType_: number;
      rootClaim_: string;
      extraData_: string;
    }
  >;

  gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

  gameType(overrides?: CallOverrides): Promise<number>;

  getChallengerDuration(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  isProposing(overrides?: CallOverrides): Promise<boolean>;

  isViableSignature(
    childSignature: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  l1Head(overrides?: CallOverrides): Promise<string>;

  l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  lastProposal(arg0: string, overrides?: CallOverrides): Promise<string>;

  lastResolved(overrides?: CallOverrides): Promise<string>;

  opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

  paidBonds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  parentGame(overrides?: CallOverrides): Promise<string>;

  participationBond(overrides?: CallOverrides): Promise<BigNumber>;

  proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<number>;

  proposalBlobHashes(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  propose(
    _rootClaim: BytesLike,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  proposer(overrides?: CallOverrides): Promise<string>;

  proposerOf(arg0: string, overrides?: CallOverrides): Promise<string>;

  proveOutputFault(
    prHs: [string, string],
    co: [BigNumberish, BigNumberish],
    encodedSeal: BytesLike,
    ac: [BytesLike, BytesLike],
    proposedOutputFe: BigNumberish,
    kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  proveTrailFault(
    payoutRecipient: string,
    co: [BigNumberish, BigNumberish],
    proposedOutputFe: BigNumberish,
    blobCommitment: BytesLike,
    kzgProof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  proveValidity(
    payoutRecipient: string,
    l1HeadSource: string,
    childIndex: BigNumberish,
    encodedSeal: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  prover(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  pruneChildren(
    stepLimit: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  removeVanguard(
    _vanguard: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  resolve(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

  rootClaim(overrides?: CallOverrides): Promise<string>;

  setParticipationBond(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  signature(overrides?: CallOverrides): Promise<string>;

  status(overrides?: CallOverrides): Promise<number>;

  treasuryAddress(overrides?: CallOverrides): Promise<string>;

  updateLastResolved(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  validChildSignature(overrides?: CallOverrides): Promise<string>;

  vanguards(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  verifyIntermediateOutput(
    arg0: BigNumberish,
    arg1: BigNumberish,
    arg2: BytesLike,
    arg3: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  version(overrides?: CallOverrides): Promise<string>;

  wasRespectedGameTypeWhenCreated(overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<string>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<string>;

    GAME_TYPE(overrides?: CallOverrides): Promise<number>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<string>;

    L2_BLOCK_NUMBER(overrides?: CallOverrides): Promise<BigNumber>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<string>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<string>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<string>;

    ROOT_CLAIM(overrides?: CallOverrides): Promise<string>;

    appendChild(overrides?: CallOverrides): Promise<void>;

    assignVanguard(_vanguard: string, overrides?: CallOverrides): Promise<void>;

    blobsHash(overrides?: CallOverrides): Promise<string>;

    childCount(overrides?: CallOverrides): Promise<BigNumber>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    claimEliminationBonds(
      claims: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    claimProposerBond(overrides?: CallOverrides): Promise<void>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

    createdAt(overrides?: CallOverrides): Promise<BigNumber>;

    eliminate(
      _child: string,
      prover: string,
      overrides?: CallOverrides
    ): Promise<void>;

    eliminationRound(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eliminations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    eliminationsPaid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    extraData(overrides?: CallOverrides): Promise<string>;

    gameCreator(overrides?: CallOverrides): Promise<string>;

    gameData(
      overrides?: CallOverrides
    ): Promise<
      [number, string, string] & {
        gameType_: number;
        rootClaim_: string;
        extraData_: string;
      }
    >;

    gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    gameType(overrides?: CallOverrides): Promise<number>;

    getChallengerDuration(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(overrides?: CallOverrides): Promise<void>;

    isProposing(overrides?: CallOverrides): Promise<boolean>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    l1Head(overrides?: CallOverrides): Promise<string>;

    l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    lastProposal(arg0: string, overrides?: CallOverrides): Promise<string>;

    lastResolved(overrides?: CallOverrides): Promise<string>;

    opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

    paidBonds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    parentGame(overrides?: CallOverrides): Promise<string>;

    participationBond(overrides?: CallOverrides): Promise<BigNumber>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<number>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    propose(
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    proposer(overrides?: CallOverrides): Promise<string>;

    proposerOf(arg0: string, overrides?: CallOverrides): Promise<string>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: CallOverrides
    ): Promise<void>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    removeVanguard(_vanguard: string, overrides?: CallOverrides): Promise<void>;

    resolve(overrides?: CallOverrides): Promise<number>;

    resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

    rootClaim(overrides?: CallOverrides): Promise<string>;

    setParticipationBond(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    signature(overrides?: CallOverrides): Promise<string>;

    status(overrides?: CallOverrides): Promise<number>;

    treasuryAddress(overrides?: CallOverrides): Promise<string>;

    updateLastResolved(overrides?: CallOverrides): Promise<void>;

    validChildSignature(overrides?: CallOverrides): Promise<string>;

    vanguards(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    verifyIntermediateOutput(
      arg0: BigNumberish,
      arg1: BigNumberish,
      arg2: BytesLike,
      arg3: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    version(overrides?: CallOverrides): Promise<string>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "BondUpdated(uint256)"(amount?: null): BondUpdatedEventFilter;
    BondUpdated(amount?: null): BondUpdatedEventFilter;

    "Proven(bytes32,uint8)"(
      signature?: BytesLike | null,
      status?: BigNumberish | null
    ): ProvenEventFilter;
    Proven(
      signature?: BytesLike | null,
      status?: BigNumberish | null
    ): ProvenEventFilter;

    "Resolved(uint8)"(status?: BigNumberish | null): ResolvedEventFilter;
    Resolved(status?: BigNumberish | null): ResolvedEventFilter;

    "VanguardAdded(address)"(
      vanguard?: string | null
    ): VanguardAddedEventFilter;
    VanguardAdded(vanguard?: string | null): VanguardAddedEventFilter;

    "VanguardRemoved(address)"(
      vanguard?: string | null
    ): VanguardRemovedEventFilter;
    VanguardRemoved(vanguard?: string | null): VanguardRemovedEventFilter;
  };

  estimateGas: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<BigNumber>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<BigNumber>;

    GAME_TYPE(overrides?: CallOverrides): Promise<BigNumber>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<BigNumber>;

    L2_BLOCK_NUMBER(overrides?: CallOverrides): Promise<BigNumber>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<BigNumber>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<BigNumber>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    ROOT_CLAIM(overrides?: CallOverrides): Promise<BigNumber>;

    appendChild(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    assignVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    blobsHash(overrides?: CallOverrides): Promise<BigNumber>;

    childCount(overrides?: CallOverrides): Promise<BigNumber>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    claimEliminationBonds(
      claims: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    claimProposerBond(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

    createdAt(overrides?: CallOverrides): Promise<BigNumber>;

    eliminate(
      _child: string,
      prover: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    eliminationRound(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eliminations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eliminationsPaid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    extraData(overrides?: CallOverrides): Promise<BigNumber>;

    gameCreator(overrides?: CallOverrides): Promise<BigNumber>;

    gameData(overrides?: CallOverrides): Promise<BigNumber>;

    gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    gameType(overrides?: CallOverrides): Promise<BigNumber>;

    getChallengerDuration(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    isProposing(overrides?: CallOverrides): Promise<BigNumber>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    l1Head(overrides?: CallOverrides): Promise<BigNumber>;

    l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    lastProposal(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    lastResolved(overrides?: CallOverrides): Promise<BigNumber>;

    opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

    paidBonds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    parentGame(overrides?: CallOverrides): Promise<BigNumber>;

    participationBond(overrides?: CallOverrides): Promise<BigNumber>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    propose(
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    proposer(overrides?: CallOverrides): Promise<BigNumber>;

    proposerOf(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    removeVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    resolve(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

    rootClaim(overrides?: CallOverrides): Promise<BigNumber>;

    setParticipationBond(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    signature(overrides?: CallOverrides): Promise<BigNumber>;

    status(overrides?: CallOverrides): Promise<BigNumber>;

    treasuryAddress(overrides?: CallOverrides): Promise<BigNumber>;

    updateLastResolved(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    validChildSignature(overrides?: CallOverrides): Promise<BigNumber>;

    vanguards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    verifyIntermediateOutput(
      arg0: BigNumberish,
      arg1: BigNumberish,
      arg2: BytesLike,
      arg3: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DISPUTE_GAME_FACTORY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    GAME_TYPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    L2_BLOCK_NUMBER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_OUTPUT_COUNT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    RISC_ZERO_VERIFIER(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ROLLUP_CONFIG_HASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ROOT_CLAIM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    appendChild(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    assignVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    blobsHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    childCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    children(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimEliminationBonds(
      claims: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    claimProposerBond(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contenderIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createdAt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eliminate(
      _child: string,
      prover: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    eliminationRound(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eliminations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eliminationsPaid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    extraData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameCreator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getChallengerDuration(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isProposing(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    l1Head(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    l2BlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastProposal(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastResolved(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    opponentIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paidBonds(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    parentGame(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    participationBond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proofStatus(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    propose(
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proposer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposerOf(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    provenAt(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    prover(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    removeVanguard(
      _vanguard: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    resolve(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    resolvedAt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rootClaim(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setParticipationBond(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    signature(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    status(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    treasuryAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateLastResolved(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    validChildSignature(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    vanguards(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyIntermediateOutput(
      arg0: BigNumberish,
      arg1: BigNumberish,
      arg2: BytesLike,
      arg3: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
