/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type OutputRootStruct = { root: BytesLike; l2BlockNumber: BigNumberish };

export type OutputRootStructOutput = [string, BigNumber] & {
  root: string;
  l2BlockNumber: BigNumber;
};

export declare namespace AnchorStateRegistry {
  export type StartingAnchorRootStruct = {
    gameType: BigNumberish;
    outputRoot: OutputRootStruct;
  };

  export type StartingAnchorRootStructOutput = [
    number,
    OutputRootStructOutput
  ] & { gameType: number; outputRoot: OutputRootStructOutput };
}

export interface AnchorStateRegistryInterface extends utils.Interface {
  functions: {
    "anchors(uint32)": FunctionFragment;
    "disputeGameFactory()": FunctionFragment;
    "initialize((uint32,(bytes32,uint256))[],address)": FunctionFragment;
    "setAnchorState(address)": FunctionFragment;
    "superchainConfig()": FunctionFragment;
    "tryUpdateAnchorState()": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "anchors"
      | "disputeGameFactory"
      | "initialize"
      | "setAnchorState"
      | "superchainConfig"
      | "tryUpdateAnchorState"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "anchors",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeGameFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [AnchorStateRegistry.StartingAnchorRootStruct[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAnchorState",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "superchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tryUpdateAnchorState",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(functionFragment: "anchors", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "disputeGameFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAnchorState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "superchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tryUpdateAnchorState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "Initialized(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface AnchorStateRegistry extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AnchorStateRegistryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Returns the anchor state for the given game type.
     */
    anchors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { root: string; l2BlockNumber: BigNumber }
    >;

    /**
     * Returns the DisputeGameFactory address.
     */
    disputeGameFactory(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _startingAnchorRoots: AnchorStateRegistry.StartingAnchorRootStruct[],
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the anchor state given the game.
     * @param _game The game to set the anchor state for.
     */
    setAnchorState(
      _game: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Callable by FaultDisputeGame contracts to update the anchor state. Pulls the anchor state directly from         the FaultDisputeGame contract and stores it in the registry if the new anchor state is valid and the         state is newer than the current anchor state.
     */
    tryUpdateAnchorState(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Returns the anchor state for the given game type.
   */
  anchors(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { root: string; l2BlockNumber: BigNumber }>;

  /**
   * Returns the DisputeGameFactory address.
   */
  disputeGameFactory(overrides?: CallOverrides): Promise<string>;

  initialize(
    _startingAnchorRoots: AnchorStateRegistry.StartingAnchorRootStruct[],
    _superchainConfig: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the anchor state given the game.
   * @param _game The game to set the anchor state for.
   */
  setAnchorState(
    _game: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Address of the SuperchainConfig contract.
   */
  superchainConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Callable by FaultDisputeGame contracts to update the anchor state. Pulls the anchor state directly from         the FaultDisputeGame contract and stores it in the registry if the new anchor state is valid and the         state is newer than the current anchor state.
   */
  tryUpdateAnchorState(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Returns the anchor state for the given game type.
     */
    anchors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { root: string; l2BlockNumber: BigNumber }
    >;

    /**
     * Returns the DisputeGameFactory address.
     */
    disputeGameFactory(overrides?: CallOverrides): Promise<string>;

    initialize(
      _startingAnchorRoots: AnchorStateRegistry.StartingAnchorRootStruct[],
      _superchainConfig: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the anchor state given the game.
     * @param _game The game to set the anchor state for.
     */
    setAnchorState(_game: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Callable by FaultDisputeGame contracts to update the anchor state. Pulls the anchor state directly from         the FaultDisputeGame contract and stores it in the registry if the new anchor state is valid and the         state is newer than the current anchor state.
     */
    tryUpdateAnchorState(overrides?: CallOverrides): Promise<void>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;
  };

  estimateGas: {
    /**
     * Returns the anchor state for the given game type.
     */
    anchors(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the DisputeGameFactory address.
     */
    disputeGameFactory(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _startingAnchorRoots: AnchorStateRegistry.StartingAnchorRootStruct[],
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the anchor state given the game.
     * @param _game The game to set the anchor state for.
     */
    setAnchorState(
      _game: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Callable by FaultDisputeGame contracts to update the anchor state. Pulls the anchor state directly from         the FaultDisputeGame contract and stores it in the registry if the new anchor state is valid and the         state is newer than the current anchor state.
     */
    tryUpdateAnchorState(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Returns the anchor state for the given game type.
     */
    anchors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the DisputeGameFactory address.
     */
    disputeGameFactory(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _startingAnchorRoots: AnchorStateRegistry.StartingAnchorRootStruct[],
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the anchor state given the game.
     * @param _game The game to set the anchor state for.
     */
    setAnchorState(
      _game: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Callable by FaultDisputeGame contracts to update the anchor state. Pulls the anchor state directly from         the FaultDisputeGame contract and stores it in the registry if the new anchor state is valid and the         state is newer than the current anchor state.
     */
    tryUpdateAnchorState(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
