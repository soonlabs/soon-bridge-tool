/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface KailuaGameInterface extends utils.Interface {
  functions: {
    "DISPUTE_GAME_FACTORY()": FunctionFragment;
    "FPVM_IMAGE_ID()": FunctionFragment;
    "GAME_TYPE()": FunctionFragment;
    "GENESIS_TIME_STAMP()": FunctionFragment;
    "KAILUA_TREASURY()": FunctionFragment;
    "L2_BLOCK_TIME()": FunctionFragment;
    "MAX_CLOCK_DURATION()": FunctionFragment;
    "OPTIMISM_PORTAL()": FunctionFragment;
    "OUTPUT_BLOCK_SPAN()": FunctionFragment;
    "PROPOSAL_BLOBS()": FunctionFragment;
    "PROPOSAL_OUTPUT_COUNT()": FunctionFragment;
    "RISC_ZERO_VERIFIER()": FunctionFragment;
    "ROLLUP_CONFIG_HASH()": FunctionFragment;
    "appendChild()": FunctionFragment;
    "blobsHash()": FunctionFragment;
    "childCount()": FunctionFragment;
    "children(uint256)": FunctionFragment;
    "contenderDuplicates(uint256)": FunctionFragment;
    "contenderIndex()": FunctionFragment;
    "createdAt()": FunctionFragment;
    "duplicationCounter()": FunctionFragment;
    "extraData()": FunctionFragment;
    "gameCreator()": FunctionFragment;
    "gameData()": FunctionFragment;
    "gameIndex()": FunctionFragment;
    "gameType()": FunctionFragment;
    "getChallengerDuration(uint256)": FunctionFragment;
    "initialize()": FunctionFragment;
    "isViableSignature(bytes32)": FunctionFragment;
    "l1Head()": FunctionFragment;
    "l2BlockNumber()": FunctionFragment;
    "opponentIndex()": FunctionFragment;
    "parentGame()": FunctionFragment;
    "parentGameIndex()": FunctionFragment;
    "proofStatus(bytes32)": FunctionFragment;
    "proposalBlobHashes(uint256)": FunctionFragment;
    "proposer()": FunctionFragment;
    "proveOutputFault(address[2],uint64[2],bytes,bytes32[2],uint256,bytes[][2])": FunctionFragment;
    "proveTrailFault(address,uint64[2],uint256,bytes,bytes)": FunctionFragment;
    "proveValidity(address,address,uint64,bytes)": FunctionFragment;
    "provenAt(bytes32)": FunctionFragment;
    "prover(bytes32)": FunctionFragment;
    "pruneChildren(uint256)": FunctionFragment;
    "resolve()": FunctionFragment;
    "resolvedAt()": FunctionFragment;
    "rootClaim()": FunctionFragment;
    "signature()": FunctionFragment;
    "status()": FunctionFragment;
    "validChildSignature()": FunctionFragment;
    "verifyIntermediateOutput(uint64,uint256,bytes,bytes)": FunctionFragment;
    "version()": FunctionFragment;
    "wasRespectedGameTypeWhenCreated()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DISPUTE_GAME_FACTORY"
      | "FPVM_IMAGE_ID"
      | "GAME_TYPE"
      | "GENESIS_TIME_STAMP"
      | "KAILUA_TREASURY"
      | "L2_BLOCK_TIME"
      | "MAX_CLOCK_DURATION"
      | "OPTIMISM_PORTAL"
      | "OUTPUT_BLOCK_SPAN"
      | "PROPOSAL_BLOBS"
      | "PROPOSAL_OUTPUT_COUNT"
      | "RISC_ZERO_VERIFIER"
      | "ROLLUP_CONFIG_HASH"
      | "appendChild"
      | "blobsHash"
      | "childCount"
      | "children"
      | "contenderDuplicates"
      | "contenderIndex"
      | "createdAt"
      | "duplicationCounter"
      | "extraData"
      | "gameCreator"
      | "gameData"
      | "gameIndex"
      | "gameType"
      | "getChallengerDuration"
      | "initialize"
      | "isViableSignature"
      | "l1Head"
      | "l2BlockNumber"
      | "opponentIndex"
      | "parentGame"
      | "parentGameIndex"
      | "proofStatus"
      | "proposalBlobHashes"
      | "proposer"
      | "proveOutputFault"
      | "proveTrailFault"
      | "proveValidity"
      | "provenAt"
      | "prover"
      | "pruneChildren"
      | "resolve"
      | "resolvedAt"
      | "rootClaim"
      | "signature"
      | "status"
      | "validChildSignature"
      | "verifyIntermediateOutput"
      | "version"
      | "wasRespectedGameTypeWhenCreated"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DISPUTE_GAME_FACTORY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FPVM_IMAGE_ID",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "GAME_TYPE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "GENESIS_TIME_STAMP",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "KAILUA_TREASURY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "L2_BLOCK_TIME",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_CLOCK_DURATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OPTIMISM_PORTAL",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OUTPUT_BLOCK_SPAN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_BLOBS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_OUTPUT_COUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RISC_ZERO_VERIFIER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROLLUP_CONFIG_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appendChild",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "blobsHash", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "childCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "children",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contenderDuplicates",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contenderIndex",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "createdAt", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "duplicationCounter",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "extraData", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "gameCreator",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "gameData", values?: undefined): string;
  encodeFunctionData(functionFragment: "gameIndex", values?: undefined): string;
  encodeFunctionData(functionFragment: "gameType", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getChallengerDuration",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isViableSignature",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "l1Head", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "l2BlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "opponentIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "parentGame",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "parentGameIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proofStatus",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalBlobHashes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "proposer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proveOutputFault",
    values: [
      [string, string],
      [BigNumberish, BigNumberish],
      BytesLike,
      [BytesLike, BytesLike],
      BigNumberish,
      [BytesLike[], BytesLike[]]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "proveTrailFault",
    values: [
      string,
      [BigNumberish, BigNumberish],
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "proveValidity",
    values: [string, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "provenAt", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "prover", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "pruneChildren",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "resolve", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resolvedAt",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rootClaim", values?: undefined): string;
  encodeFunctionData(functionFragment: "signature", values?: undefined): string;
  encodeFunctionData(functionFragment: "status", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "validChildSignature",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "verifyIntermediateOutput",
    values: [BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "wasRespectedGameTypeWhenCreated",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "DISPUTE_GAME_FACTORY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FPVM_IMAGE_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "GAME_TYPE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "GENESIS_TIME_STAMP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "KAILUA_TREASURY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "L2_BLOCK_TIME",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_CLOCK_DURATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OPTIMISM_PORTAL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OUTPUT_BLOCK_SPAN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_BLOBS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_OUTPUT_COUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RISC_ZERO_VERIFIER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROLLUP_CONFIG_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appendChild",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "blobsHash", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "childCount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "children", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "contenderDuplicates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contenderIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "createdAt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "duplicationCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "extraData", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "gameCreator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gameData", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gameIndex", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gameType", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getChallengerDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isViableSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "l1Head", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "l2BlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "opponentIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "parentGame", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "parentGameIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proofStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalBlobHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proposer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proveOutputFault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveTrailFault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveValidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "provenAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "prover", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pruneChildren",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resolve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resolvedAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rootClaim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "signature", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "validChildSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyIntermediateOutput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "wasRespectedGameTypeWhenCreated",
    data: BytesLike
  ): Result;

  events: {
    "Proven(bytes32,uint8)": EventFragment;
    "Resolved(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Proven"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Resolved"): EventFragment;
}

export interface ProvenEventObject {
  signature: string;
  status: number;
}
export type ProvenEvent = TypedEvent<[string, number], ProvenEventObject>;

export type ProvenEventFilter = TypedEventFilter<ProvenEvent>;

export interface ResolvedEventObject {
  status: number;
}
export type ResolvedEvent = TypedEvent<[number], ResolvedEventObject>;

export type ResolvedEventFilter = TypedEventFilter<ResolvedEvent>;

export interface KailuaGame extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: KailuaGameInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<[string]>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<[string]>;

    GAME_TYPE(overrides?: CallOverrides): Promise<[number]>;

    GENESIS_TIME_STAMP(overrides?: CallOverrides): Promise<[BigNumber]>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<[string]>;

    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_CLOCK_DURATION(overrides?: CallOverrides): Promise<[BigNumber]>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<[string]>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<[string]>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<[string]>;

    appendChild(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    blobsHash(
      overrides?: CallOverrides
    ): Promise<[string] & { blobsHash_: string }>;

    childCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count_: BigNumber }>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    contenderIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    createdAt(overrides?: CallOverrides): Promise<[BigNumber]>;

    duplicationCounter(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { duplicationCounter_: BigNumber }>;

    extraData(
      overrides?: CallOverrides
    ): Promise<[string] & { extraData_: string }>;

    gameCreator(
      overrides?: CallOverrides
    ): Promise<[string] & { creator_: string }>;

    gameData(
      overrides?: CallOverrides
    ): Promise<
      [number, string, string] & {
        gameType_: number;
        rootClaim_: string;
        extraData_: string;
      }
    >;

    gameIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    gameType(
      overrides?: CallOverrides
    ): Promise<[number] & { gameType_: number }>;

    getChallengerDuration(
      asOfTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { duration_: BigNumber }>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isViableSignature_: boolean }>;

    l1Head(overrides?: CallOverrides): Promise<[string] & { l1Head_: string }>;

    l2BlockNumber(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { l2BlockNumber_: BigNumber }>;

    opponentIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    parentGame(
      overrides?: CallOverrides
    ): Promise<[string] & { parentGame_: string }>;

    parentGameIndex(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { parentGameIndex_: BigNumber }>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<[number]>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    proposer(
      overrides?: CallOverrides
    ): Promise<[string] & { proposer_: string }>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    resolve(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    resolvedAt(overrides?: CallOverrides): Promise<[BigNumber]>;

    rootClaim(
      overrides?: CallOverrides
    ): Promise<[string] & { rootClaim_: string }>;

    signature(
      overrides?: CallOverrides
    ): Promise<[string] & { signature_: string }>;

    status(overrides?: CallOverrides): Promise<[number]>;

    validChildSignature(overrides?: CallOverrides): Promise<[string]>;

    verifyIntermediateOutput(
      outputNumber: BigNumberish,
      outputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[string]>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<string>;

  FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<string>;

  GAME_TYPE(overrides?: CallOverrides): Promise<number>;

  GENESIS_TIME_STAMP(overrides?: CallOverrides): Promise<BigNumber>;

  KAILUA_TREASURY(overrides?: CallOverrides): Promise<string>;

  L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_CLOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

  OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<string>;

  OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

  RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<string>;

  ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<string>;

  appendChild(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  blobsHash(overrides?: CallOverrides): Promise<string>;

  childCount(overrides?: CallOverrides): Promise<BigNumber>;

  children(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  contenderDuplicates(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

  createdAt(overrides?: CallOverrides): Promise<BigNumber>;

  duplicationCounter(overrides?: CallOverrides): Promise<BigNumber>;

  extraData(overrides?: CallOverrides): Promise<string>;

  gameCreator(overrides?: CallOverrides): Promise<string>;

  gameData(
    overrides?: CallOverrides
  ): Promise<
    [number, string, string] & {
      gameType_: number;
      rootClaim_: string;
      extraData_: string;
    }
  >;

  gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

  gameType(overrides?: CallOverrides): Promise<number>;

  getChallengerDuration(
    asOfTimestamp: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  isViableSignature(
    childSignature: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  l1Head(overrides?: CallOverrides): Promise<string>;

  l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

  parentGame(overrides?: CallOverrides): Promise<string>;

  parentGameIndex(overrides?: CallOverrides): Promise<BigNumber>;

  proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<number>;

  proposalBlobHashes(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  proposer(overrides?: CallOverrides): Promise<string>;

  proveOutputFault(
    prHs: [string, string],
    co: [BigNumberish, BigNumberish],
    encodedSeal: BytesLike,
    ac: [BytesLike, BytesLike],
    proposedOutputFe: BigNumberish,
    kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  proveTrailFault(
    payoutRecipient: string,
    co: [BigNumberish, BigNumberish],
    proposedOutputFe: BigNumberish,
    blobCommitment: BytesLike,
    kzgProof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  proveValidity(
    payoutRecipient: string,
    l1HeadSource: string,
    childIndex: BigNumberish,
    encodedSeal: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  prover(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  pruneChildren(
    stepLimit: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  resolve(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

  rootClaim(overrides?: CallOverrides): Promise<string>;

  signature(overrides?: CallOverrides): Promise<string>;

  status(overrides?: CallOverrides): Promise<number>;

  validChildSignature(overrides?: CallOverrides): Promise<string>;

  verifyIntermediateOutput(
    outputNumber: BigNumberish,
    outputFe: BigNumberish,
    blobCommitment: BytesLike,
    kzgProof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<string>;

  wasRespectedGameTypeWhenCreated(overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<string>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<string>;

    GAME_TYPE(overrides?: CallOverrides): Promise<number>;

    GENESIS_TIME_STAMP(overrides?: CallOverrides): Promise<BigNumber>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<string>;

    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_CLOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<string>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<string>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<string>;

    appendChild(overrides?: CallOverrides): Promise<void>;

    blobsHash(overrides?: CallOverrides): Promise<string>;

    childCount(overrides?: CallOverrides): Promise<BigNumber>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

    createdAt(overrides?: CallOverrides): Promise<BigNumber>;

    duplicationCounter(overrides?: CallOverrides): Promise<BigNumber>;

    extraData(overrides?: CallOverrides): Promise<string>;

    gameCreator(overrides?: CallOverrides): Promise<string>;

    gameData(
      overrides?: CallOverrides
    ): Promise<
      [number, string, string] & {
        gameType_: number;
        rootClaim_: string;
        extraData_: string;
      }
    >;

    gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    gameType(overrides?: CallOverrides): Promise<number>;

    getChallengerDuration(
      asOfTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(overrides?: CallOverrides): Promise<void>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    l1Head(overrides?: CallOverrides): Promise<string>;

    l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

    parentGame(overrides?: CallOverrides): Promise<string>;

    parentGameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<number>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    proposer(overrides?: CallOverrides): Promise<string>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: CallOverrides
    ): Promise<void>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    resolve(overrides?: CallOverrides): Promise<number>;

    resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

    rootClaim(overrides?: CallOverrides): Promise<string>;

    signature(overrides?: CallOverrides): Promise<string>;

    status(overrides?: CallOverrides): Promise<number>;

    validChildSignature(overrides?: CallOverrides): Promise<string>;

    verifyIntermediateOutput(
      outputNumber: BigNumberish,
      outputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    version(overrides?: CallOverrides): Promise<string>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "Proven(bytes32,uint8)"(
      signature?: BytesLike | null,
      status?: BigNumberish | null
    ): ProvenEventFilter;
    Proven(
      signature?: BytesLike | null,
      status?: BigNumberish | null
    ): ProvenEventFilter;

    "Resolved(uint8)"(status?: BigNumberish | null): ResolvedEventFilter;
    Resolved(status?: BigNumberish | null): ResolvedEventFilter;
  };

  estimateGas: {
    DISPUTE_GAME_FACTORY(overrides?: CallOverrides): Promise<BigNumber>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<BigNumber>;

    GAME_TYPE(overrides?: CallOverrides): Promise<BigNumber>;

    GENESIS_TIME_STAMP(overrides?: CallOverrides): Promise<BigNumber>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<BigNumber>;

    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_CLOCK_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<BigNumber>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_OUTPUT_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    RISC_ZERO_VERIFIER(overrides?: CallOverrides): Promise<BigNumber>;

    ROLLUP_CONFIG_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    appendChild(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    blobsHash(overrides?: CallOverrides): Promise<BigNumber>;

    childCount(overrides?: CallOverrides): Promise<BigNumber>;

    children(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contenderIndex(overrides?: CallOverrides): Promise<BigNumber>;

    createdAt(overrides?: CallOverrides): Promise<BigNumber>;

    duplicationCounter(overrides?: CallOverrides): Promise<BigNumber>;

    extraData(overrides?: CallOverrides): Promise<BigNumber>;

    gameCreator(overrides?: CallOverrides): Promise<BigNumber>;

    gameData(overrides?: CallOverrides): Promise<BigNumber>;

    gameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    gameType(overrides?: CallOverrides): Promise<BigNumber>;

    getChallengerDuration(
      asOfTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    l1Head(overrides?: CallOverrides): Promise<BigNumber>;

    l2BlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    opponentIndex(overrides?: CallOverrides): Promise<BigNumber>;

    parentGame(overrides?: CallOverrides): Promise<BigNumber>;

    parentGameIndex(overrides?: CallOverrides): Promise<BigNumber>;

    proofStatus(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposer(overrides?: CallOverrides): Promise<BigNumber>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    provenAt(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    prover(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    resolve(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    resolvedAt(overrides?: CallOverrides): Promise<BigNumber>;

    rootClaim(overrides?: CallOverrides): Promise<BigNumber>;

    signature(overrides?: CallOverrides): Promise<BigNumber>;

    status(overrides?: CallOverrides): Promise<BigNumber>;

    validChildSignature(overrides?: CallOverrides): Promise<BigNumber>;

    verifyIntermediateOutput(
      outputNumber: BigNumberish,
      outputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DISPUTE_GAME_FACTORY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    FPVM_IMAGE_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    GAME_TYPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    GENESIS_TIME_STAMP(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    KAILUA_TREASURY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_CLOCK_DURATION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    OPTIMISM_PORTAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OUTPUT_BLOCK_SPAN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_BLOBS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_OUTPUT_COUNT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    RISC_ZERO_VERIFIER(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ROLLUP_CONFIG_HASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    appendChild(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    blobsHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    childCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    children(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contenderDuplicates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contenderIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createdAt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    duplicationCounter(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    extraData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameCreator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getChallengerDuration(
      asOfTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isViableSignature(
      childSignature: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    l1Head(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    l2BlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    opponentIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    parentGame(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    parentGameIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proofStatus(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposalBlobHashes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proveOutputFault(
      prHs: [string, string],
      co: [BigNumberish, BigNumberish],
      encodedSeal: BytesLike,
      ac: [BytesLike, BytesLike],
      proposedOutputFe: BigNumberish,
      kzgCommitmentsProofs: [BytesLike[], BytesLike[]],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proveTrailFault(
      payoutRecipient: string,
      co: [BigNumberish, BigNumberish],
      proposedOutputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proveValidity(
      payoutRecipient: string,
      l1HeadSource: string,
      childIndex: BigNumberish,
      encodedSeal: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    provenAt(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    prover(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pruneChildren(
      stepLimit: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    resolve(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    resolvedAt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rootClaim(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    signature(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    status(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validChildSignature(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyIntermediateOutput(
      outputNumber: BigNumberish,
      outputFe: BigNumberish,
      blobCommitment: BytesLike,
      kzgProof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wasRespectedGameTypeWhenCreated(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
