/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type ChallengeStruct = {
  challenger: string;
  lockedBond: BigNumberish;
  startBlock: BigNumberish;
  resolvedBlock: BigNumberish;
};

export type ChallengeStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  challenger: string;
  lockedBond: BigNumber;
  startBlock: BigNumber;
  resolvedBlock: BigNumber;
};

export interface DataAvailabilityChallengeInterface extends utils.Interface {
  functions: {
    "balances(address)": FunctionFragment;
    "bondSize()": FunctionFragment;
    "challenge(uint256,bytes)": FunctionFragment;
    "challengeWindow()": FunctionFragment;
    "deposit()": FunctionFragment;
    "fixedResolutionCost()": FunctionFragment;
    "getChallenge(uint256,bytes)": FunctionFragment;
    "getChallengeStatus(uint256,bytes)": FunctionFragment;
    "initialize(address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "resolve(uint256,bytes,bytes)": FunctionFragment;
    "resolveWindow()": FunctionFragment;
    "resolverRefundPercentage()": FunctionFragment;
    "setBondSize(uint256)": FunctionFragment;
    "setResolverRefundPercentage(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unlockBond(uint256,bytes)": FunctionFragment;
    "validateCommitment(bytes)": FunctionFragment;
    "variableResolutionCost()": FunctionFragment;
    "variableResolutionCostPrecision()": FunctionFragment;
    "version()": FunctionFragment;
    "withdraw()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "balances"
      | "bondSize"
      | "challenge"
      | "challengeWindow"
      | "deposit"
      | "fixedResolutionCost"
      | "getChallenge"
      | "getChallengeStatus"
      | "initialize"
      | "owner"
      | "renounceOwnership"
      | "resolve"
      | "resolveWindow"
      | "resolverRefundPercentage"
      | "setBondSize"
      | "setResolverRefundPercentage"
      | "transferOwnership"
      | "unlockBond"
      | "validateCommitment"
      | "variableResolutionCost"
      | "variableResolutionCostPrecision"
      | "version"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "balances", values: [string]): string;
  encodeFunctionData(functionFragment: "bondSize", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "challenge",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "challengeWindow",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "deposit", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "fixedResolutionCost",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getChallenge",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getChallengeStatus",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resolve",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "resolveWindow",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resolverRefundPercentage",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setBondSize",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setResolverRefundPercentage",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockBond",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validateCommitment",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "variableResolutionCost",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "variableResolutionCostPrecision",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;

  decodeFunctionResult(functionFragment: "balances", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bondSize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "challenge", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "challengeWindow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fixedResolutionCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChallengeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resolve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resolveWindow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolverRefundPercentage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBondSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setResolverRefundPercentage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unlockBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "validateCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "variableResolutionCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "variableResolutionCostPrecision",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "BalanceChanged(address,uint256)": EventFragment;
    "ChallengeStatusChanged(uint256,bytes,uint8)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RequiredBondSizeChanged(uint256)": EventFragment;
    "ResolverRefundPercentageChanged(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BalanceChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChallengeStatusChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequiredBondSizeChanged"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ResolverRefundPercentageChanged"
  ): EventFragment;
}

export interface BalanceChangedEventObject {
  account: string;
  balance: BigNumber;
}
export type BalanceChangedEvent = TypedEvent<
  [string, BigNumber],
  BalanceChangedEventObject
>;

export type BalanceChangedEventFilter = TypedEventFilter<BalanceChangedEvent>;

export interface ChallengeStatusChangedEventObject {
  challengedBlockNumber: BigNumber;
  challengedCommitment: string;
  status: number;
}
export type ChallengeStatusChangedEvent = TypedEvent<
  [BigNumber, string, number],
  ChallengeStatusChangedEventObject
>;

export type ChallengeStatusChangedEventFilter =
  TypedEventFilter<ChallengeStatusChangedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface RequiredBondSizeChangedEventObject {
  challengeWindow: BigNumber;
}
export type RequiredBondSizeChangedEvent = TypedEvent<
  [BigNumber],
  RequiredBondSizeChangedEventObject
>;

export type RequiredBondSizeChangedEventFilter =
  TypedEventFilter<RequiredBondSizeChangedEvent>;

export interface ResolverRefundPercentageChangedEventObject {
  resolverRefundPercentage: BigNumber;
}
export type ResolverRefundPercentageChangedEvent = TypedEvent<
  [BigNumber],
  ResolverRefundPercentageChangedEventObject
>;

export type ResolverRefundPercentageChangedEventFilter =
  TypedEventFilter<ResolverRefundPercentageChangedEvent>;

export interface DataAvailabilityChallenge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DataAvailabilityChallengeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * A mapping from addresses to their bond balance in the contract.
     */
    balances(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The amount required to post a challenge.
     */
    bondSize(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The block number parameter is necessary for the contract to verify the challenge window,      since the contract cannot access the block number of the commitment.      The function reverts if the commitment type (first byte) is unknown,      if the caller does not have a bond or if the challenge already exists.
     * Challenge a commitment at a given block number.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    challenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The block interval during which a commitment can be challenged.
     */
    challengeWindow(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Post a bond as prerequisite for challenging a commitment.
     */
    deposit(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The fixed cost of resolving a challenge.
     */
    fixedResolutionCost(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Unlike with a public `challenges` mapping, we can return a Challenge struct instead of tuple.
     * Returns a challenge for the given block number and commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<[ChallengeStructOutput]>;

    /**
     * Returns the status of a challenge for a given challenged block number and challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallengeStatus(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * Initializes the contract.
     * @param _bondSize The amount required to post a challenge.
     * @param _challengeWindow The block interval during which a commitment can be challenged.
     * @param _owner The owner of the contract.
     * @param _resolveWindow The block interval during which a challenge can be resolved.
     */
    initialize(
      _owner: string,
      _challengeWindow: BigNumberish,
      _resolveWindow: BigNumberish,
      _bondSize: BigNumberish,
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The function computes a commitment from the provided resolveData and verifies that it matches the challenged commitment.      It reverts if the commitment type is unknown, if the data doesn't match the commitment,      if the challenge is not active or if the resolve window is not open.
     * Resolve a challenge by providing the data corresponding to the challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The challenged commitment that is being resolved.
     * @param resolveData The pre-image data corresponding to the challenged commitment.
     */
    resolve(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      resolveData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The block interval during which a challenge can be resolved.
     */
    resolveWindow(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The percentage of the resolving cost to be refunded to the resolver.
     */
    resolverRefundPercentage(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Sets the bond size.
     * @param _bondSize The amount required to post a challenge.
     */
    setBondSize(
      _bondSize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The function reverts if the provided percentage is above 100, since the refund logic assumes a value smaller or equal to 100%.
     * Sets the percentage of the resolving cost to be refunded to the resolver.
     * @param _resolverRefundPercentage The percentage of the resolving cost to be refunded to the resolver.
     */
    setResolverRefundPercentage(
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The function reverts if the challenge is not expired.      If the expiration is successful, the challenger's bond is unlocked.
     * Unlock the bond associated wth an expired challenge.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    unlockBond(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The type of a commitment is stored in its first byte.      The function reverts with `UnknownCommitmentType` if the type is not known and      with `InvalidCommitmentLength` if the commitment has an unexpected length.
     * Validate that a given commitment has a known type and the expected length for this type.
     * @param commitment The commitment for which to check the type.
     */
    validateCommitment(
      commitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * The variable cost of resolving a callenge per byte scaled by the variableResolutionCostPrecision.
     */
    variableResolutionCost(overrides?: CallOverrides): Promise<[BigNumber]>;

    variableResolutionCostPrecision(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Withdraw a user's unlocked bond.
     */
    withdraw(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  /**
   * A mapping from addresses to their bond balance in the contract.
   */
  balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The amount required to post a challenge.
   */
  bondSize(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The block number parameter is necessary for the contract to verify the challenge window,      since the contract cannot access the block number of the commitment.      The function reverts if the commitment type (first byte) is unknown,      if the caller does not have a bond or if the challenge already exists.
   * Challenge a commitment at a given block number.
   * @param challengedBlockNumber The block number at which the commitment was made.
   * @param challengedCommitment The commitment that is being challenged.
   */
  challenge(
    challengedBlockNumber: BigNumberish,
    challengedCommitment: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The block interval during which a commitment can be challenged.
   */
  challengeWindow(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Post a bond as prerequisite for challenging a commitment.
   */
  deposit(
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The fixed cost of resolving a challenge.
   */
  fixedResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Unlike with a public `challenges` mapping, we can return a Challenge struct instead of tuple.
   * Returns a challenge for the given block number and commitment.
   * @param challengedBlockNumber The block number at which the commitment was made.
   * @param challengedCommitment The commitment that is being challenged.
   */
  getChallenge(
    challengedBlockNumber: BigNumberish,
    challengedCommitment: BytesLike,
    overrides?: CallOverrides
  ): Promise<ChallengeStructOutput>;

  /**
   * Returns the status of a challenge for a given challenged block number and challenged commitment.
   * @param challengedBlockNumber The block number at which the commitment was made.
   * @param challengedCommitment The commitment that is being challenged.
   */
  getChallengeStatus(
    challengedBlockNumber: BigNumberish,
    challengedCommitment: BytesLike,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * Initializes the contract.
   * @param _bondSize The amount required to post a challenge.
   * @param _challengeWindow The block interval during which a commitment can be challenged.
   * @param _owner The owner of the contract.
   * @param _resolveWindow The block interval during which a challenge can be resolved.
   */
  initialize(
    _owner: string,
    _challengeWindow: BigNumberish,
    _resolveWindow: BigNumberish,
    _bondSize: BigNumberish,
    _resolverRefundPercentage: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The function computes a commitment from the provided resolveData and verifies that it matches the challenged commitment.      It reverts if the commitment type is unknown, if the data doesn't match the commitment,      if the challenge is not active or if the resolve window is not open.
   * Resolve a challenge by providing the data corresponding to the challenged commitment.
   * @param challengedBlockNumber The block number at which the commitment was made.
   * @param challengedCommitment The challenged commitment that is being resolved.
   * @param resolveData The pre-image data corresponding to the challenged commitment.
   */
  resolve(
    challengedBlockNumber: BigNumberish,
    challengedCommitment: BytesLike,
    resolveData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The block interval during which a challenge can be resolved.
   */
  resolveWindow(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The percentage of the resolving cost to be refunded to the resolver.
   */
  resolverRefundPercentage(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Sets the bond size.
   * @param _bondSize The amount required to post a challenge.
   */
  setBondSize(
    _bondSize: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The function reverts if the provided percentage is above 100, since the refund logic assumes a value smaller or equal to 100%.
   * Sets the percentage of the resolving cost to be refunded to the resolver.
   * @param _resolverRefundPercentage The percentage of the resolving cost to be refunded to the resolver.
   */
  setResolverRefundPercentage(
    _resolverRefundPercentage: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The function reverts if the challenge is not expired.      If the expiration is successful, the challenger's bond is unlocked.
   * Unlock the bond associated wth an expired challenge.
   * @param challengedBlockNumber The block number at which the commitment was made.
   * @param challengedCommitment The commitment that is being challenged.
   */
  unlockBond(
    challengedBlockNumber: BigNumberish,
    challengedCommitment: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The type of a commitment is stored in its first byte.      The function reverts with `UnknownCommitmentType` if the type is not known and      with `InvalidCommitmentLength` if the commitment has an unexpected length.
   * Validate that a given commitment has a known type and the expected length for this type.
   * @param commitment The commitment for which to check the type.
   */
  validateCommitment(
    commitment: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * The variable cost of resolving a callenge per byte scaled by the variableResolutionCostPrecision.
   */
  variableResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

  variableResolutionCostPrecision(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  /**
   * Withdraw a user's unlocked bond.
   */
  withdraw(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * A mapping from addresses to their bond balance in the contract.
     */
    balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The amount required to post a challenge.
     */
    bondSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The block number parameter is necessary for the contract to verify the challenge window,      since the contract cannot access the block number of the commitment.      The function reverts if the commitment type (first byte) is unknown,      if the caller does not have a bond or if the challenge already exists.
     * Challenge a commitment at a given block number.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    challenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The block interval during which a commitment can be challenged.
     */
    challengeWindow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Post a bond as prerequisite for challenging a commitment.
     */
    deposit(overrides?: CallOverrides): Promise<void>;

    /**
     * The fixed cost of resolving a challenge.
     */
    fixedResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Unlike with a public `challenges` mapping, we can return a Challenge struct instead of tuple.
     * Returns a challenge for the given block number and commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<ChallengeStructOutput>;

    /**
     * Returns the status of a challenge for a given challenged block number and challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallengeStatus(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Initializes the contract.
     * @param _bondSize The amount required to post a challenge.
     * @param _challengeWindow The block interval during which a commitment can be challenged.
     * @param _owner The owner of the contract.
     * @param _resolveWindow The block interval during which a challenge can be resolved.
     */
    initialize(
      _owner: string,
      _challengeWindow: BigNumberish,
      _resolveWindow: BigNumberish,
      _bondSize: BigNumberish,
      _resolverRefundPercentage: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * The function computes a commitment from the provided resolveData and verifies that it matches the challenged commitment.      It reverts if the commitment type is unknown, if the data doesn't match the commitment,      if the challenge is not active or if the resolve window is not open.
     * Resolve a challenge by providing the data corresponding to the challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The challenged commitment that is being resolved.
     * @param resolveData The pre-image data corresponding to the challenged commitment.
     */
    resolve(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      resolveData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The block interval during which a challenge can be resolved.
     */
    resolveWindow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The percentage of the resolving cost to be refunded to the resolver.
     */
    resolverRefundPercentage(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets the bond size.
     * @param _bondSize The amount required to post a challenge.
     */
    setBondSize(
      _bondSize: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The function reverts if the provided percentage is above 100, since the refund logic assumes a value smaller or equal to 100%.
     * Sets the percentage of the resolving cost to be refunded to the resolver.
     * @param _resolverRefundPercentage The percentage of the resolving cost to be refunded to the resolver.
     */
    setResolverRefundPercentage(
      _resolverRefundPercentage: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The function reverts if the challenge is not expired.      If the expiration is successful, the challenger's bond is unlocked.
     * Unlock the bond associated wth an expired challenge.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    unlockBond(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The type of a commitment is stored in its first byte.      The function reverts with `UnknownCommitmentType` if the type is not known and      with `InvalidCommitmentLength` if the commitment has an unexpected length.
     * Validate that a given commitment has a known type and the expected length for this type.
     * @param commitment The commitment for which to check the type.
     */
    validateCommitment(
      commitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The variable cost of resolving a callenge per byte scaled by the variableResolutionCostPrecision.
     */
    variableResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

    variableResolutionCostPrecision(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;

    /**
     * Withdraw a user's unlocked bond.
     */
    withdraw(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "BalanceChanged(address,uint256)"(
      account?: null,
      balance?: null
    ): BalanceChangedEventFilter;
    BalanceChanged(account?: null, balance?: null): BalanceChangedEventFilter;

    "ChallengeStatusChanged(uint256,bytes,uint8)"(
      challengedBlockNumber?: BigNumberish | null,
      challengedCommitment?: null,
      status?: null
    ): ChallengeStatusChangedEventFilter;
    ChallengeStatusChanged(
      challengedBlockNumber?: BigNumberish | null,
      challengedCommitment?: null,
      status?: null
    ): ChallengeStatusChangedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "RequiredBondSizeChanged(uint256)"(
      challengeWindow?: null
    ): RequiredBondSizeChangedEventFilter;
    RequiredBondSizeChanged(
      challengeWindow?: null
    ): RequiredBondSizeChangedEventFilter;

    "ResolverRefundPercentageChanged(uint256)"(
      resolverRefundPercentage?: null
    ): ResolverRefundPercentageChangedEventFilter;
    ResolverRefundPercentageChanged(
      resolverRefundPercentage?: null
    ): ResolverRefundPercentageChangedEventFilter;
  };

  estimateGas: {
    /**
     * A mapping from addresses to their bond balance in the contract.
     */
    balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The amount required to post a challenge.
     */
    bondSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The block number parameter is necessary for the contract to verify the challenge window,      since the contract cannot access the block number of the commitment.      The function reverts if the commitment type (first byte) is unknown,      if the caller does not have a bond or if the challenge already exists.
     * Challenge a commitment at a given block number.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    challenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The block interval during which a commitment can be challenged.
     */
    challengeWindow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Post a bond as prerequisite for challenging a commitment.
     */
    deposit(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The fixed cost of resolving a challenge.
     */
    fixedResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Unlike with a public `challenges` mapping, we can return a Challenge struct instead of tuple.
     * Returns a challenge for the given block number and commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the status of a challenge for a given challenged block number and challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallengeStatus(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes the contract.
     * @param _bondSize The amount required to post a challenge.
     * @param _challengeWindow The block interval during which a commitment can be challenged.
     * @param _owner The owner of the contract.
     * @param _resolveWindow The block interval during which a challenge can be resolved.
     */
    initialize(
      _owner: string,
      _challengeWindow: BigNumberish,
      _resolveWindow: BigNumberish,
      _bondSize: BigNumberish,
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The function computes a commitment from the provided resolveData and verifies that it matches the challenged commitment.      It reverts if the commitment type is unknown, if the data doesn't match the commitment,      if the challenge is not active or if the resolve window is not open.
     * Resolve a challenge by providing the data corresponding to the challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The challenged commitment that is being resolved.
     * @param resolveData The pre-image data corresponding to the challenged commitment.
     */
    resolve(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      resolveData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The block interval during which a challenge can be resolved.
     */
    resolveWindow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The percentage of the resolving cost to be refunded to the resolver.
     */
    resolverRefundPercentage(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets the bond size.
     * @param _bondSize The amount required to post a challenge.
     */
    setBondSize(
      _bondSize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The function reverts if the provided percentage is above 100, since the refund logic assumes a value smaller or equal to 100%.
     * Sets the percentage of the resolving cost to be refunded to the resolver.
     * @param _resolverRefundPercentage The percentage of the resolving cost to be refunded to the resolver.
     */
    setResolverRefundPercentage(
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The function reverts if the challenge is not expired.      If the expiration is successful, the challenger's bond is unlocked.
     * Unlock the bond associated wth an expired challenge.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    unlockBond(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The type of a commitment is stored in its first byte.      The function reverts with `UnknownCommitmentType` if the type is not known and      with `InvalidCommitmentLength` if the commitment has an unexpected length.
     * Validate that a given commitment has a known type and the expected length for this type.
     * @param commitment The commitment for which to check the type.
     */
    validateCommitment(
      commitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The variable cost of resolving a callenge per byte scaled by the variableResolutionCostPrecision.
     */
    variableResolutionCost(overrides?: CallOverrides): Promise<BigNumber>;

    variableResolutionCostPrecision(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Withdraw a user's unlocked bond.
     */
    withdraw(overrides?: Overrides & { from?: string }): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * A mapping from addresses to their bond balance in the contract.
     */
    balances(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The amount required to post a challenge.
     */
    bondSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The block number parameter is necessary for the contract to verify the challenge window,      since the contract cannot access the block number of the commitment.      The function reverts if the commitment type (first byte) is unknown,      if the caller does not have a bond or if the challenge already exists.
     * Challenge a commitment at a given block number.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    challenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The block interval during which a commitment can be challenged.
     */
    challengeWindow(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Post a bond as prerequisite for challenging a commitment.
     */
    deposit(
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The fixed cost of resolving a challenge.
     */
    fixedResolutionCost(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Unlike with a public `challenges` mapping, we can return a Challenge struct instead of tuple.
     * Returns a challenge for the given block number and commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallenge(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the status of a challenge for a given challenged block number and challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    getChallengeStatus(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initializes the contract.
     * @param _bondSize The amount required to post a challenge.
     * @param _challengeWindow The block interval during which a commitment can be challenged.
     * @param _owner The owner of the contract.
     * @param _resolveWindow The block interval during which a challenge can be resolved.
     */
    initialize(
      _owner: string,
      _challengeWindow: BigNumberish,
      _resolveWindow: BigNumberish,
      _bondSize: BigNumberish,
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The function computes a commitment from the provided resolveData and verifies that it matches the challenged commitment.      It reverts if the commitment type is unknown, if the data doesn't match the commitment,      if the challenge is not active or if the resolve window is not open.
     * Resolve a challenge by providing the data corresponding to the challenged commitment.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The challenged commitment that is being resolved.
     * @param resolveData The pre-image data corresponding to the challenged commitment.
     */
    resolve(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      resolveData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The block interval during which a challenge can be resolved.
     */
    resolveWindow(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The percentage of the resolving cost to be refunded to the resolver.
     */
    resolverRefundPercentage(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the bond size.
     * @param _bondSize The amount required to post a challenge.
     */
    setBondSize(
      _bondSize: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The function reverts if the provided percentage is above 100, since the refund logic assumes a value smaller or equal to 100%.
     * Sets the percentage of the resolving cost to be refunded to the resolver.
     * @param _resolverRefundPercentage The percentage of the resolving cost to be refunded to the resolver.
     */
    setResolverRefundPercentage(
      _resolverRefundPercentage: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The function reverts if the challenge is not expired.      If the expiration is successful, the challenger's bond is unlocked.
     * Unlock the bond associated wth an expired challenge.
     * @param challengedBlockNumber The block number at which the commitment was made.
     * @param challengedCommitment The commitment that is being challenged.
     */
    unlockBond(
      challengedBlockNumber: BigNumberish,
      challengedCommitment: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The type of a commitment is stored in its first byte.      The function reverts with `UnknownCommitmentType` if the type is not known and      with `InvalidCommitmentLength` if the commitment has an unexpected length.
     * Validate that a given commitment has a known type and the expected length for this type.
     * @param commitment The commitment for which to check the type.
     */
    validateCommitment(
      commitment: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The variable cost of resolving a callenge per byte scaled by the variableResolutionCostPrecision.
     */
    variableResolutionCost(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    variableResolutionCostPrecision(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Withdraw a user's unlocked bond.
     */
    withdraw(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
