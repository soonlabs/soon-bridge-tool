/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace IDisputeGameFactory {
  export type GameSearchResultStruct = {
    index: BigNumberish;
    metadata: BytesLike;
    timestamp: BigNumberish;
    rootClaim: BytesLike;
    extraData: BytesLike;
  };

  export type GameSearchResultStructOutput = [
    BigNumber,
    string,
    BigNumber,
    string,
    string
  ] & {
    index: BigNumber;
    metadata: string;
    timestamp: BigNumber;
    rootClaim: string;
    extraData: string;
  };
}

export interface DisputeGameFactoryInterface extends utils.Interface {
  functions: {
    "create(uint32,bytes32,bytes)": FunctionFragment;
    "findLatestGames(uint32,uint256,uint256)": FunctionFragment;
    "gameAtIndex(uint256)": FunctionFragment;
    "gameCount()": FunctionFragment;
    "gameImpls(uint32)": FunctionFragment;
    "games(uint32,bytes32,bytes)": FunctionFragment;
    "getGameUUID(uint32,bytes32,bytes)": FunctionFragment;
    "initBonds(uint32)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "owner()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setImplementation(uint32,address)": FunctionFragment;
    "setInitBond(uint32,uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "create"
      | "findLatestGames"
      | "gameAtIndex"
      | "gameCount"
      | "gameImpls"
      | "games"
      | "getGameUUID"
      | "initBonds"
      | "initialize"
      | "owner"
      | "renounceOwnership"
      | "setImplementation"
      | "setInitBond"
      | "transferOwnership"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "create",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "findLatestGames",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "gameAtIndex",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "gameCount", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "gameImpls",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "games",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getGameUUID",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initBonds",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "initialize", values: [string]): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setImplementation",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setInitBond",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "findLatestGames",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "gameAtIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gameCount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gameImpls", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "games", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getGameUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initBonds", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setInitBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "DisputeGameCreated(address,uint32,bytes32)": EventFragment;
    "ImplementationSet(address,uint32)": EventFragment;
    "InitBondUpdated(uint32,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DisputeGameCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ImplementationSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InitBondUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface DisputeGameCreatedEventObject {
  disputeProxy: string;
  gameType: number;
  rootClaim: string;
}
export type DisputeGameCreatedEvent = TypedEvent<
  [string, number, string],
  DisputeGameCreatedEventObject
>;

export type DisputeGameCreatedEventFilter =
  TypedEventFilter<DisputeGameCreatedEvent>;

export interface ImplementationSetEventObject {
  impl: string;
  gameType: number;
}
export type ImplementationSetEvent = TypedEvent<
  [string, number],
  ImplementationSetEventObject
>;

export type ImplementationSetEventFilter =
  TypedEventFilter<ImplementationSetEvent>;

export interface InitBondUpdatedEventObject {
  gameType: number;
  newBond: BigNumber;
}
export type InitBondUpdatedEvent = TypedEvent<
  [number, BigNumber],
  InitBondUpdatedEventObject
>;

export type InitBondUpdatedEventFilter = TypedEventFilter<InitBondUpdatedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface DisputeGameFactory extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DisputeGameFactoryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Creates a new DisputeGame proxy contract.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    create(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Finds the `_n` most recent `GameId`'s of type `_gameType` starting at `_start`. If there are less than         `_n` games of type `_gameType` starting at `_start`, then the returned array will be shorter than `_n`.
     * @param _gameType The type of game to find.
     * @param _n The number of games to find.
     * @param _start The index to start the reverse search from.
     */
    findLatestGames(
      _gameType: BigNumberish,
      _start: BigNumberish,
      _n: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [IDisputeGameFactory.GameSearchResultStructOutput[]] & {
        games_: IDisputeGameFactory.GameSearchResultStructOutput[];
      }
    >;

    /**
     * `gameAtIndex` returns the dispute game contract address and its creation timestamp          at the given index. Each created dispute game increments the underlying index.
     * @param _index The index of the dispute game.
     */
    gameAtIndex(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        gameType_: number;
        timestamp_: BigNumber;
        proxy_: string;
      }
    >;

    /**
     * The total number of dispute games created by this factory.
     */
    gameCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { gameCount_: BigNumber }>;

    /**
     * `gameImpls` is a mapping that maps `GameType`s to their respective         `IDisputeGame` implementations.
     */
    gameImpls(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * `++` equates to concatenation.
     * `games` queries an internal mapping that maps the hash of         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation
     * @param _rootClaim The root claim of the DisputeGame.
     */
    games(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { proxy_: string; timestamp_: BigNumber }>;

    /**
     * Hashes the concatenation of `gameType . rootClaim . extraData`      without expanding memory.
     * Returns a unique identifier for the given dispute game parameters.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    getGameUUID(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { uuid_: string }>;

    /**
     * Returns the required bonds for initializing a dispute game of the given type.
     */
    initBonds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Initializes the contract.
     * @param _owner The owner of the contract.
     */
    initialize(
      _owner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * May only be called by the `owner`.
     * Sets the implementation contract for a specific `GameType`.
     * @param _gameType The type of the DisputeGame.
     * @param _impl The implementation contract for the given `GameType`.
     */
    setImplementation(
      _gameType: BigNumberish,
      _impl: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * May only be called by the `owner`.
     * Sets the bond (in wei) for initializing a game type.
     * @param _gameType The type of the DisputeGame.
     * @param _initBond The bond (in wei) for initializing a game type.
     */
    setInitBond(
      _gameType: BigNumberish,
      _initBond: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Creates a new DisputeGame proxy contract.
   * @param _extraData Any extra data that should be provided to the created dispute game.
   * @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
   * @param _rootClaim The root claim of the DisputeGame.
   */
  create(
    _gameType: BigNumberish,
    _rootClaim: BytesLike,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Finds the `_n` most recent `GameId`'s of type `_gameType` starting at `_start`. If there are less than         `_n` games of type `_gameType` starting at `_start`, then the returned array will be shorter than `_n`.
   * @param _gameType The type of game to find.
   * @param _n The number of games to find.
   * @param _start The index to start the reverse search from.
   */
  findLatestGames(
    _gameType: BigNumberish,
    _start: BigNumberish,
    _n: BigNumberish,
    overrides?: CallOverrides
  ): Promise<IDisputeGameFactory.GameSearchResultStructOutput[]>;

  /**
   * `gameAtIndex` returns the dispute game contract address and its creation timestamp          at the given index. Each created dispute game increments the underlying index.
   * @param _index The index of the dispute game.
   */
  gameAtIndex(
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, string] & {
      gameType_: number;
      timestamp_: BigNumber;
      proxy_: string;
    }
  >;

  /**
   * The total number of dispute games created by this factory.
   */
  gameCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * `gameImpls` is a mapping that maps `GameType`s to their respective         `IDisputeGame` implementations.
   */
  gameImpls(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * `++` equates to concatenation.
   * `games` queries an internal mapping that maps the hash of         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
   * @param _extraData Any extra data that should be provided to the created dispute game.
   * @param _gameType The type of the DisputeGame - used to decide the proxy implementation
   * @param _rootClaim The root claim of the DisputeGame.
   */
  games(
    _gameType: BigNumberish,
    _rootClaim: BytesLike,
    _extraData: BytesLike,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { proxy_: string; timestamp_: BigNumber }>;

  /**
   * Hashes the concatenation of `gameType . rootClaim . extraData`      without expanding memory.
   * Returns a unique identifier for the given dispute game parameters.
   * @param _extraData Any extra data that should be provided to the created dispute game.
   * @param _gameType The type of the DisputeGame.
   * @param _rootClaim The root claim of the DisputeGame.
   */
  getGameUUID(
    _gameType: BigNumberish,
    _rootClaim: BytesLike,
    _extraData: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns the required bonds for initializing a dispute game of the given type.
   */
  initBonds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Initializes the contract.
   * @param _owner The owner of the contract.
   */
  initialize(
    _owner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * May only be called by the `owner`.
   * Sets the implementation contract for a specific `GameType`.
   * @param _gameType The type of the DisputeGame.
   * @param _impl The implementation contract for the given `GameType`.
   */
  setImplementation(
    _gameType: BigNumberish,
    _impl: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * May only be called by the `owner`.
   * Sets the bond (in wei) for initializing a game type.
   * @param _gameType The type of the DisputeGame.
   * @param _initBond The bond (in wei) for initializing a game type.
   */
  setInitBond(
    _gameType: BigNumberish,
    _initBond: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Creates a new DisputeGame proxy contract.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    create(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Finds the `_n` most recent `GameId`'s of type `_gameType` starting at `_start`. If there are less than         `_n` games of type `_gameType` starting at `_start`, then the returned array will be shorter than `_n`.
     * @param _gameType The type of game to find.
     * @param _n The number of games to find.
     * @param _start The index to start the reverse search from.
     */
    findLatestGames(
      _gameType: BigNumberish,
      _start: BigNumberish,
      _n: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IDisputeGameFactory.GameSearchResultStructOutput[]>;

    /**
     * `gameAtIndex` returns the dispute game contract address and its creation timestamp          at the given index. Each created dispute game increments the underlying index.
     * @param _index The index of the dispute game.
     */
    gameAtIndex(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        gameType_: number;
        timestamp_: BigNumber;
        proxy_: string;
      }
    >;

    /**
     * The total number of dispute games created by this factory.
     */
    gameCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * `gameImpls` is a mapping that maps `GameType`s to their respective         `IDisputeGame` implementations.
     */
    gameImpls(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * `++` equates to concatenation.
     * `games` queries an internal mapping that maps the hash of         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation
     * @param _rootClaim The root claim of the DisputeGame.
     */
    games(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { proxy_: string; timestamp_: BigNumber }>;

    /**
     * Hashes the concatenation of `gameType . rootClaim . extraData`      without expanding memory.
     * Returns a unique identifier for the given dispute game parameters.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    getGameUUID(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the required bonds for initializing a dispute game of the given type.
     */
    initBonds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes the contract.
     * @param _owner The owner of the contract.
     */
    initialize(_owner: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * May only be called by the `owner`.
     * Sets the implementation contract for a specific `GameType`.
     * @param _gameType The type of the DisputeGame.
     * @param _impl The implementation contract for the given `GameType`.
     */
    setImplementation(
      _gameType: BigNumberish,
      _impl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * May only be called by the `owner`.
     * Sets the bond (in wei) for initializing a game type.
     * @param _gameType The type of the DisputeGame.
     * @param _initBond The bond (in wei) for initializing a game type.
     */
    setInitBond(
      _gameType: BigNumberish,
      _initBond: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "DisputeGameCreated(address,uint32,bytes32)"(
      disputeProxy?: string | null,
      gameType?: BigNumberish | null,
      rootClaim?: BytesLike | null
    ): DisputeGameCreatedEventFilter;
    DisputeGameCreated(
      disputeProxy?: string | null,
      gameType?: BigNumberish | null,
      rootClaim?: BytesLike | null
    ): DisputeGameCreatedEventFilter;

    "ImplementationSet(address,uint32)"(
      impl?: string | null,
      gameType?: BigNumberish | null
    ): ImplementationSetEventFilter;
    ImplementationSet(
      impl?: string | null,
      gameType?: BigNumberish | null
    ): ImplementationSetEventFilter;

    "InitBondUpdated(uint32,uint256)"(
      gameType?: BigNumberish | null,
      newBond?: BigNumberish | null
    ): InitBondUpdatedEventFilter;
    InitBondUpdated(
      gameType?: BigNumberish | null,
      newBond?: BigNumberish | null
    ): InitBondUpdatedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    /**
     * Creates a new DisputeGame proxy contract.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    create(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Finds the `_n` most recent `GameId`'s of type `_gameType` starting at `_start`. If there are less than         `_n` games of type `_gameType` starting at `_start`, then the returned array will be shorter than `_n`.
     * @param _gameType The type of game to find.
     * @param _n The number of games to find.
     * @param _start The index to start the reverse search from.
     */
    findLatestGames(
      _gameType: BigNumberish,
      _start: BigNumberish,
      _n: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * `gameAtIndex` returns the dispute game contract address and its creation timestamp          at the given index. Each created dispute game increments the underlying index.
     * @param _index The index of the dispute game.
     */
    gameAtIndex(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The total number of dispute games created by this factory.
     */
    gameCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * `gameImpls` is a mapping that maps `GameType`s to their respective         `IDisputeGame` implementations.
     */
    gameImpls(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * `++` equates to concatenation.
     * `games` queries an internal mapping that maps the hash of         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation
     * @param _rootClaim The root claim of the DisputeGame.
     */
    games(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Hashes the concatenation of `gameType . rootClaim . extraData`      without expanding memory.
     * Returns a unique identifier for the given dispute game parameters.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    getGameUUID(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the required bonds for initializing a dispute game of the given type.
     */
    initBonds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializes the contract.
     * @param _owner The owner of the contract.
     */
    initialize(
      _owner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * May only be called by the `owner`.
     * Sets the implementation contract for a specific `GameType`.
     * @param _gameType The type of the DisputeGame.
     * @param _impl The implementation contract for the given `GameType`.
     */
    setImplementation(
      _gameType: BigNumberish,
      _impl: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * May only be called by the `owner`.
     * Sets the bond (in wei) for initializing a game type.
     * @param _gameType The type of the DisputeGame.
     * @param _initBond The bond (in wei) for initializing a game type.
     */
    setInitBond(
      _gameType: BigNumberish,
      _initBond: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Creates a new DisputeGame proxy contract.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    create(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Finds the `_n` most recent `GameId`'s of type `_gameType` starting at `_start`. If there are less than         `_n` games of type `_gameType` starting at `_start`, then the returned array will be shorter than `_n`.
     * @param _gameType The type of game to find.
     * @param _n The number of games to find.
     * @param _start The index to start the reverse search from.
     */
    findLatestGames(
      _gameType: BigNumberish,
      _start: BigNumberish,
      _n: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * `gameAtIndex` returns the dispute game contract address and its creation timestamp          at the given index. Each created dispute game increments the underlying index.
     * @param _index The index of the dispute game.
     */
    gameAtIndex(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The total number of dispute games created by this factory.
     */
    gameCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * `gameImpls` is a mapping that maps `GameType`s to their respective         `IDisputeGame` implementations.
     */
    gameImpls(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * `++` equates to concatenation.
     * `games` queries an internal mapping that maps the hash of         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame - used to decide the proxy implementation
     * @param _rootClaim The root claim of the DisputeGame.
     */
    games(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Hashes the concatenation of `gameType . rootClaim . extraData`      without expanding memory.
     * Returns a unique identifier for the given dispute game parameters.
     * @param _extraData Any extra data that should be provided to the created dispute game.
     * @param _gameType The type of the DisputeGame.
     * @param _rootClaim The root claim of the DisputeGame.
     */
    getGameUUID(
      _gameType: BigNumberish,
      _rootClaim: BytesLike,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the required bonds for initializing a dispute game of the given type.
     */
    initBonds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initializes the contract.
     * @param _owner The owner of the contract.
     */
    initialize(
      _owner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * May only be called by the `owner`.
     * Sets the implementation contract for a specific `GameType`.
     * @param _gameType The type of the DisputeGame.
     * @param _impl The implementation contract for the given `GameType`.
     */
    setImplementation(
      _gameType: BigNumberish,
      _impl: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * May only be called by the `owner`.
     * Sets the bond (in wei) for initializing a game type.
     * @param _gameType The type of the DisputeGame.
     * @param _initBond The bond (in wei) for initializing a game type.
     */
    setInitBond(
      _gameType: BigNumberish,
      _initBond: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
