/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface L1ERC721BridgeInterface extends utils.Interface {
  functions: {
    "MESSENGER()": FunctionFragment;
    "OTHER_BRIDGE()": FunctionFragment;
    "bridgeERC721(address,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "bridgeERC721To(address,bytes32,bytes32,uint256,uint32,bytes)": FunctionFragment;
    "deposits(address,bytes32,uint256)": FunctionFragment;
    "encodeBridgeERC721L2Message(address,bytes32,address,bytes32,uint256,bytes)": FunctionFragment;
    "finalizeBridgeERC721(address,bytes32,bytes32,address,uint256,bytes)": FunctionFragment;
    "initialize(address,address)": FunctionFragment;
    "messenger()": FunctionFragment;
    "otherBridge()": FunctionFragment;
    "paused()": FunctionFragment;
    "superchainConfig()": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MESSENGER"
      | "OTHER_BRIDGE"
      | "bridgeERC721"
      | "bridgeERC721To"
      | "deposits"
      | "encodeBridgeERC721L2Message"
      | "finalizeBridgeERC721"
      | "initialize"
      | "messenger"
      | "otherBridge"
      | "paused"
      | "superchainConfig"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "MESSENGER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "OTHER_BRIDGE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC721",
    values: [string, BytesLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeERC721To",
    values: [
      string,
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposits",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeBridgeERC721L2Message",
    values: [string, BytesLike, string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeBridgeERC721",
    values: [string, BytesLike, BytesLike, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "messenger", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "otherBridge",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "superchainConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(functionFragment: "MESSENGER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "OTHER_BRIDGE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeERC721To",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposits", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "encodeBridgeERC721L2Message",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeBridgeERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "messenger", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "otherBridge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "superchainConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "ERC721BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)": EventFragment;
    "ERC721BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)": EventFragment;
    "Initialized(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ERC721BridgeFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ERC721BridgeInitiated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}

export interface ERC721BridgeFinalizedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  tokenId: BigNumber;
  extraData: string;
}
export type ERC721BridgeFinalizedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC721BridgeFinalizedEventObject
>;

export type ERC721BridgeFinalizedEventFilter =
  TypedEventFilter<ERC721BridgeFinalizedEvent>;

export interface ERC721BridgeInitiatedEventObject {
  localToken: string;
  remoteToken: string;
  from: string;
  to: string;
  tokenId: BigNumber;
  extraData: string;
}
export type ERC721BridgeInitiatedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  ERC721BridgeInitiatedEventObject
>;

export type ERC721BridgeInitiatedEventFilter =
  TypedEventFilter<ERC721BridgeInitiatedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface L1ERC721Bridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L1ERC721BridgeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token         by ID was deposited for a given L2 token.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Encode L2 message for bridge ERC721 from L1 to L2.
     * @param _extraData Optional data to forward to the other domain. Data supplied here will                     not be used to execute any code on the other domain and is only emitted                     as extra data for the convenience of off-chain tooling.
     * @param _from Address of the sender on this domain.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    encodeBridgeERC721L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Completes an ERC721 bridge from the other domain and sends the ERC721 token to the         recipient on this domain.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _from Address that triggered the bridge on the other domain.
     * @param _localToken Address of the ERC721 token on this domain.
     * @param _remoteToken Address of the ERC721 token on the other domain.
     * @param _to Address to receive the token on this domain.
     * @param _tokenId ID of the token being deposited.
     */
    finalizeBridgeERC721(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initializes the contract.
     * @param _messenger Contract of the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
   */
  MESSENGER(overrides?: CallOverrides): Promise<string>;

  /**
   * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
   */
  OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

  /**
   * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
   */
  bridgeERC721(
    arg0: string,
    arg1: BytesLike,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
   * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
   * @param _localToken Address of the ERC721 on this domain.
   * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
   * @param _remoteToken Address of the ERC721 on the remote domain.
   * @param _to Address to receive the token on the other domain.
   * @param _tokenId Token ID to bridge.
   */
  bridgeERC721To(
    _localToken: string,
    _remoteToken: BytesLike,
    _to: BytesLike,
    _tokenId: BigNumberish,
    _minGasLimit: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token         by ID was deposited for a given L2 token.
   */
  deposits(
    arg0: string,
    arg1: BytesLike,
    arg2: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Encode L2 message for bridge ERC721 from L1 to L2.
   * @param _extraData Optional data to forward to the other domain. Data supplied here will                     not be used to execute any code on the other domain and is only emitted                     as extra data for the convenience of off-chain tooling.
   * @param _from Address of the sender on this domain.
   * @param _localToken Address of the ERC721 on this domain.
   * @param _remoteToken Address of the ERC721 on the remote domain.
   * @param _to Address to receive the token on the other domain.
   * @param _tokenId Token ID to bridge.
   */
  encodeBridgeERC721L2Message(
    _localToken: string,
    _remoteToken: BytesLike,
    _from: string,
    _to: BytesLike,
    _tokenId: BigNumberish,
    _extraData: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Completes an ERC721 bridge from the other domain and sends the ERC721 token to the         recipient on this domain.
   * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
   * @param _from Address that triggered the bridge on the other domain.
   * @param _localToken Address of the ERC721 token on this domain.
   * @param _remoteToken Address of the ERC721 token on the other domain.
   * @param _to Address to receive the token on this domain.
   * @param _tokenId ID of the token being deposited.
   */
  finalizeBridgeERC721(
    _localToken: string,
    _remoteToken: BytesLike,
    _from: BytesLike,
    _to: string,
    _tokenId: BigNumberish,
    _extraData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initializes the contract.
   * @param _messenger Contract of the CrossDomainMessenger on this network.
   * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
   */
  initialize(
    _messenger: string,
    _superchainConfig: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Messenger contract on this domain.
   */
  messenger(overrides?: CallOverrides): Promise<string>;

  /**
   * Contract of the bridge on the other network.
   */
  otherBridge(overrides?: CallOverrides): Promise<string>;

  /**
   * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
   */
  paused(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Address of the SuperchainConfig contract.
   */
  superchainConfig(overrides?: CallOverrides): Promise<string>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<string>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<string>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token         by ID was deposited for a given L2 token.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Encode L2 message for bridge ERC721 from L1 to L2.
     * @param _extraData Optional data to forward to the other domain. Data supplied here will                     not be used to execute any code on the other domain and is only emitted                     as extra data for the convenience of off-chain tooling.
     * @param _from Address of the sender on this domain.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    encodeBridgeERC721L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Completes an ERC721 bridge from the other domain and sends the ERC721 token to the         recipient on this domain.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _from Address that triggered the bridge on the other domain.
     * @param _localToken Address of the ERC721 token on this domain.
     * @param _remoteToken Address of the ERC721 token on the other domain.
     * @param _to Address to receive the token on this domain.
     * @param _tokenId ID of the token being deposited.
     */
    finalizeBridgeERC721(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Initializes the contract.
     * @param _messenger Contract of the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<string>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<string>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<string>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "ERC721BridgeFinalized(address,bytes32,bytes32,address,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeFinalizedEventFilter;
    ERC721BridgeFinalized(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: BytesLike | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeFinalizedEventFilter;

    "ERC721BridgeInitiated(address,bytes32,address,bytes32,uint256,bytes)"(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeInitiatedEventFilter;
    ERC721BridgeInitiated(
      localToken?: string | null,
      remoteToken?: BytesLike | null,
      from?: string | null,
      to?: null,
      tokenId?: null,
      extraData?: null
    ): ERC721BridgeInitiatedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;
  };

  estimateGas: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token         by ID was deposited for a given L2 token.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Encode L2 message for bridge ERC721 from L1 to L2.
     * @param _extraData Optional data to forward to the other domain. Data supplied here will                     not be used to execute any code on the other domain and is only emitted                     as extra data for the convenience of off-chain tooling.
     * @param _from Address of the sender on this domain.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    encodeBridgeERC721L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Completes an ERC721 bridge from the other domain and sends the ERC721 token to the         recipient on this domain.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _from Address that triggered the bridge on the other domain.
     * @param _localToken Address of the ERC721 token on this domain.
     * @param _remoteToken Address of the ERC721 token on the other domain.
     * @param _to Address to receive the token on this domain.
     * @param _tokenId ID of the token being deposited.
     */
    finalizeBridgeERC721(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initializes the contract.
     * @param _messenger Contract of the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Legacy getter for messenger contract.         Public getter is legacy and will be removed in the future. Use `messenger` instead.
     */
    MESSENGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Legacy getter for other bridge address.         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.
     */
    OTHER_BRIDGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Initiates a bridge of an NFT to the caller's account on the other chain. Note that         this function can only be called by EOAs. Smart contract wallets should use the         `bridgeERC721To` function after ensuring that the recipient address on the remote         chain exists. Also note that the current owner of the token on this chain must         approve this contract to operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     */
    bridgeERC721(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initiates a bridge of an NFT to some recipient's account on the other chain. Note         that the current owner of the token on this chain must approve this contract to         operate the NFT before it can be bridged.         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This         bridge only supports ERC721s originally deployed on Ethereum. Users will need to         wait for the one-week challenge period to elapse before their Optimism-native NFT         can be refunded on L2.
     * @param _extraData Optional data to forward to the other chain. Data supplied here will not                     be used to execute any code on the other chain and is only emitted as                     extra data for the convenience of off-chain tooling.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    bridgeERC721To(
      _localToken: string,
      _remoteToken: BytesLike,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _minGasLimit: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token         by ID was deposited for a given L2 token.
     */
    deposits(
      arg0: string,
      arg1: BytesLike,
      arg2: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Encode L2 message for bridge ERC721 from L1 to L2.
     * @param _extraData Optional data to forward to the other domain. Data supplied here will                     not be used to execute any code on the other domain and is only emitted                     as extra data for the convenience of off-chain tooling.
     * @param _from Address of the sender on this domain.
     * @param _localToken Address of the ERC721 on this domain.
     * @param _remoteToken Address of the ERC721 on the remote domain.
     * @param _to Address to receive the token on the other domain.
     * @param _tokenId Token ID to bridge.
     */
    encodeBridgeERC721L2Message(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: string,
      _to: BytesLike,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Completes an ERC721 bridge from the other domain and sends the ERC721 token to the         recipient on this domain.
     * @param _extraData Optional data to forward to L2.                     Data supplied here will not be used to execute any code on L2 and is                     only emitted as extra data for the convenience of off-chain tooling.
     * @param _from Address that triggered the bridge on the other domain.
     * @param _localToken Address of the ERC721 token on this domain.
     * @param _remoteToken Address of the ERC721 token on the other domain.
     * @param _to Address to receive the token on this domain.
     * @param _tokenId ID of the token being deposited.
     */
    finalizeBridgeERC721(
      _localToken: string,
      _remoteToken: BytesLike,
      _from: BytesLike,
      _to: string,
      _tokenId: BigNumberish,
      _extraData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initializes the contract.
     * @param _messenger Contract of the CrossDomainMessenger on this network.
     * @param _superchainConfig Contract of the SuperchainConfig contract on this network.
     */
    initialize(
      _messenger: string,
      _superchainConfig: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Messenger contract on this domain.
     */
    messenger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Contract of the bridge on the other network.
     */
    otherBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function should return true if the contract is paused.         On L1 this function will check the SuperchainConfig for its paused status.         On L2 this function should be a no-op.
     */
    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the SuperchainConfig contract.
     */
    superchainConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
